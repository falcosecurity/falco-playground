(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/path-browserify/index.js
  var require_path_browserify = __commonJS({
    "node_modules/path-browserify/index.js"(exports, module) {
      "use strict";
      function assertPath(path5) {
        if (typeof path5 !== "string") {
          throw new TypeError("Path must be a string. Received " + JSON.stringify(path5));
        }
      }
      function normalizeStringPosix(path5, allowAboveRoot) {
        var res = "";
        var lastSegmentLength = 0;
        var lastSlash = -1;
        var dots = 0;
        var code;
        for (var i = 0; i <= path5.length; ++i) {
          if (i < path5.length)
            code = path5.charCodeAt(i);
          else if (code === 47)
            break;
          else
            code = 47;
          if (code === 47) {
            if (lastSlash === i - 1 || dots === 1) {
            } else if (lastSlash !== i - 1 && dots === 2) {
              if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                if (res.length > 2) {
                  var lastSlashIndex = res.lastIndexOf("/");
                  if (lastSlashIndex !== res.length - 1) {
                    if (lastSlashIndex === -1) {
                      res = "";
                      lastSegmentLength = 0;
                    } else {
                      res = res.slice(0, lastSlashIndex);
                      lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                    }
                    lastSlash = i;
                    dots = 0;
                    continue;
                  }
                } else if (res.length === 2 || res.length === 1) {
                  res = "";
                  lastSegmentLength = 0;
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              }
              if (allowAboveRoot) {
                if (res.length > 0)
                  res += "/..";
                else
                  res = "..";
                lastSegmentLength = 2;
              }
            } else {
              if (res.length > 0)
                res += "/" + path5.slice(lastSlash + 1, i);
              else
                res = path5.slice(lastSlash + 1, i);
              lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
          } else if (code === 46 && dots !== -1) {
            ++dots;
          } else {
            dots = -1;
          }
        }
        return res;
      }
      function _format3(sep2, pathObject) {
        var dir = pathObject.dir || pathObject.root;
        var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir) {
          return base;
        }
        if (dir === pathObject.root) {
          return dir + base;
        }
        return dir + sep2 + base;
      }
      var posix2 = {
        // path.resolve([from ...], to)
        resolve: function resolve3() {
          var resolvedPath = "";
          var resolvedAbsolute = false;
          var cwd2;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path5;
            if (i >= 0)
              path5 = arguments[i];
            else {
              if (cwd2 === void 0)
                cwd2 = process.cwd();
              path5 = cwd2;
            }
            assertPath(path5);
            if (path5.length === 0) {
              continue;
            }
            resolvedPath = path5 + "/" + resolvedPath;
            resolvedAbsolute = path5.charCodeAt(0) === 47;
          }
          resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
          if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
              return "/" + resolvedPath;
            else
              return "/";
          } else if (resolvedPath.length > 0) {
            return resolvedPath;
          } else {
            return ".";
          }
        },
        normalize: function normalize2(path5) {
          assertPath(path5);
          if (path5.length === 0)
            return ".";
          var isAbsolute2 = path5.charCodeAt(0) === 47;
          var trailingSeparator = path5.charCodeAt(path5.length - 1) === 47;
          path5 = normalizeStringPosix(path5, !isAbsolute2);
          if (path5.length === 0 && !isAbsolute2)
            path5 = ".";
          if (path5.length > 0 && trailingSeparator)
            path5 += "/";
          if (isAbsolute2)
            return "/" + path5;
          return path5;
        },
        isAbsolute: function isAbsolute2(path5) {
          assertPath(path5);
          return path5.length > 0 && path5.charCodeAt(0) === 47;
        },
        join: function join() {
          if (arguments.length === 0)
            return ".";
          var joined;
          for (var i = 0; i < arguments.length; ++i) {
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
              if (joined === void 0)
                joined = arg;
              else
                joined += "/" + arg;
            }
          }
          if (joined === void 0)
            return ".";
          return posix2.normalize(joined);
        },
        relative: function relative2(from, to) {
          assertPath(from);
          assertPath(to);
          if (from === to)
            return "";
          from = posix2.resolve(from);
          to = posix2.resolve(to);
          if (from === to)
            return "";
          var fromStart = 1;
          for (; fromStart < from.length; ++fromStart) {
            if (from.charCodeAt(fromStart) !== 47)
              break;
          }
          var fromEnd = from.length;
          var fromLen = fromEnd - fromStart;
          var toStart = 1;
          for (; toStart < to.length; ++toStart) {
            if (to.charCodeAt(toStart) !== 47)
              break;
          }
          var toEnd = to.length;
          var toLen = toEnd - toStart;
          var length = fromLen < toLen ? fromLen : toLen;
          var lastCommonSep = -1;
          var i = 0;
          for (; i <= length; ++i) {
            if (i === length) {
              if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                  return to.slice(toStart + i + 1);
                } else if (i === 0) {
                  return to.slice(toStart + i);
                }
              } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                  lastCommonSep = i;
                } else if (i === 0) {
                  lastCommonSep = 0;
                }
              }
              break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
              break;
            else if (fromCode === 47)
              lastCommonSep = i;
          }
          var out = "";
          for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === 47) {
              if (out.length === 0)
                out += "..";
              else
                out += "/..";
            }
          }
          if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
          else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47)
              ++toStart;
            return to.slice(toStart);
          }
        },
        _makeLong: function _makeLong(path5) {
          return path5;
        },
        dirname: function dirname2(path5) {
          assertPath(path5);
          if (path5.length === 0)
            return ".";
          var code = path5.charCodeAt(0);
          var hasRoot = code === 47;
          var end = -1;
          var matchedSlash = true;
          for (var i = path5.length - 1; i >= 1; --i) {
            code = path5.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                end = i;
                break;
              }
            } else {
              matchedSlash = false;
            }
          }
          if (end === -1)
            return hasRoot ? "/" : ".";
          if (hasRoot && end === 1)
            return "//";
          return path5.slice(0, end);
        },
        basename: function basename5(path5, ext) {
          if (ext !== void 0 && typeof ext !== "string")
            throw new TypeError('"ext" argument must be a string');
          assertPath(path5);
          var start = 0;
          var end = -1;
          var matchedSlash = true;
          var i;
          if (ext !== void 0 && ext.length > 0 && ext.length <= path5.length) {
            if (ext.length === path5.length && ext === path5)
              return "";
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for (i = path5.length - 1; i >= 0; --i) {
              var code = path5.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else {
                if (firstNonSlashEnd === -1) {
                  matchedSlash = false;
                  firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                  if (code === ext.charCodeAt(extIdx)) {
                    if (--extIdx === -1) {
                      end = i;
                    }
                  } else {
                    extIdx = -1;
                    end = firstNonSlashEnd;
                  }
                }
              }
            }
            if (start === end)
              end = firstNonSlashEnd;
            else if (end === -1)
              end = path5.length;
            return path5.slice(start, end);
          } else {
            for (i = path5.length - 1; i >= 0; --i) {
              if (path5.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path5.slice(start, end);
          }
        },
        extname: function extname3(path5) {
          assertPath(path5);
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var preDotState = 0;
          for (var i = path5.length - 1; i >= 0; --i) {
            var code = path5.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return "";
          }
          return path5.slice(startDot, end);
        },
        format: function format5(pathObject) {
          if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
          }
          return _format3("/", pathObject);
        },
        parse: function parse5(path5) {
          assertPath(path5);
          var ret = { root: "", dir: "", base: "", ext: "", name: "" };
          if (path5.length === 0)
            return ret;
          var code = path5.charCodeAt(0);
          var isAbsolute2 = code === 47;
          var start;
          if (isAbsolute2) {
            ret.root = "/";
            start = 1;
          } else {
            start = 0;
          }
          var startDot = -1;
          var startPart = 0;
          var end = -1;
          var matchedSlash = true;
          var i = path5.length - 1;
          var preDotState = 0;
          for (; i >= start; --i) {
            code = path5.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              continue;
            }
            if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
            if (code === 46) {
              if (startDot === -1)
                startDot = i;
              else if (preDotState !== 1)
                preDotState = 1;
            } else if (startDot !== -1) {
              preDotState = -1;
            }
          }
          if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
          preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
              if (startPart === 0 && isAbsolute2)
                ret.base = ret.name = path5.slice(1, end);
              else
                ret.base = ret.name = path5.slice(startPart, end);
            }
          } else {
            if (startPart === 0 && isAbsolute2) {
              ret.name = path5.slice(1, startDot);
              ret.base = path5.slice(1, end);
            } else {
              ret.name = path5.slice(startPart, startDot);
              ret.base = path5.slice(startPart, end);
            }
            ret.ext = path5.slice(startDot, end);
          }
          if (startPart > 0)
            ret.dir = path5.slice(0, startPart - 1);
          else if (isAbsolute2)
            ret.dir = "/";
          return ret;
        },
        sep: "/",
        delimiter: ":",
        win32: null,
        posix: null
      };
      posix2.posix = posix2;
      module.exports = posix2;
    }
  });

  // node_modules/prettier/standalone.js
  var require_standalone = __commonJS({
    "node_modules/prettier/standalone.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var f2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          f2.prettier = e();
        }
      })(function() {
        "use strict";
        var xe = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
        var pt = xe((r0, pu) => {
          var ir = function(e) {
            return e && e.Math == Math && e;
          };
          pu.exports = ir(typeof globalThis == "object" && globalThis) || ir(typeof window == "object" && window) || ir(typeof self == "object" && self) || ir(typeof global == "object" && global) || function() {
            return this;
          }() || Function("return this")();
        });
        var Dt = xe((n0, fu) => {
          fu.exports = function(e) {
            try {
              return !!e();
            } catch {
              return true;
            }
          };
        });
        var yt = xe((u0, Du) => {
          var Mo = Dt();
          Du.exports = !Mo(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        });
        var ar = xe((s0, mu) => {
          var Ro = Dt();
          mu.exports = !Ro(function() {
            var e = function() {
            }.bind();
            return typeof e != "function" || e.hasOwnProperty("prototype");
          });
        });
        var At = xe((i0, du) => {
          var $o = ar(), or = Function.prototype.call;
          du.exports = $o ? or.bind(or) : function() {
            return or.apply(or, arguments);
          };
        });
        var vu = xe((hu) => {
          "use strict";
          var gu = {}.propertyIsEnumerable, yu = Object.getOwnPropertyDescriptor, Vo = yu && !gu.call({ 1: 2 }, 1);
          hu.f = Vo ? function(r) {
            var t = yu(this, r);
            return !!t && t.enumerable;
          } : gu;
        });
        var lr = xe((o0, Cu) => {
          Cu.exports = function(e, r) {
            return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
          };
        });
        var mt = xe((l0, Au) => {
          var Eu = ar(), Fu = Function.prototype, Wr = Fu.call, Wo = Eu && Fu.bind.bind(Wr, Wr);
          Au.exports = Eu ? Wo : function(e) {
            return function() {
              return Wr.apply(e, arguments);
            };
          };
        });
        var Vt = xe((c0, xu) => {
          var Su = mt(), Ho = Su({}.toString), Go = Su("".slice);
          xu.exports = function(e) {
            return Go(Ho(e), 8, -1);
          };
        });
        var Tu = xe((p0, bu) => {
          var Uo = mt(), Jo = Dt(), zo = Vt(), Hr = Object, Xo = Uo("".split);
          bu.exports = Jo(function() {
            return !Hr("z").propertyIsEnumerable(0);
          }) ? function(e) {
            return zo(e) == "String" ? Xo(e, "") : Hr(e);
          } : Hr;
        });
        var cr = xe((f0, Bu) => {
          Bu.exports = function(e) {
            return e == null;
          };
        });
        var Gr = xe((D0, Nu) => {
          var Ko = cr(), Yo = TypeError;
          Nu.exports = function(e) {
            if (Ko(e))
              throw Yo("Can't call method on " + e);
            return e;
          };
        });
        var pr = xe((m0, wu) => {
          var Qo = Tu(), Zo = Gr();
          wu.exports = function(e) {
            return Qo(Zo(e));
          };
        });
        var Jr = xe((d0, _u) => {
          var Ur = typeof document == "object" && document.all, el = typeof Ur > "u" && Ur !== void 0;
          _u.exports = { all: Ur, IS_HTMLDDA: el };
        });
        var ot = xe((g0, Iu) => {
          var Pu = Jr(), tl = Pu.all;
          Iu.exports = Pu.IS_HTMLDDA ? function(e) {
            return typeof e == "function" || e === tl;
          } : function(e) {
            return typeof e == "function";
          };
        });
        var St = xe((y0, Ou) => {
          var ku = ot(), Lu = Jr(), rl = Lu.all;
          Ou.exports = Lu.IS_HTMLDDA ? function(e) {
            return typeof e == "object" ? e !== null : ku(e) || e === rl;
          } : function(e) {
            return typeof e == "object" ? e !== null : ku(e);
          };
        });
        var Wt = xe((h0, ju) => {
          var zr = pt(), nl = ot(), ul = function(e) {
            return nl(e) ? e : void 0;
          };
          ju.exports = function(e, r) {
            return arguments.length < 2 ? ul(zr[e]) : zr[e] && zr[e][r];
          };
        });
        var Xr = xe((v0, qu) => {
          var sl = mt();
          qu.exports = sl({}.isPrototypeOf);
        });
        var Ru = xe((C0, Mu) => {
          var il = Wt();
          Mu.exports = il("navigator", "userAgent") || "";
        });
        var Ju = xe((E0, Uu) => {
          var Gu = pt(), Kr = Ru(), $u = Gu.process, Vu = Gu.Deno, Wu = $u && $u.versions || Vu && Vu.version, Hu = Wu && Wu.v8, dt, fr;
          Hu && (dt = Hu.split("."), fr = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));
          !fr && Kr && (dt = Kr.match(/Edge\/(\d+)/), (!dt || dt[1] >= 74) && (dt = Kr.match(/Chrome\/(\d+)/), dt && (fr = +dt[1])));
          Uu.exports = fr;
        });
        var Yr = xe((F0, Xu) => {
          var zu = Ju(), al = Dt();
          Xu.exports = !!Object.getOwnPropertySymbols && !al(function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && zu && zu < 41;
          });
        });
        var Qr = xe((A0, Ku) => {
          var ol = Yr();
          Ku.exports = ol && !Symbol.sham && typeof Symbol.iterator == "symbol";
        });
        var Zr = xe((S0, Yu) => {
          var ll = Wt(), cl = ot(), pl = Xr(), fl = Qr(), Dl = Object;
          Yu.exports = fl ? function(e) {
            return typeof e == "symbol";
          } : function(e) {
            var r = ll("Symbol");
            return cl(r) && pl(r.prototype, Dl(e));
          };
        });
        var Dr = xe((x0, Qu) => {
          var ml = String;
          Qu.exports = function(e) {
            try {
              return ml(e);
            } catch {
              return "Object";
            }
          };
        });
        var Ht = xe((b0, Zu) => {
          var dl = ot(), gl = Dr(), yl = TypeError;
          Zu.exports = function(e) {
            if (dl(e))
              return e;
            throw yl(gl(e) + " is not a function");
          };
        });
        var mr = xe((T0, es) => {
          var hl = Ht(), vl = cr();
          es.exports = function(e, r) {
            var t = e[r];
            return vl(t) ? void 0 : hl(t);
          };
        });
        var rs = xe((B0, ts) => {
          var en = At(), tn = ot(), rn = St(), Cl = TypeError;
          ts.exports = function(e, r) {
            var t, s;
            if (r === "string" && tn(t = e.toString) && !rn(s = en(t, e)) || tn(t = e.valueOf) && !rn(s = en(t, e)) || r !== "string" && tn(t = e.toString) && !rn(s = en(t, e)))
              return s;
            throw Cl("Can't convert object to primitive value");
          };
        });
        var us = xe((N0, ns) => {
          ns.exports = false;
        });
        var dr = xe((w0, is) => {
          var ss = pt(), El = Object.defineProperty;
          is.exports = function(e, r) {
            try {
              El(ss, e, { value: r, configurable: true, writable: true });
            } catch {
              ss[e] = r;
            }
            return r;
          };
        });
        var gr = xe((_0, os) => {
          var Fl = pt(), Al = dr(), as = "__core-js_shared__", Sl = Fl[as] || Al(as, {});
          os.exports = Sl;
        });
        var nn = xe((P0, cs) => {
          var xl = us(), ls = gr();
          (cs.exports = function(e, r) {
            return ls[e] || (ls[e] = r !== void 0 ? r : {});
          })("versions", []).push({ version: "3.26.1", mode: xl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
        });
        var yr = xe((I0, ps) => {
          var bl = Gr(), Tl = Object;
          ps.exports = function(e) {
            return Tl(bl(e));
          };
        });
        var Ct = xe((k0, fs) => {
          var Bl = mt(), Nl = yr(), wl = Bl({}.hasOwnProperty);
          fs.exports = Object.hasOwn || function(r, t) {
            return wl(Nl(r), t);
          };
        });
        var un = xe((L0, Ds) => {
          var _l = mt(), Pl = 0, Il = Math.random(), kl = _l(1 .toString);
          Ds.exports = function(e) {
            return "Symbol(" + (e === void 0 ? "" : e) + ")_" + kl(++Pl + Il, 36);
          };
        });
        var bt = xe((O0, hs) => {
          var Ll = pt(), Ol = nn(), ms = Ct(), jl = un(), ds = Yr(), ys = Qr(), It = Ol("wks"), xt = Ll.Symbol, gs = xt && xt.for, ql = ys ? xt : xt && xt.withoutSetter || jl;
          hs.exports = function(e) {
            if (!ms(It, e) || !(ds || typeof It[e] == "string")) {
              var r = "Symbol." + e;
              ds && ms(xt, e) ? It[e] = xt[e] : ys && gs ? It[e] = gs(r) : It[e] = ql(r);
            }
            return It[e];
          };
        });
        var Fs = xe((j0, Es) => {
          var Ml = At(), vs = St(), Cs = Zr(), Rl = mr(), $l = rs(), Vl = bt(), Wl = TypeError, Hl = Vl("toPrimitive");
          Es.exports = function(e, r) {
            if (!vs(e) || Cs(e))
              return e;
            var t = Rl(e, Hl), s;
            if (t) {
              if (r === void 0 && (r = "default"), s = Ml(t, e, r), !vs(s) || Cs(s))
                return s;
              throw Wl("Can't convert object to primitive value");
            }
            return r === void 0 && (r = "number"), $l(e, r);
          };
        });
        var hr = xe((q0, As) => {
          var Gl = Fs(), Ul = Zr();
          As.exports = function(e) {
            var r = Gl(e, "string");
            return Ul(r) ? r : r + "";
          };
        });
        var bs = xe((M0, xs) => {
          var Jl = pt(), Ss = St(), sn = Jl.document, zl = Ss(sn) && Ss(sn.createElement);
          xs.exports = function(e) {
            return zl ? sn.createElement(e) : {};
          };
        });
        var an = xe((R0, Ts) => {
          var Xl = yt(), Kl = Dt(), Yl = bs();
          Ts.exports = !Xl && !Kl(function() {
            return Object.defineProperty(Yl("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        });
        var on = xe((Ns) => {
          var Ql = yt(), Zl = At(), ec = vu(), tc = lr(), rc = pr(), nc = hr(), uc = Ct(), sc = an(), Bs = Object.getOwnPropertyDescriptor;
          Ns.f = Ql ? Bs : function(r, t) {
            if (r = rc(r), t = nc(t), sc)
              try {
                return Bs(r, t);
              } catch {
              }
            if (uc(r, t))
              return tc(!Zl(ec.f, r, t), r[t]);
          };
        });
        var _s = xe((V0, ws) => {
          var ic = yt(), ac = Dt();
          ws.exports = ic && ac(function() {
            return Object.defineProperty(function() {
            }, "prototype", { value: 42, writable: false }).prototype != 42;
          });
        });
        var Tt = xe((W0, Ps) => {
          var oc = St(), lc = String, cc = TypeError;
          Ps.exports = function(e) {
            if (oc(e))
              return e;
            throw cc(lc(e) + " is not an object");
          };
        });
        var kt = xe((ks) => {
          var pc = yt(), fc = an(), Dc = _s(), vr = Tt(), Is2 = hr(), mc = TypeError, ln = Object.defineProperty, dc = Object.getOwnPropertyDescriptor, cn = "enumerable", pn = "configurable", fn = "writable";
          ks.f = pc ? Dc ? function(r, t, s) {
            if (vr(r), t = Is2(t), vr(s), typeof r == "function" && t === "prototype" && "value" in s && fn in s && !s[fn]) {
              var a2 = dc(r, t);
              a2 && a2[fn] && (r[t] = s.value, s = { configurable: pn in s ? s[pn] : a2[pn], enumerable: cn in s ? s[cn] : a2[cn], writable: false });
            }
            return ln(r, t, s);
          } : ln : function(r, t, s) {
            if (vr(r), t = Is2(t), vr(s), fc)
              try {
                return ln(r, t, s);
              } catch {
              }
            if ("get" in s || "set" in s)
              throw mc("Accessors not supported");
            return "value" in s && (r[t] = s.value), r;
          };
        });
        var Dn = xe((G0, Ls) => {
          var gc = yt(), yc = kt(), hc = lr();
          Ls.exports = gc ? function(e, r, t) {
            return yc.f(e, r, hc(1, t));
          } : function(e, r, t) {
            return e[r] = t, e;
          };
        });
        var qs = xe((U0, js) => {
          var mn = yt(), vc = Ct(), Os = Function.prototype, Cc = mn && Object.getOwnPropertyDescriptor, dn = vc(Os, "name"), Ec = dn && function() {
          }.name === "something", Fc = dn && (!mn || mn && Cc(Os, "name").configurable);
          js.exports = { EXISTS: dn, PROPER: Ec, CONFIGURABLE: Fc };
        });
        var yn = xe((J0, Ms) => {
          var Ac = mt(), Sc = ot(), gn = gr(), xc = Ac(Function.toString);
          Sc(gn.inspectSource) || (gn.inspectSource = function(e) {
            return xc(e);
          });
          Ms.exports = gn.inspectSource;
        });
        var Vs = xe((z0, $s) => {
          var bc = pt(), Tc = ot(), Rs = bc.WeakMap;
          $s.exports = Tc(Rs) && /native code/.test(String(Rs));
        });
        var Gs = xe((X0, Hs) => {
          var Bc = nn(), Nc = un(), Ws = Bc("keys");
          Hs.exports = function(e) {
            return Ws[e] || (Ws[e] = Nc(e));
          };
        });
        var hn = xe((K0, Us) => {
          Us.exports = {};
        });
        var Ks = xe((Y0, Xs) => {
          var wc = Vs(), zs = pt(), _c = St(), Pc = Dn(), vn = Ct(), Cn = gr(), Ic = Gs(), kc = hn(), Js = "Object already initialized", En = zs.TypeError, Lc = zs.WeakMap, Cr, Gt, Er, Oc = function(e) {
            return Er(e) ? Gt(e) : Cr(e, {});
          }, jc = function(e) {
            return function(r) {
              var t;
              if (!_c(r) || (t = Gt(r)).type !== e)
                throw En("Incompatible receiver, " + e + " required");
              return t;
            };
          };
          wc || Cn.state ? (gt = Cn.state || (Cn.state = new Lc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, Cr = function(e, r) {
            if (gt.has(e))
              throw En(Js);
            return r.facade = e, gt.set(e, r), r;
          }, Gt = function(e) {
            return gt.get(e) || {};
          }, Er = function(e) {
            return gt.has(e);
          }) : (Bt = Ic("state"), kc[Bt] = true, Cr = function(e, r) {
            if (vn(e, Bt))
              throw En(Js);
            return r.facade = e, Pc(e, Bt, r), r;
          }, Gt = function(e) {
            return vn(e, Bt) ? e[Bt] : {};
          }, Er = function(e) {
            return vn(e, Bt);
          });
          var gt, Bt;
          Xs.exports = { set: Cr, get: Gt, has: Er, enforce: Oc, getterFor: jc };
        });
        var An = xe((Q0, Qs) => {
          var qc = Dt(), Mc = ot(), Fr = Ct(), Fn = yt(), Rc = qs().CONFIGURABLE, $c = yn(), Ys = Ks(), Vc = Ys.enforce, Wc = Ys.get, Ar = Object.defineProperty, Hc = Fn && !qc(function() {
            return Ar(function() {
            }, "length", { value: 8 }).length !== 8;
          }), Gc = String(String).split("String"), Uc = Qs.exports = function(e, r, t) {
            String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Fr(e, "name") || Rc && e.name !== r) && (Fn ? Ar(e, "name", { value: r, configurable: true }) : e.name = r), Hc && t && Fr(t, "arity") && e.length !== t.arity && Ar(e, "length", { value: t.arity });
            try {
              t && Fr(t, "constructor") && t.constructor ? Fn && Ar(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
            } catch {
            }
            var s = Vc(e);
            return Fr(s, "source") || (s.source = Gc.join(typeof r == "string" ? r : "")), e;
          };
          Function.prototype.toString = Uc(function() {
            return Mc(this) && Wc(this).source || $c(this);
          }, "toString");
        });
        var ei = xe((Z0, Zs) => {
          var Jc = ot(), zc = kt(), Xc = An(), Kc = dr();
          Zs.exports = function(e, r, t, s) {
            s || (s = {});
            var a2 = s.enumerable, n = s.name !== void 0 ? s.name : r;
            if (Jc(t) && Xc(t, n, s), s.global)
              a2 ? e[r] = t : Kc(r, t);
            else {
              try {
                s.unsafe ? e[r] && (a2 = true) : delete e[r];
              } catch {
              }
              a2 ? e[r] = t : zc.f(e, r, { value: t, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
            }
            return e;
          };
        });
        var ri = xe((ey, ti) => {
          var Yc = Math.ceil, Qc = Math.floor;
          ti.exports = Math.trunc || function(r) {
            var t = +r;
            return (t > 0 ? Qc : Yc)(t);
          };
        });
        var Sr = xe((ty, ni) => {
          var Zc = ri();
          ni.exports = function(e) {
            var r = +e;
            return r !== r || r === 0 ? 0 : Zc(r);
          };
        });
        var si = xe((ry, ui) => {
          var ep = Sr(), tp = Math.max, rp = Math.min;
          ui.exports = function(e, r) {
            var t = ep(e);
            return t < 0 ? tp(t + r, 0) : rp(t, r);
          };
        });
        var ai = xe((ny, ii) => {
          var np = Sr(), up = Math.min;
          ii.exports = function(e) {
            return e > 0 ? up(np(e), 9007199254740991) : 0;
          };
        });
        var Lt = xe((uy, oi) => {
          var sp = ai();
          oi.exports = function(e) {
            return sp(e.length);
          };
        });
        var pi = xe((sy, ci) => {
          var ip = pr(), ap = si(), op = Lt(), li = function(e) {
            return function(r, t, s) {
              var a2 = ip(r), n = op(a2), u = ap(s, n), i;
              if (e && t != t) {
                for (; n > u; )
                  if (i = a2[u++], i != i)
                    return true;
              } else
                for (; n > u; u++)
                  if ((e || u in a2) && a2[u] === t)
                    return e || u || 0;
              return !e && -1;
            };
          };
          ci.exports = { includes: li(true), indexOf: li(false) };
        });
        var mi = xe((iy, Di) => {
          var lp = mt(), Sn = Ct(), cp = pr(), pp = pi().indexOf, fp = hn(), fi = lp([].push);
          Di.exports = function(e, r) {
            var t = cp(e), s = 0, a2 = [], n;
            for (n in t)
              !Sn(fp, n) && Sn(t, n) && fi(a2, n);
            for (; r.length > s; )
              Sn(t, n = r[s++]) && (~pp(a2, n) || fi(a2, n));
            return a2;
          };
        });
        var gi = xe((ay, di) => {
          di.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
        });
        var hi = xe((yi) => {
          var Dp = mi(), mp = gi(), dp = mp.concat("length", "prototype");
          yi.f = Object.getOwnPropertyNames || function(r) {
            return Dp(r, dp);
          };
        });
        var Ci = xe((vi) => {
          vi.f = Object.getOwnPropertySymbols;
        });
        var Fi = xe((cy, Ei) => {
          var gp = Wt(), yp = mt(), hp = hi(), vp = Ci(), Cp = Tt(), Ep = yp([].concat);
          Ei.exports = gp("Reflect", "ownKeys") || function(r) {
            var t = hp.f(Cp(r)), s = vp.f;
            return s ? Ep(t, s(r)) : t;
          };
        });
        var xi = xe((py, Si) => {
          var Ai = Ct(), Fp = Fi(), Ap = on(), Sp = kt();
          Si.exports = function(e, r, t) {
            for (var s = Fp(r), a2 = Sp.f, n = Ap.f, u = 0; u < s.length; u++) {
              var i = s[u];
              !Ai(e, i) && !(t && Ai(t, i)) && a2(e, i, n(r, i));
            }
          };
        });
        var Ti = xe((fy, bi) => {
          var xp = Dt(), bp = ot(), Tp = /#|\.prototype\./, Ut = function(e, r) {
            var t = Np[Bp(e)];
            return t == _p ? true : t == wp ? false : bp(r) ? xp(r) : !!r;
          }, Bp = Ut.normalize = function(e) {
            return String(e).replace(Tp, ".").toLowerCase();
          }, Np = Ut.data = {}, wp = Ut.NATIVE = "N", _p = Ut.POLYFILL = "P";
          bi.exports = Ut;
        });
        var Jt = xe((Dy, Bi) => {
          var xn = pt(), Pp = on().f, Ip = Dn(), kp = ei(), Lp = dr(), Op = xi(), jp = Ti();
          Bi.exports = function(e, r) {
            var t = e.target, s = e.global, a2 = e.stat, n, u, i, l, p, y;
            if (s ? u = xn : a2 ? u = xn[t] || Lp(t, {}) : u = (xn[t] || {}).prototype, u)
              for (i in r) {
                if (p = r[i], e.dontCallGetSet ? (y = Pp(u, i), l = y && y.value) : l = u[i], n = jp(s ? i : t + (a2 ? "." : "#") + i, e.forced), !n && l !== void 0) {
                  if (typeof p == typeof l)
                    continue;
                  Op(p, l);
                }
                (e.sham || l && l.sham) && Ip(p, "sham", true), kp(u, i, p, e);
              }
          };
        });
        var bn = xe((my, Ni) => {
          var qp = Vt();
          Ni.exports = Array.isArray || function(r) {
            return qp(r) == "Array";
          };
        });
        var _i = xe((dy, wi) => {
          var Mp = TypeError, Rp = 9007199254740991;
          wi.exports = function(e) {
            if (e > Rp)
              throw Mp("Maximum allowed index exceeded");
            return e;
          };
        });
        var Ii = xe((gy, Pi) => {
          var $p = Vt(), Vp = mt();
          Pi.exports = function(e) {
            if ($p(e) === "Function")
              return Vp(e);
          };
        });
        var Tn = xe((yy, Li) => {
          var ki = Ii(), Wp = Ht(), Hp = ar(), Gp = ki(ki.bind);
          Li.exports = function(e, r) {
            return Wp(e), r === void 0 ? e : Hp ? Gp(e, r) : function() {
              return e.apply(r, arguments);
            };
          };
        });
        var Bn = xe((hy, ji) => {
          "use strict";
          var Up = bn(), Jp = Lt(), zp = _i(), Xp = Tn(), Oi = function(e, r, t, s, a2, n, u, i) {
            for (var l = a2, p = 0, y = u ? Xp(u, i) : false, h, g; p < s; )
              p in t && (h = y ? y(t[p], p, r) : t[p], n > 0 && Up(h) ? (g = Jp(h), l = Oi(e, r, h, g, l, n - 1) - 1) : (zp(l + 1), e[l] = h), l++), p++;
            return l;
          };
          ji.exports = Oi;
        });
        var Ri = xe((vy, Mi) => {
          var Kp = bt(), Yp = Kp("toStringTag"), qi = {};
          qi[Yp] = "z";
          Mi.exports = String(qi) === "[object z]";
        });
        var Nn = xe((Cy, $i) => {
          var Qp = Ri(), Zp = ot(), xr = Vt(), ef = bt(), tf = ef("toStringTag"), rf = Object, nf = xr(function() {
            return arguments;
          }()) == "Arguments", uf = function(e, r) {
            try {
              return e[r];
            } catch {
            }
          };
          $i.exports = Qp ? xr : function(e) {
            var r, t, s;
            return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = uf(r = rf(e), tf)) == "string" ? t : nf ? xr(r) : (s = xr(r)) == "Object" && Zp(r.callee) ? "Arguments" : s;
          };
        });
        var Ji = xe((Ey, Ui) => {
          var sf = mt(), af = Dt(), Vi = ot(), of = Nn(), lf = Wt(), cf = yn(), Wi = function() {
          }, pf = [], Hi = lf("Reflect", "construct"), wn = /^\s*(?:class|function)\b/, ff = sf(wn.exec), Df = !wn.exec(Wi), zt = function(r) {
            if (!Vi(r))
              return false;
            try {
              return Hi(Wi, pf, r), true;
            } catch {
              return false;
            }
          }, Gi = function(r) {
            if (!Vi(r))
              return false;
            switch (of(r)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            try {
              return Df || !!ff(wn, cf(r));
            } catch {
              return true;
            }
          };
          Gi.sham = true;
          Ui.exports = !Hi || af(function() {
            var e;
            return zt(zt.call) || !zt(Object) || !zt(function() {
              e = true;
            }) || e;
          }) ? Gi : zt;
        });
        var Yi = xe((Fy, Ki) => {
          var zi = bn(), mf = Ji(), df = St(), gf = bt(), yf = gf("species"), Xi = Array;
          Ki.exports = function(e) {
            var r;
            return zi(e) && (r = e.constructor, mf(r) && (r === Xi || zi(r.prototype)) ? r = void 0 : df(r) && (r = r[yf], r === null && (r = void 0))), r === void 0 ? Xi : r;
          };
        });
        var _n = xe((Ay, Qi) => {
          var hf = Yi();
          Qi.exports = function(e, r) {
            return new (hf(e))(r === 0 ? 0 : r);
          };
        });
        var Zi = xe(() => {
          "use strict";
          var vf = Jt(), Cf = Bn(), Ef = Ht(), Ff = yr(), Af = Lt(), Sf = _n();
          vf({ target: "Array", proto: true }, { flatMap: function(r) {
            var t = Ff(this), s = Af(t), a2;
            return Ef(r), a2 = Sf(t, 0), a2.length = Cf(a2, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a2;
          } });
        });
        var Pn = xe((by, ea) => {
          ea.exports = {};
        });
        var ra = xe((Ty, ta) => {
          var xf = bt(), bf = Pn(), Tf = xf("iterator"), Bf = Array.prototype;
          ta.exports = function(e) {
            return e !== void 0 && (bf.Array === e || Bf[Tf] === e);
          };
        });
        var In = xe((By, ua) => {
          var Nf = Nn(), na = mr(), wf = cr(), _f = Pn(), Pf = bt(), If = Pf("iterator");
          ua.exports = function(e) {
            if (!wf(e))
              return na(e, If) || na(e, "@@iterator") || _f[Nf(e)];
          };
        });
        var ia = xe((Ny, sa) => {
          var kf = At(), Lf = Ht(), Of = Tt(), jf = Dr(), qf = In(), Mf = TypeError;
          sa.exports = function(e, r) {
            var t = arguments.length < 2 ? qf(e) : r;
            if (Lf(t))
              return Of(kf(t, e));
            throw Mf(jf(e) + " is not iterable");
          };
        });
        var la = xe((wy, oa) => {
          var Rf = At(), aa = Tt(), $f = mr();
          oa.exports = function(e, r, t) {
            var s, a2;
            aa(e);
            try {
              if (s = $f(e, "return"), !s) {
                if (r === "throw")
                  throw t;
                return t;
              }
              s = Rf(s, e);
            } catch (n) {
              a2 = true, s = n;
            }
            if (r === "throw")
              throw t;
            if (a2)
              throw s;
            return aa(s), t;
          };
        });
        var ma = xe((_y, Da) => {
          var Vf = Tn(), Wf = At(), Hf = Tt(), Gf = Dr(), Uf = ra(), Jf = Lt(), ca = Xr(), zf = ia(), Xf = In(), pa = la(), Kf = TypeError, br = function(e, r) {
            this.stopped = e, this.result = r;
          }, fa = br.prototype;
          Da.exports = function(e, r, t) {
            var s = t && t.that, a2 = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = Vf(r, s), p, y, h, g, c, f2, F, _ = function(E) {
              return p && pa(p, "normal", E), new br(true, E);
            }, w = function(E) {
              return a2 ? (Hf(E), i ? l(E[0], E[1], _) : l(E[0], E[1])) : i ? l(E, _) : l(E);
            };
            if (n)
              p = e.iterator;
            else if (u)
              p = e;
            else {
              if (y = Xf(e), !y)
                throw Kf(Gf(e) + " is not iterable");
              if (Uf(y)) {
                for (h = 0, g = Jf(e); g > h; h++)
                  if (c = w(e[h]), c && ca(fa, c))
                    return c;
                return new br(false);
              }
              p = zf(e, y);
            }
            for (f2 = n ? e.next : p.next; !(F = Wf(f2, p)).done; ) {
              try {
                c = w(F.value);
              } catch (E) {
                pa(p, "throw", E);
              }
              if (typeof c == "object" && c && ca(fa, c))
                return c;
            }
            return new br(false);
          };
        });
        var ga = xe((Py, da) => {
          "use strict";
          var Yf = hr(), Qf = kt(), Zf = lr();
          da.exports = function(e, r, t) {
            var s = Yf(r);
            s in e ? Qf.f(e, s, Zf(0, t)) : e[s] = t;
          };
        });
        var ya = xe(() => {
          var eD = Jt(), tD = ma(), rD = ga();
          eD({ target: "Object", stat: true }, { fromEntries: function(r) {
            var t = {};
            return tD(r, function(s, a2) {
              rD(t, s, a2);
            }, { AS_ENTRIES: true }), t;
          } });
        });
        var Ca = xe((Ly, va) => {
          var ha = An(), nD = kt();
          va.exports = function(e, r, t) {
            return t.get && ha(t.get, r, { getter: true }), t.set && ha(t.set, r, { setter: true }), nD.f(e, r, t);
          };
        });
        var Fa = xe((Oy, Ea) => {
          "use strict";
          var uD = Tt();
          Ea.exports = function() {
            var e = uD(this), r = "";
            return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
          };
        });
        var xa = xe(() => {
          var sD = pt(), iD = yt(), aD = Ca(), oD = Fa(), lD = Dt(), Aa = sD.RegExp, Sa = Aa.prototype, cD = iD && lD(function() {
            var e = true;
            try {
              Aa(".", "d");
            } catch {
              e = false;
            }
            var r = {}, t = "", s = e ? "dgimsy" : "gimsy", a2 = function(l, p) {
              Object.defineProperty(r, l, { get: function() {
                return t += p, true;
              } });
            }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
            e && (n.hasIndices = "d");
            for (var u in n)
              a2(u, n[u]);
            var i = Object.getOwnPropertyDescriptor(Sa, "flags").get.call(r);
            return i !== s || t !== s;
          });
          cD && aD(Sa, "flags", { configurable: true, get: oD });
        });
        var ba = xe(() => {
          var pD = Jt(), kn = pt();
          pD({ global: true, forced: kn.globalThis !== kn }, { globalThis: kn });
        });
        var Ta = xe(() => {
          ba();
        });
        var Ba = xe(() => {
          "use strict";
          var fD = Jt(), DD = Bn(), mD = yr(), dD = Lt(), gD = Sr(), yD = _n();
          fD({ target: "Array", proto: true }, { flat: function() {
            var r = arguments.length ? arguments[0] : void 0, t = mD(this), s = dD(t), a2 = yD(t, 0);
            return a2.length = DD(a2, t, t, s, 0, r === void 0 ? 1 : gD(r)), a2;
          } });
        });
        var e0 = xe((Uy, jo) => {
          var hD = ["cliName", "cliCategory", "cliDescription"], vD = ["_"], CD = ["languageId"];
          function Hn(e, r) {
            if (e == null)
              return {};
            var t = ED(e, r), s, a2;
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              for (a2 = 0; a2 < n.length; a2++)
                s = n[a2], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t[s] = e[s]);
            }
            return t;
          }
          function ED(e, r) {
            if (e == null)
              return {};
            var t = {}, s = Object.keys(e), a2, n;
            for (n = 0; n < s.length; n++)
              a2 = s[n], !(r.indexOf(a2) >= 0) && (t[a2] = e[a2]);
            return t;
          }
          Zi();
          ya();
          xa();
          Ta();
          Ba();
          var FD = Object.create, _r = Object.defineProperty, AD = Object.getOwnPropertyDescriptor, Gn = Object.getOwnPropertyNames, SD = Object.getPrototypeOf, xD = Object.prototype.hasOwnProperty, ht = (e, r) => function() {
            return e && (r = (0, e[Gn(e)[0]])(e = 0)), r;
          }, te = (e, r) => function() {
            return r || (0, e[Gn(e)[0]])((r = { exports: {} }).exports, r), r.exports;
          }, Kt = (e, r) => {
            for (var t in r)
              _r(e, t, { get: r[t], enumerable: true });
          }, Pa = (e, r, t, s) => {
            if (r && typeof r == "object" || typeof r == "function")
              for (let a2 of Gn(r))
                !xD.call(e, a2) && a2 !== t && _r(e, a2, { get: () => r[a2], enumerable: !(s = AD(r, a2)) || s.enumerable });
            return e;
          }, bD = (e, r, t) => (t = e != null ? FD(SD(e)) : {}, Pa(r || !e || !e.__esModule ? _r(t, "default", { value: e, enumerable: true }) : t, e)), ft = (e) => Pa(_r({}, "__esModule", { value: true }), e), wt, ne = ht({ "<define:process>"() {
            wt = { env: {}, argv: [] };
          } }), Ia = te({ "package.json"(e, r) {
            r.exports = { version: "2.8.8" };
          } }), TD = te({ "node_modules/diff/lib/diff/base.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
            function r() {
            }
            r.prototype = { diff: function(n, u) {
              var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
              typeof i == "function" && (l = i, i = {}), this.options = i;
              var p = this;
              function y(N) {
                return l ? (setTimeout(function() {
                  l(void 0, N);
                }, 0), true) : N;
              }
              n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
              var h = u.length, g = n.length, c = 1, f2 = h + g, F = [{ newPos: -1, components: [] }], _ = this.extractCommon(F[0], u, n, 0);
              if (F[0].newPos + 1 >= h && _ + 1 >= g)
                return y([{ value: this.join(u), count: u.length }]);
              function w() {
                for (var N = -1 * c; N <= c; N += 2) {
                  var x = void 0, I = F[N - 1], P = F[N + 1], $ = (P ? P.newPos : 0) - N;
                  I && (F[N - 1] = void 0);
                  var D = I && I.newPos + 1 < h, T = P && 0 <= $ && $ < g;
                  if (!D && !T) {
                    F[N] = void 0;
                    continue;
                  }
                  if (!D || T && I.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, true)) : (x = I, x.newPos++, p.pushComponent(x.components, true, void 0)), $ = p.extractCommon(x, u, n, N), x.newPos + 1 >= h && $ + 1 >= g)
                    return y(t(p, x.components, u, n, p.useLongestToken));
                  F[N] = x;
                }
                c++;
              }
              if (l)
                (function N() {
                  setTimeout(function() {
                    if (c > f2)
                      return l();
                    w() || N();
                  }, 0);
                })();
              else
                for (; c <= f2; ) {
                  var E = w();
                  if (E)
                    return E;
                }
            }, pushComponent: function(n, u, i) {
              var l = n[n.length - 1];
              l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
            }, extractCommon: function(n, u, i, l) {
              for (var p = u.length, y = i.length, h = n.newPos, g = h - l, c = 0; h + 1 < p && g + 1 < y && this.equals(u[h + 1], i[g + 1]); )
                h++, g++, c++;
              return c && n.components.push({ count: c }), n.newPos = h, g;
            }, equals: function(n, u) {
              return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
            }, removeEmpty: function(n) {
              for (var u = [], i = 0; i < n.length; i++)
                n[i] && u.push(n[i]);
              return u;
            }, castInput: function(n) {
              return n;
            }, tokenize: function(n) {
              return n.split("");
            }, join: function(n) {
              return n.join("");
            } };
            function t(a2, n, u, i, l) {
              for (var p = 0, y = n.length, h = 0, g = 0; p < y; p++) {
                var c = n[p];
                if (c.removed) {
                  if (c.value = a2.join(i.slice(g, g + c.count)), g += c.count, p && n[p - 1].added) {
                    var F = n[p - 1];
                    n[p - 1] = n[p], n[p] = F;
                  }
                } else {
                  if (!c.added && l) {
                    var f2 = u.slice(h, h + c.count);
                    f2 = f2.map(function(w, E) {
                      var N = i[g + E];
                      return N.length > w.length ? N : w;
                    }), c.value = a2.join(f2);
                  } else
                    c.value = a2.join(u.slice(h, h + c.count));
                  h += c.count, c.added || (g += c.count);
                }
              }
              var _ = n[y - 1];
              return y > 1 && typeof _.value == "string" && (_.added || _.removed) && a2.equals("", _.value) && (n[y - 2].value += _.value, n.pop()), n;
            }
            function s(a2) {
              return { newPos: a2.newPos, components: a2.components.slice(0) };
            }
          } }), BD = te({ "node_modules/diff/lib/diff/array.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a2, e.arrayDiff = void 0;
            var r = t(TD());
            function t(n) {
              return n && n.__esModule ? n : { default: n };
            }
            var s = new r.default();
            e.arrayDiff = s, s.tokenize = function(n) {
              return n.slice();
            }, s.join = s.removeEmpty = function(n) {
              return n;
            };
            function a2(n, u, i) {
              return s.diff(n, u, i);
            }
          } }), Un = te({ "src/document/doc-builders.js"(e, r) {
            "use strict";
            ne();
            function t(C) {
              return { type: "concat", parts: C };
            }
            function s(C) {
              return { type: "indent", contents: C };
            }
            function a2(C, o) {
              return { type: "align", contents: o, n: C };
            }
            function n(C) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
            }
            function u(C) {
              return a2(Number.NEGATIVE_INFINITY, C);
            }
            function i(C) {
              return a2({ type: "root" }, C);
            }
            function l(C) {
              return a2(-1, C);
            }
            function p(C, o) {
              return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
            }
            function y(C) {
              return { type: "fill", parts: C };
            }
            function h(C, o) {
              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return { type: "if-break", breakContents: C, flatContents: o, groupId: d.groupId };
            }
            function g(C, o) {
              return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
            }
            function c(C) {
              return { type: "line-suffix", contents: C };
            }
            var f2 = { type: "line-suffix-boundary" }, F = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, E = { type: "line", hard: true, literal: true }, N = { type: "line" }, x = { type: "line", soft: true }, I = t([w, F]), P = t([E, F]), $ = { type: "cursor", placeholder: Symbol("cursor") };
            function D(C, o) {
              let d = [];
              for (let v = 0; v < o.length; v++)
                v !== 0 && d.push(C), d.push(o[v]);
              return t(d);
            }
            function T(C, o, d) {
              let v = C;
              if (o > 0) {
                for (let S = 0; S < Math.floor(o / d); ++S)
                  v = s(v);
                v = a2(o % d, v), v = a2(Number.NEGATIVE_INFINITY, v);
              }
              return v;
            }
            function m(C, o) {
              return { type: "label", label: C, contents: o };
            }
            r.exports = { concat: t, join: D, line: N, softline: x, hardline: I, literalline: P, group: n, conditionalGroup: p, fill: y, lineSuffix: c, lineSuffixBoundary: f2, cursor: $, breakParent: F, ifBreak: h, trim: _, indent: s, indentIfBreak: g, align: a2, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: E, label: m };
          } }), Jn = te({ "src/common/end-of-line.js"(e, r) {
            "use strict";
            ne();
            function t(u) {
              let i = u.indexOf("\r");
              return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
            }
            function s(u) {
              switch (u) {
                case "cr":
                  return "\r";
                case "crlf":
                  return `\r
`;
                default:
                  return `
`;
              }
            }
            function a2(u, i) {
              let l;
              switch (i) {
                case `
`:
                  l = /\n/g;
                  break;
                case "\r":
                  l = /\r/g;
                  break;
                case `\r
`:
                  l = /\r\n/g;
                  break;
                default:
                  throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
              }
              let p = u.match(l);
              return p ? p.length : 0;
            }
            function n(u) {
              return u.replace(/\r\n?/g, `
`);
            }
            r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a2, normalizeEndOfLine: n };
          } }), lt = te({ "src/utils/get-last.js"(e, r) {
            "use strict";
            ne();
            var t = (s) => s[s.length - 1];
            r.exports = t;
          } });
          function ND() {
            let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
            return new RegExp(r, e ? void 0 : "g");
          }
          var wD = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
            ne();
          } });
          function _D(e) {
            if (typeof e != "string")
              throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
            return e.replace(ND(), "");
          }
          var PD = ht({ "node_modules/strip-ansi/index.js"() {
            ne(), wD();
          } });
          function ID(e) {
            return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
          }
          var kD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
            ne();
          } }), LD = te({ "node_modules/emoji-regex/index.js"(e, r) {
            "use strict";
            ne(), r.exports = function() {
              return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
            };
          } }), ka = {};
          Kt(ka, { default: () => OD });
          function OD(e) {
            if (typeof e != "string" || e.length === 0 || (e = _D(e), e.length === 0))
              return 0;
            e = e.replace((0, La.default)(), "  ");
            let r = 0;
            for (let t = 0; t < e.length; t++) {
              let s = e.codePointAt(t);
              s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += ID(s) ? 2 : 1);
            }
            return r;
          }
          var La, jD = ht({ "node_modules/string-width/index.js"() {
            ne(), PD(), kD(), La = bD(LD());
          } }), Oa = te({ "src/utils/get-string-width.js"(e, r) {
            "use strict";
            ne();
            var t = (jD(), ft(ka)).default, s = /[^\x20-\x7F]/;
            function a2(n) {
              return n ? s.test(n) ? t(n) : n.length : 0;
            }
            r.exports = a2;
          } }), Yt = te({ "src/document/doc-utils.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { literalline: s, join: a2 } = Un(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
              if (Array.isArray(o))
                return o;
              if (o.type !== "concat" && o.type !== "fill")
                throw new Error("Expect doc type to be `concat` or `fill`.");
              return o.parts;
            }, i = {};
            function l(o, d, v, S) {
              let b = [o];
              for (; b.length > 0; ) {
                let B = b.pop();
                if (B === i) {
                  v(b.pop());
                  continue;
                }
                if (v && b.push(B, i), !d || d(B) !== false)
                  if (n(B) || B.type === "fill") {
                    let k = u(B);
                    for (let M = k.length, R = M - 1; R >= 0; --R)
                      b.push(k[R]);
                  } else if (B.type === "if-break")
                    B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
                  else if (B.type === "group" && B.expandedStates)
                    if (S)
                      for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M)
                        b.push(B.expandedStates[M]);
                    else
                      b.push(B.contents);
                  else
                    B.contents && b.push(B.contents);
              }
            }
            function p(o, d) {
              let v = /* @__PURE__ */ new Map();
              return S(o);
              function S(B) {
                if (v.has(B))
                  return v.get(B);
                let k = b(B);
                return v.set(B, k), k;
              }
              function b(B) {
                if (Array.isArray(B))
                  return d(B.map(S));
                if (B.type === "concat" || B.type === "fill") {
                  let k = B.parts.map(S);
                  return d(Object.assign(Object.assign({}, B), {}, { parts: k }));
                }
                if (B.type === "if-break") {
                  let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
                  return d(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
                }
                if (B.type === "group" && B.expandedStates) {
                  let k = B.expandedStates.map(S), M = k[0];
                  return d(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
                }
                if (B.contents) {
                  let k = S(B.contents);
                  return d(Object.assign(Object.assign({}, B), {}, { contents: k }));
                }
                return d(B);
              }
            }
            function y(o, d, v) {
              let S = v, b = false;
              function B(k) {
                let M = d(k);
                if (M !== void 0 && (b = true, S = M), b)
                  return false;
              }
              return l(o, B), S;
            }
            function h(o) {
              if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
                return true;
            }
            function g(o) {
              return y(o, h, false);
            }
            function c(o) {
              if (o.length > 0) {
                let d = t(o);
                !d.expandedStates && !d.break && (d.break = "propagated");
              }
              return null;
            }
            function f2(o) {
              let d = /* @__PURE__ */ new Set(), v = [];
              function S(B) {
                if (B.type === "break-parent" && c(v), B.type === "group") {
                  if (v.push(B), d.has(B))
                    return false;
                  d.add(B);
                }
              }
              function b(B) {
                B.type === "group" && v.pop().break && c(v);
              }
              l(o, S, b, true);
            }
            function F(o) {
              return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
            }
            function _(o) {
              return p(o, F);
            }
            var w = (o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent";
            function E(o) {
              if (!o)
                return o;
              if (n(o) || o.type === "fill") {
                let d = u(o);
                for (; d.length > 1 && w(...d.slice(-2)); )
                  d.length -= 2;
                if (d.length > 0) {
                  let v = E(t(d));
                  d[d.length - 1] = v;
                }
                return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
              }
              switch (o.type) {
                case "align":
                case "indent":
                case "indent-if-break":
                case "group":
                case "line-suffix":
                case "label": {
                  let d = E(o.contents);
                  return Object.assign(Object.assign({}, o), {}, { contents: d });
                }
                case "if-break": {
                  let d = E(o.breakContents), v = E(o.flatContents);
                  return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: v });
                }
              }
              return o;
            }
            function N(o) {
              return E(I(o));
            }
            function x(o) {
              switch (o.type) {
                case "fill":
                  if (o.parts.every((v) => v === ""))
                    return "";
                  break;
                case "group":
                  if (!o.contents && !o.id && !o.break && !o.expandedStates)
                    return "";
                  if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                    return o.contents;
                  break;
                case "align":
                case "indent":
                case "indent-if-break":
                case "line-suffix":
                  if (!o.contents)
                    return "";
                  break;
                case "if-break":
                  if (!o.flatContents && !o.breakContents)
                    return "";
                  break;
              }
              if (!n(o))
                return o;
              let d = [];
              for (let v of u(o)) {
                if (!v)
                  continue;
                let [S, ...b] = n(v) ? u(v) : [v];
                typeof S == "string" && typeof t(d) == "string" ? d[d.length - 1] += S : d.push(S), d.push(...b);
              }
              return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            function I(o) {
              return p(o, (d) => x(d));
            }
            function P(o) {
              let d = [], v = o.filter(Boolean);
              for (; v.length > 0; ) {
                let S = v.shift();
                if (S) {
                  if (n(S)) {
                    v.unshift(...u(S));
                    continue;
                  }
                  if (d.length > 0 && typeof t(d) == "string" && typeof S == "string") {
                    d[d.length - 1] += S;
                    continue;
                  }
                  d.push(S);
                }
              }
              return d;
            }
            function $(o) {
              return p(o, (d) => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P(d.parts) }) : d);
            }
            function D(o) {
              return p(o, (d) => typeof d == "string" && d.includes(`
`) ? T(d) : d);
            }
            function T(o) {
              let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
              return a2(d, o.split(`
`)).parts;
            }
            function m(o) {
              if (o.type === "line")
                return true;
            }
            function C(o) {
              return y(o, m, false);
            }
            r.exports = { isConcat: n, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: p, propagateBreaks: f2, removeLines: _, stripTrailingHardline: N, normalizeParts: P, normalizeDoc: $, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
          } }), qD = te({ "src/document/doc-printer.js"(e, r) {
            "use strict";
            ne();
            var { convertEndOfLineToChars: t } = Jn(), s = lt(), a2 = Oa(), { fill: n, cursor: u, indent: i } = Un(), { isConcat: l, getDocParts: p } = Yt(), y, h = 1, g = 2;
            function c() {
              return { value: "", length: 0, queue: [] };
            }
            function f2(x, I) {
              return _(x, { type: "indent" }, I);
            }
            function F(x, I, P) {
              return I === Number.NEGATIVE_INFINITY ? x.root || c() : I < 0 ? _(x, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x), {}, { root: x }) : _(x, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x;
            }
            function _(x, I, P) {
              let $ = I.type === "dedent" ? x.queue.slice(0, -1) : [...x.queue, I], D = "", T = 0, m = 0, C = 0;
              for (let k of $)
                switch (k.type) {
                  case "indent":
                    v(), P.useTabs ? o(1) : d(P.tabWidth);
                    break;
                  case "stringAlign":
                    v(), D += k.n, T += k.n.length;
                    break;
                  case "numberAlign":
                    m += 1, C += k.n;
                    break;
                  default:
                    throw new Error(`Unexpected type '${k.type}'`);
                }
              return b(), Object.assign(Object.assign({}, x), {}, { value: D, length: T, queue: $ });
              function o(k) {
                D += "	".repeat(k), T += P.tabWidth * k;
              }
              function d(k) {
                D += " ".repeat(k), T += k;
              }
              function v() {
                P.useTabs ? S() : b();
              }
              function S() {
                m > 0 && o(m), B();
              }
              function b() {
                C > 0 && d(C), B();
              }
              function B() {
                m = 0, C = 0;
              }
            }
            function w(x) {
              if (x.length === 0)
                return 0;
              let I = 0;
              for (; x.length > 0 && typeof s(x) == "string" && /^[\t ]*$/.test(s(x)); )
                I += x.pop().length;
              if (x.length > 0 && typeof s(x) == "string") {
                let P = s(x).replace(/[\t ]*$/, "");
                I += s(x).length - P.length, x[x.length - 1] = P;
              }
              return I;
            }
            function E(x, I, P, $, D) {
              let T = I.length, m = [x], C = [];
              for (; P >= 0; ) {
                if (m.length === 0) {
                  if (T === 0)
                    return true;
                  m.push(I[--T]);
                  continue;
                }
                let { mode: o, doc: d } = m.pop();
                if (typeof d == "string")
                  C.push(d), P -= a2(d);
                else if (l(d) || d.type === "fill") {
                  let v = p(d);
                  for (let S = v.length - 1; S >= 0; S--)
                    m.push({ mode: o, doc: v[S] });
                } else
                  switch (d.type) {
                    case "indent":
                    case "align":
                    case "indent-if-break":
                    case "label":
                      m.push({ mode: o, doc: d.contents });
                      break;
                    case "trim":
                      P += w(C);
                      break;
                    case "group": {
                      if (D && d.break)
                        return false;
                      let v = d.break ? h : o, S = d.expandedStates && v === h ? s(d.expandedStates) : d.contents;
                      m.push({ mode: v, doc: S });
                      break;
                    }
                    case "if-break": {
                      let S = (d.groupId ? y[d.groupId] || g : o) === h ? d.breakContents : d.flatContents;
                      S && m.push({ mode: o, doc: S });
                      break;
                    }
                    case "line":
                      if (o === h || d.hard)
                        return true;
                      d.soft || (C.push(" "), P--);
                      break;
                    case "line-suffix":
                      $ = true;
                      break;
                    case "line-suffix-boundary":
                      if ($)
                        return false;
                      break;
                  }
              }
              return false;
            }
            function N(x, I) {
              y = {};
              let P = I.printWidth, $ = t(I.endOfLine), D = 0, T = [{ ind: c(), mode: h, doc: x }], m = [], C = false, o = [];
              for (; T.length > 0; ) {
                let { ind: v, mode: S, doc: b } = T.pop();
                if (typeof b == "string") {
                  let B = $ !== `
` ? b.replace(/\n/g, $) : b;
                  m.push(B), D += a2(B);
                } else if (l(b)) {
                  let B = p(b);
                  for (let k = B.length - 1; k >= 0; k--)
                    T.push({ ind: v, mode: S, doc: B[k] });
                } else
                  switch (b.type) {
                    case "cursor":
                      m.push(u.placeholder);
                      break;
                    case "indent":
                      T.push({ ind: f2(v, I), mode: S, doc: b.contents });
                      break;
                    case "align":
                      T.push({ ind: F(v, b.n, I), mode: S, doc: b.contents });
                      break;
                    case "trim":
                      D -= w(m);
                      break;
                    case "group":
                      switch (S) {
                        case g:
                          if (!C) {
                            T.push({ ind: v, mode: b.break ? h : g, doc: b.contents });
                            break;
                          }
                        case h: {
                          C = false;
                          let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
                          if (!b.break && E(B, T, k, M))
                            T.push(B);
                          else if (b.expandedStates) {
                            let R = s(b.expandedStates);
                            if (b.break) {
                              T.push({ ind: v, mode: h, doc: R });
                              break;
                            } else
                              for (let q = 1; q < b.expandedStates.length + 1; q++)
                                if (q >= b.expandedStates.length) {
                                  T.push({ ind: v, mode: h, doc: R });
                                  break;
                                } else {
                                  let J = b.expandedStates[q], L = { ind: v, mode: g, doc: J };
                                  if (E(L, T, k, M)) {
                                    T.push(L);
                                    break;
                                  }
                                }
                          } else
                            T.push({ ind: v, mode: h, doc: b.contents });
                          break;
                        }
                      }
                      b.id && (y[b.id] = s(T).mode);
                      break;
                    case "fill": {
                      let B = P - D, { parts: k } = b;
                      if (k.length === 0)
                        break;
                      let [M, R] = k, q = { ind: v, mode: g, doc: M }, J = { ind: v, mode: h, doc: M }, L = E(q, [], B, o.length > 0, true);
                      if (k.length === 1) {
                        L ? T.push(q) : T.push(J);
                        break;
                      }
                      let Q = { ind: v, mode: g, doc: R }, V = { ind: v, mode: h, doc: R };
                      if (k.length === 2) {
                        L ? T.push(Q, q) : T.push(V, J);
                        break;
                      }
                      k.splice(0, 2);
                      let j = { ind: v, mode: S, doc: n(k) }, Y = k[0];
                      E({ ind: v, mode: g, doc: [M, R, Y] }, [], B, o.length > 0, true) ? T.push(j, Q, q) : L ? T.push(j, V, q) : T.push(j, V, J);
                      break;
                    }
                    case "if-break":
                    case "indent-if-break": {
                      let B = b.groupId ? y[b.groupId] : S;
                      if (B === h) {
                        let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                        k && T.push({ ind: v, mode: S, doc: k });
                      }
                      if (B === g) {
                        let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                        k && T.push({ ind: v, mode: S, doc: k });
                      }
                      break;
                    }
                    case "line-suffix":
                      o.push({ ind: v, mode: S, doc: b.contents });
                      break;
                    case "line-suffix-boundary":
                      o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
                      break;
                    case "line":
                      switch (S) {
                        case g:
                          if (b.hard)
                            C = true;
                          else {
                            b.soft || (m.push(" "), D += 1);
                            break;
                          }
                        case h:
                          if (o.length > 0) {
                            T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                            break;
                          }
                          b.literal ? v.root ? (m.push($, v.root.value), D = v.root.length) : (m.push($), D = 0) : (D -= w(m), m.push($ + v.value), D = v.length);
                          break;
                      }
                      break;
                    case "label":
                      T.push({ ind: v, mode: S, doc: b.contents });
                      break;
                    default:
                  }
                T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
              }
              let d = m.indexOf(u.placeholder);
              if (d !== -1) {
                let v = m.indexOf(u.placeholder, d + 1), S = m.slice(0, d).join(""), b = m.slice(d + 1, v).join(""), B = m.slice(v + 1).join("");
                return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
              }
              return { formatted: m.join("") };
            }
            r.exports = { printDocToString: N };
          } }), MD = te({ "src/document/doc-debug.js"(e, r) {
            "use strict";
            ne();
            var { isConcat: t, getDocParts: s } = Yt();
            function a2(u) {
              if (!u)
                return "";
              if (t(u)) {
                let i = [];
                for (let l of s(u))
                  if (t(l))
                    i.push(...a2(l).parts);
                  else {
                    let p = a2(l);
                    p !== "" && i.push(p);
                  }
                return { type: "concat", parts: i };
              }
              return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a2(u.breakContents), flatContents: a2(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a2(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a2) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a2) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a2(u.contents) }) : u;
            }
            function n(u) {
              let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
              return p(a2(u));
              function p(h, g, c) {
                if (typeof h == "string")
                  return JSON.stringify(h);
                if (t(h)) {
                  let f2 = s(h).map(p).filter(Boolean);
                  return f2.length === 1 ? f2[0] : `[${f2.join(", ")}]`;
                }
                if (h.type === "line") {
                  let f2 = Array.isArray(c) && c[g + 1] && c[g + 1].type === "break-parent";
                  return h.literal ? f2 ? "literalline" : "literallineWithoutBreakParent" : h.hard ? f2 ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
                }
                if (h.type === "break-parent")
                  return Array.isArray(c) && c[g - 1] && c[g - 1].type === "line" && c[g - 1].hard ? void 0 : "breakParent";
                if (h.type === "trim")
                  return "trim";
                if (h.type === "indent")
                  return "indent(" + p(h.contents) + ")";
                if (h.type === "align")
                  return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(h.contents) + ")" : h.n < 0 ? "dedent(" + p(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + p(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + p(h.contents) + ")";
                if (h.type === "if-break")
                  return "ifBreak(" + p(h.breakContents) + (h.flatContents ? ", " + p(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + `, { groupId: ${y(h.groupId)} }` : "") + ")";
                if (h.type === "indent-if-break") {
                  let f2 = [];
                  h.negate && f2.push("negate: true"), h.groupId && f2.push(`groupId: ${y(h.groupId)}`);
                  let F = f2.length > 0 ? `, { ${f2.join(", ")} }` : "";
                  return `indentIfBreak(${p(h.contents)}${F})`;
                }
                if (h.type === "group") {
                  let f2 = [];
                  h.break && h.break !== "propagated" && f2.push("shouldBreak: true"), h.id && f2.push(`id: ${y(h.id)}`);
                  let F = f2.length > 0 ? `, { ${f2.join(", ")} }` : "";
                  return h.expandedStates ? `conditionalGroup([${h.expandedStates.map((_) => p(_)).join(",")}]${F})` : `group(${p(h.contents)}${F})`;
                }
                if (h.type === "fill")
                  return `fill([${h.parts.map((f2) => p(f2)).join(", ")}])`;
                if (h.type === "line-suffix")
                  return "lineSuffix(" + p(h.contents) + ")";
                if (h.type === "line-suffix-boundary")
                  return "lineSuffixBoundary";
                if (h.type === "label")
                  return `label(${JSON.stringify(h.label)}, ${p(h.contents)})`;
                throw new Error("Unknown doc type " + h.type);
              }
              function y(h) {
                if (typeof h != "symbol")
                  return JSON.stringify(String(h));
                if (h in i)
                  return i[h];
                let g = String(h).slice(7, -1) || "symbol";
                for (let c = 0; ; c++) {
                  let f2 = g + (c > 0 ? ` #${c}` : "");
                  if (!l.has(f2))
                    return l.add(f2), i[h] = `Symbol.for(${JSON.stringify(f2)})`;
                }
              }
            }
            r.exports = { printDocToDebug: n };
          } }), qe = te({ "src/document/index.js"(e, r) {
            "use strict";
            ne(), r.exports = { builders: Un(), printer: qD(), utils: Yt(), debug: MD() };
          } }), ja = {};
          Kt(ja, { default: () => RD });
          function RD(e) {
            if (typeof e != "string")
              throw new TypeError("Expected a string");
            return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
          }
          var $D = ht({ "node_modules/escape-string-regexp/index.js"() {
            ne();
          } }), qa = te({ "node_modules/semver/internal/debug.js"(e, r) {
            ne();
            var t = typeof wt == "object" && wt.env && wt.env.NODE_DEBUG && /\bsemver\b/i.test(wt.env.NODE_DEBUG) ? function() {
              for (var s = arguments.length, a2 = new Array(s), n = 0; n < s; n++)
                a2[n] = arguments[n];
              return console.error("SEMVER", ...a2);
            } : () => {
            };
            r.exports = t;
          } }), Ma = te({ "node_modules/semver/internal/constants.js"(e, r) {
            ne();
            var t = "2.0.0", s = 256, a2 = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
            r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a2, MAX_SAFE_COMPONENT_LENGTH: n };
          } }), VD = te({ "node_modules/semver/internal/re.js"(e, r) {
            ne();
            var { MAX_SAFE_COMPONENT_LENGTH: t } = Ma(), s = qa();
            e = r.exports = {};
            var a2 = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p, y, h) => {
              let g = i++;
              s(p, g, y), u[p] = g, n[g] = y, a2[g] = new RegExp(y, h ? "g" : void 0);
            };
            l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
          } }), WD = te({ "node_modules/semver/internal/parse-options.js"(e, r) {
            ne();
            var t = ["includePrerelease", "loose", "rtl"], s = (a2) => a2 ? typeof a2 != "object" ? { loose: true } : t.filter((n) => a2[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
            r.exports = s;
          } }), HD = te({ "node_modules/semver/internal/identifiers.js"(e, r) {
            ne();
            var t = /^[0-9]+$/, s = (n, u) => {
              let i = t.test(n), l = t.test(u);
              return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
            }, a2 = (n, u) => s(u, n);
            r.exports = { compareIdentifiers: s, rcompareIdentifiers: a2 };
          } }), GD = te({ "node_modules/semver/classes/semver.js"(e, r) {
            ne();
            var t = qa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a2 } = Ma(), { re: n, t: u } = VD(), i = WD(), { compareIdentifiers: l } = HD(), p = class {
              constructor(y, h) {
                if (h = i(h), y instanceof p) {
                  if (y.loose === !!h.loose && y.includePrerelease === !!h.includePrerelease)
                    return y;
                  y = y.version;
                } else if (typeof y != "string")
                  throw new TypeError(`Invalid Version: ${y}`);
                if (y.length > s)
                  throw new TypeError(`version is longer than ${s} characters`);
                t("SemVer", y, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
                let g = y.trim().match(h.loose ? n[u.LOOSE] : n[u.FULL]);
                if (!g)
                  throw new TypeError(`Invalid Version: ${y}`);
                if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a2 || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > a2 || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > a2 || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                g[4] ? this.prerelease = g[4].split(".").map((c) => {
                  if (/^[0-9]+$/.test(c)) {
                    let f2 = +c;
                    if (f2 >= 0 && f2 < a2)
                      return f2;
                  }
                  return c;
                }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
              }
              format() {
                return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
              }
              toString() {
                return this.version;
              }
              compare(y) {
                if (t("SemVer.compare", this.version, this.options, y), !(y instanceof p)) {
                  if (typeof y == "string" && y === this.version)
                    return 0;
                  y = new p(y, this.options);
                }
                return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
              }
              compareMain(y) {
                return y instanceof p || (y = new p(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
              }
              comparePre(y) {
                if (y instanceof p || (y = new p(y, this.options)), this.prerelease.length && !y.prerelease.length)
                  return -1;
                if (!this.prerelease.length && y.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !y.prerelease.length)
                  return 0;
                let h = 0;
                do {
                  let g = this.prerelease[h], c = y.prerelease[h];
                  if (t("prerelease compare", h, g, c), g === void 0 && c === void 0)
                    return 0;
                  if (c === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === c)
                    continue;
                  return l(g, c);
                } while (++h);
              }
              compareBuild(y) {
                y instanceof p || (y = new p(y, this.options));
                let h = 0;
                do {
                  let g = this.build[h], c = y.build[h];
                  if (t("prerelease compare", h, g, c), g === void 0 && c === void 0)
                    return 0;
                  if (c === void 0)
                    return 1;
                  if (g === void 0)
                    return -1;
                  if (g === c)
                    continue;
                  return l(g, c);
                } while (++h);
              }
              inc(y, h) {
                switch (y) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                    break;
                  case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let g = this.prerelease.length;
                      for (; --g >= 0; )
                        typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                      g === -1 && this.prerelease.push(0);
                    }
                    h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                    break;
                  default:
                    throw new Error(`invalid increment argument: ${y}`);
                }
                return this.format(), this.raw = this.version, this;
              }
            };
            r.exports = p;
          } }), zn = te({ "node_modules/semver/functions/compare.js"(e, r) {
            ne();
            var t = GD(), s = (a2, n, u) => new t(a2, u).compare(new t(n, u));
            r.exports = s;
          } }), UD = te({ "node_modules/semver/functions/lt.js"(e, r) {
            ne();
            var t = zn(), s = (a2, n, u) => t(a2, n, u) < 0;
            r.exports = s;
          } }), JD = te({ "node_modules/semver/functions/gte.js"(e, r) {
            ne();
            var t = zn(), s = (a2, n, u) => t(a2, n, u) >= 0;
            r.exports = s;
          } }), zD = te({ "src/utils/arrayify.js"(e, r) {
            "use strict";
            ne(), r.exports = (t, s) => Object.entries(t).map((a2) => {
              let [n, u] = a2;
              return Object.assign({ [s]: n }, u);
            });
          } }), XD = te({ "node_modules/outdent/lib/index.js"(e, r) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
            function t() {
              for (var E = [], N = 0; N < arguments.length; N++)
                E[N] = arguments[N];
            }
            function s() {
              return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a2();
            }
            function a2() {
              return { add: t, delete: t, get: t, set: t, has: function(E) {
                return false;
              } };
            }
            var n = Object.prototype.hasOwnProperty, u = function(E, N) {
              return n.call(E, N);
            };
            function i(E, N) {
              for (var x in N)
                u(N, x) && (E[x] = N[x]);
              return E;
            }
            var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
            function c(E, N, x) {
              var I = 0, P = E[0].match(h);
              P && (I = P[1].length);
              var $ = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($, "g");
              N && (E = E.slice(1));
              var T = x.newline, m = x.trimLeadingNewline, C = x.trimTrailingNewline, o = typeof T == "string", d = E.length, v = E.map(function(S, b) {
                return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === d - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
                  return T;
                })), S;
              });
              return v;
            }
            function f2(E, N) {
              for (var x = "", I = 0, P = E.length; I < P; I++)
                x += E[I], I < P - 1 && (x += N[I]);
              return x;
            }
            function F(E) {
              return u(E, "raw") && u(E, "length");
            }
            function _(E) {
              var N = s(), x = s();
              function I($) {
                for (var D = [], T = 1; T < arguments.length; T++)
                  D[T - 1] = arguments[T];
                if (F($)) {
                  var m = $, C = (D[0] === I || D[0] === w) && g.test(m[0]) && y.test(m[1]), o = C ? x : N, d = o.get(m);
                  if (d || (d = c(m, C, E), o.set(m, d)), D.length === 0)
                    return d[0];
                  var v = f2(d, C ? D.slice(1) : D);
                  return v;
                } else
                  return _(i(i({}, E), $ || {}));
              }
              var P = i(I, { string: function($) {
                return c([$], false, E)[0];
              } });
              return P;
            }
            var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
            if (e.outdent = w, e.default = w, typeof r < "u")
              try {
                r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
              } catch {
              }
          } }), KD = te({ "src/main/core-options.js"(e, r) {
            "use strict";
            ne();
            var { outdent: t } = XD(), s = "Config", a2 = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p = "Special", y = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a2 }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
            r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a2, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: y };
          } }), Xn = te({ "src/main/support.js"(e, r) {
            "use strict";
            ne();
            var t = { compare: zn(), lt: UD(), gte: JD() }, s = zD(), a2 = Ia().version, n = KD().options;
            function u() {
              let { plugins: l = [], showUnreleased: p = false, showDeprecated: y = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a2.split("-", 1)[0], c = l.flatMap((E) => E.languages || []).filter(F), f2 = s(Object.assign({}, ...l.map((E) => {
                let { options: N } = E;
                return N;
              }), n), "name").filter((E) => F(E) && _(E)).sort((E, N) => E.name === N.name ? 0 : E.name < N.name ? -1 : 1).map(w).map((E) => {
                E = Object.assign({}, E), Array.isArray(E.default) && (E.default = E.default.length === 1 ? E.default[0].value : E.default.filter(F).sort((x, I) => t.compare(I.since, x.since))[0].value), Array.isArray(E.choices) && (E.choices = E.choices.filter((x) => F(x) && _(x)), E.name === "parser" && i(E, c, l));
                let N = Object.fromEntries(l.filter((x) => x.defaultOptions && x.defaultOptions[E.name] !== void 0).map((x) => [x.name, x.defaultOptions[E.name]]));
                return Object.assign(Object.assign({}, E), {}, { pluginDefaults: N });
              });
              return { languages: c, options: f2 };
              function F(E) {
                return p || !("since" in E) || E.since && t.gte(g, E.since);
              }
              function _(E) {
                return y || !("deprecated" in E) || E.deprecated && t.lt(g, E.deprecated);
              }
              function w(E) {
                if (h)
                  return E;
                let { cliName: N, cliCategory: x, cliDescription: I } = E;
                return Hn(E, hD);
              }
            }
            function i(l, p, y) {
              let h = new Set(l.choices.map((g) => g.value));
              for (let g of p)
                if (g.parsers) {
                  for (let c of g.parsers)
                    if (!h.has(c)) {
                      h.add(c);
                      let f2 = y.find((_) => _.parsers && _.parsers[c]), F = g.name;
                      f2 && f2.name && (F += ` (plugin: ${f2.name})`), l.choices.push({ value: c, description: F });
                    }
                }
            }
            r.exports = { getSupportInfo: u };
          } }), Kn = te({ "src/utils/is-non-empty-array.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              return Array.isArray(s) && s.length > 0;
            }
            r.exports = t;
          } }), Pr = te({ "src/utils/text/skip.js"(e, r) {
            "use strict";
            ne();
            function t(i) {
              return (l, p, y) => {
                let h = y && y.backwards;
                if (p === false)
                  return false;
                let { length: g } = l, c = p;
                for (; c >= 0 && c < g; ) {
                  let f2 = l.charAt(c);
                  if (i instanceof RegExp) {
                    if (!i.test(f2))
                      return c;
                  } else if (!i.includes(f2))
                    return c;
                  h ? c-- : c++;
                }
                return c === -1 || c === g ? c : false;
              };
            }
            var s = t(/\s/), a2 = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
            r.exports = { skipWhitespace: s, skipSpaces: a2, skipToLineEnd: n, skipEverythingButNewLine: u };
          } }), Ra = te({ "src/utils/text/skip-inline-comment.js"(e, r) {
            "use strict";
            ne();
            function t(s, a2) {
              if (a2 === false)
                return false;
              if (s.charAt(a2) === "/" && s.charAt(a2 + 1) === "*") {
                for (let n = a2 + 2; n < s.length; ++n)
                  if (s.charAt(n) === "*" && s.charAt(n + 1) === "/")
                    return n + 2;
              }
              return a2;
            }
            r.exports = t;
          } }), $a = te({ "src/utils/text/skip-trailing-comment.js"(e, r) {
            "use strict";
            ne();
            var { skipEverythingButNewLine: t } = Pr();
            function s(a2, n) {
              return n === false ? false : a2.charAt(n) === "/" && a2.charAt(n + 1) === "/" ? t(a2, n) : n;
            }
            r.exports = s;
          } }), Va = te({ "src/utils/text/skip-newline.js"(e, r) {
            "use strict";
            ne();
            function t(s, a2, n) {
              let u = n && n.backwards;
              if (a2 === false)
                return false;
              let i = s.charAt(a2);
              if (u) {
                if (s.charAt(a2 - 1) === "\r" && i === `
`)
                  return a2 - 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a2 - 1;
              } else {
                if (i === "\r" && s.charAt(a2 + 1) === `
`)
                  return a2 + 2;
                if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                  return a2 + 1;
              }
              return a2;
            }
            r.exports = t;
          } }), YD = te({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
            "use strict";
            ne();
            var t = Ra(), s = Va(), a2 = $a(), { skipSpaces: n } = Pr();
            function u(i, l) {
              let p = null, y = l;
              for (; y !== p; )
                p = y, y = n(i, y), y = t(i, y), y = a2(i, y), y = s(i, y);
              return y;
            }
            r.exports = u;
          } }), Ue = te({ "src/common/util.js"(e, r) {
            "use strict";
            ne();
            var { default: t } = ($D(), ft(ja)), s = lt(), { getSupportInfo: a2 } = Xn(), n = Kn(), u = Oa(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y } = Pr(), h = Ra(), g = $a(), c = Va(), f2 = YD(), F = (V) => V[V.length - 2];
            function _(V) {
              return (j, Y, ie) => {
                let ee = ie && ie.backwards;
                if (Y === false)
                  return false;
                let { length: ce } = j, W = Y;
                for (; W >= 0 && W < ce; ) {
                  let K = j.charAt(W);
                  if (V instanceof RegExp) {
                    if (!V.test(K))
                      return W;
                  } else if (!V.includes(K))
                    return W;
                  ee ? W-- : W++;
                }
                return W === -1 || W === ce ? W : false;
              };
            }
            function w(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c(V, ie, Y);
              return ie !== ee;
            }
            function E(V, j, Y) {
              for (let ie = j; ie < Y; ++ie)
                if (V.charAt(ie) === `
`)
                  return true;
              return false;
            }
            function N(V, j, Y) {
              let ie = Y(j) - 1;
              ie = l(V, ie, { backwards: true }), ie = c(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
              let ee = c(V, ie, { backwards: true });
              return ie !== ee;
            }
            function x(V, j) {
              let Y = null, ie = j;
              for (; ie !== Y; )
                Y = ie, ie = p(V, ie), ie = h(V, ie), ie = l(V, ie);
              return ie = g(V, ie), ie = c(V, ie), ie !== false && w(V, ie);
            }
            function I(V, j, Y) {
              return x(V, Y(j));
            }
            function P(V, j, Y) {
              return f2(V, Y(j));
            }
            function $(V, j, Y) {
              return V.charAt(P(V, j, Y));
            }
            function D(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
              return l(V, Y.backwards ? j - 1 : j, Y) !== j;
            }
            function T(V, j) {
              let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
              for (let ee = Y; ee < V.length; ++ee)
                V[ee] === "	" ? ie = ie + j - ie % j : ie++;
              return ie;
            }
            function m(V, j) {
              let Y = V.lastIndexOf(`
`);
              return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
            }
            function C(V, j) {
              let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
              if (V.includes(ee.quote) || V.includes(ce.quote)) {
                let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
                W = K > de ? ce : ee;
              }
              return W;
            }
            function o(V, j) {
              let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
              return d(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
            }
            function d(V, j, Y) {
              let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
              return j + ce + j;
            }
            function v(V) {
              return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
            }
            function S(V, j) {
              let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
              return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
            }
            function b(V, j) {
              let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
              if (Y === null)
                return 0;
              let ie = /* @__PURE__ */ new Map(), ee = 0;
              for (let ce of Y) {
                let W = ce.length / j.length;
                ie.set(W, true), W > ee && (ee = W);
              }
              for (let ce = 1; ce < ee; ce++)
                if (!ie.get(ce))
                  return ce;
              return ee + 1;
            }
            function B(V, j) {
              (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q(V);
            }
            function k(V, j) {
              j.leading = true, j.trailing = false, B(V, j);
            }
            function M(V, j, Y) {
              j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
            }
            function R(V, j) {
              j.leading = false, j.trailing = true, B(V, j);
            }
            function q(V, j) {
              let { languages: Y } = a2({ plugins: j.plugins }), ie = Y.find((ee) => {
                let { name: ce } = ee;
                return ce.toLowerCase() === V;
              }) || Y.find((ee) => {
                let { aliases: ce } = ee;
                return Array.isArray(ce) && ce.includes(V);
              }) || Y.find((ee) => {
                let { extensions: ce } = ee;
                return Array.isArray(ce) && ce.includes(`.${V}`);
              });
              return ie && ie.parsers[0];
            }
            function J(V) {
              return V && V.type === "front-matter";
            }
            function L(V) {
              let j = /* @__PURE__ */ new WeakMap();
              return function(Y) {
                return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
              };
            }
            function Q(V) {
              let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
              return Y.length > 20 && (Y = Y.slice(0, 19) + "\u2026"), j + (Y ? " " + Y : "");
            }
            r.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: F, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f2, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: y, skipInlineComment: h, skipTrailingComment: g, skipNewline: c, isNextLineEmptyAfterIndex: x, isNextLineEmpty: I, isPreviousLineEmpty: N, hasNewline: w, hasNewlineInRange: E, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v, makeString: d, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: L };
          } }), Wa = {};
          Kt(Wa, { basename: () => za, default: () => Ka, delimiter: () => Mn, dirname: () => Ja, extname: () => Xa, isAbsolute: () => Qn, join: () => Ga, normalize: () => Yn, relative: () => Ua, resolve: () => wr, sep: () => qn });
          function Ha(e, r) {
            for (var t = 0, s = e.length - 1; s >= 0; s--) {
              var a2 = e[s];
              a2 === "." ? e.splice(s, 1) : a2 === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
            }
            if (r)
              for (; t--; t)
                e.unshift("..");
            return e;
          }
          function wr() {
            for (var e = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
              var s = t >= 0 ? arguments[t] : "/";
              if (typeof s != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!s)
                continue;
              e = s + "/" + e, r = s.charAt(0) === "/";
            }
            return e = Ha(Zn(e.split("/"), function(a2) {
              return !!a2;
            }), !r).join("/"), (r ? "/" : "") + e || ".";
          }
          function Yn(e) {
            var r = Qn(e), t = Ya(e, -1) === "/";
            return e = Ha(Zn(e.split("/"), function(s) {
              return !!s;
            }), !r).join("/"), !e && !r && (e = "."), e && t && (e += "/"), (r ? "/" : "") + e;
          }
          function Qn(e) {
            return e.charAt(0) === "/";
          }
          function Ga() {
            var e = Array.prototype.slice.call(arguments, 0);
            return Yn(Zn(e, function(r, t) {
              if (typeof r != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return r;
            }).join("/"));
          }
          function Ua(e, r) {
            e = wr(e).substr(1), r = wr(r).substr(1);
            function t(p) {
              for (var y = 0; y < p.length && p[y] === ""; y++)
                ;
              for (var h = p.length - 1; h >= 0 && p[h] === ""; h--)
                ;
              return y > h ? [] : p.slice(y, h - y + 1);
            }
            for (var s = t(e.split("/")), a2 = t(r.split("/")), n = Math.min(s.length, a2.length), u = n, i = 0; i < n; i++)
              if (s[i] !== a2[i]) {
                u = i;
                break;
              }
            for (var l = [], i = u; i < s.length; i++)
              l.push("..");
            return l = l.concat(a2.slice(u)), l.join("/");
          }
          function Ja(e) {
            var r = Ir(e), t = r[0], s = r[1];
            return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
          }
          function za(e, r) {
            var t = Ir(e)[2];
            return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
          }
          function Xa(e) {
            return Ir(e)[3];
          }
          function Zn(e, r) {
            if (e.filter)
              return e.filter(r);
            for (var t = [], s = 0; s < e.length; s++)
              r(e[s], s, e) && t.push(e[s]);
            return t;
          }
          var Na, Ir, qn, Mn, Ka, Ya, QD = ht({ "node-modules-polyfills:path"() {
            ne(), Na = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Ir = function(e) {
              return Na.exec(e).slice(1);
            }, qn = "/", Mn = ":", Ka = { extname: Xa, basename: za, dirname: Ja, sep: qn, delimiter: Mn, relative: Ua, join: Ga, isAbsolute: Qn, normalize: Yn, resolve: wr }, Ya = "ab".substr(-1) === "b" ? function(e, r, t) {
              return e.substr(r, t);
            } : function(e, r, t) {
              return r < 0 && (r = e.length + r), e.substr(r, t);
            };
          } }), ZD = te({ "node-modules-polyfills-commonjs:path"(e, r) {
            ne();
            var t = (QD(), ft(Wa));
            if (t && t.default) {
              r.exports = t.default;
              for (let s in t)
                r.exports[s] = t[s];
            } else
              t && (r.exports = t);
          } }), Qt = te({ "src/common/errors.js"(e, r) {
            "use strict";
            ne();
            var t = class extends Error {
            }, s = class extends Error {
            }, a2 = class extends Error {
            }, n = class extends Error {
            };
            r.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a2, ArgExpansionBailout: n };
          } }), vt = {};
          Kt(vt, { __assign: () => Nr, __asyncDelegator: () => fm, __asyncGenerator: () => pm, __asyncValues: () => Dm, __await: () => Xt, __awaiter: () => sm, __classPrivateFieldGet: () => ym, __classPrivateFieldSet: () => hm, __createBinding: () => am, __decorate: () => rm, __exportStar: () => om, __extends: () => em, __generator: () => im, __importDefault: () => gm, __importStar: () => dm, __makeTemplateObject: () => mm, __metadata: () => um, __param: () => nm, __read: () => Qa, __rest: () => tm, __spread: () => lm, __spreadArrays: () => cm, __values: () => Rn });
          function em(e, r) {
            Br(e, r);
            function t() {
              this.constructor = e;
            }
            e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
          }
          function tm(e, r) {
            var t = {};
            for (var s in e)
              Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function")
              for (var a2 = 0, s = Object.getOwnPropertySymbols(e); a2 < s.length; a2++)
                r.indexOf(s[a2]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a2]) && (t[s[a2]] = e[s[a2]]);
            return t;
          }
          function rm(e, r, t, s) {
            var a2 = arguments.length, n = a2 < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t) : s, u;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
              n = Reflect.decorate(e, r, t, s);
            else
              for (var i = e.length - 1; i >= 0; i--)
                (u = e[i]) && (n = (a2 < 3 ? u(n) : a2 > 3 ? u(r, t, n) : u(r, t)) || n);
            return a2 > 3 && n && Object.defineProperty(r, t, n), n;
          }
          function nm(e, r) {
            return function(t, s) {
              r(t, s, e);
            };
          }
          function um(e, r) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
              return Reflect.metadata(e, r);
          }
          function sm(e, r, t, s) {
            function a2(n) {
              return n instanceof t ? n : new t(function(u) {
                u(n);
              });
            }
            return new (t || (t = Promise))(function(n, u) {
              function i(y) {
                try {
                  p(s.next(y));
                } catch (h) {
                  u(h);
                }
              }
              function l(y) {
                try {
                  p(s.throw(y));
                } catch (h) {
                  u(h);
                }
              }
              function p(y) {
                y.done ? n(y.value) : a2(y.value).then(i, l);
              }
              p((s = s.apply(e, r || [])).next());
            });
          }
          function im(e, r) {
            var t = { label: 0, sent: function() {
              if (n[0] & 1)
                throw n[1];
              return n[1];
            }, trys: [], ops: [] }, s, a2, n, u;
            return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
              return this;
            }), u;
            function i(p) {
              return function(y) {
                return l([p, y]);
              };
            }
            function l(p) {
              if (s)
                throw new TypeError("Generator is already executing.");
              for (; t; )
                try {
                  if (s = 1, a2 && (n = p[0] & 2 ? a2.return : p[0] ? a2.throw || ((n = a2.return) && n.call(a2), 0) : a2.next) && !(n = n.call(a2, p[1])).done)
                    return n;
                  switch (a2 = 0, n && (p = [p[0] & 2, n.value]), p[0]) {
                    case 0:
                    case 1:
                      n = p;
                      break;
                    case 4:
                      return t.label++, { value: p[1], done: false };
                    case 5:
                      t.label++, a2 = p[1], p = [0];
                      continue;
                    case 7:
                      p = t.ops.pop(), t.trys.pop();
                      continue;
                    default:
                      if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                        t = 0;
                        continue;
                      }
                      if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {
                        t.label = p[1];
                        break;
                      }
                      if (p[0] === 6 && t.label < n[1]) {
                        t.label = n[1], n = p;
                        break;
                      }
                      if (n && t.label < n[2]) {
                        t.label = n[2], t.ops.push(p);
                        break;
                      }
                      n[2] && t.ops.pop(), t.trys.pop();
                      continue;
                  }
                  p = r.call(e, t);
                } catch (y) {
                  p = [6, y], a2 = 0;
                } finally {
                  s = n = 0;
                }
              if (p[0] & 5)
                throw p[1];
              return { value: p[0] ? p[1] : void 0, done: true };
            }
          }
          function am(e, r, t, s) {
            s === void 0 && (s = t), e[s] = r[t];
          }
          function om(e, r) {
            for (var t in e)
              t !== "default" && !r.hasOwnProperty(t) && (r[t] = e[t]);
          }
          function Rn(e) {
            var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], s = 0;
            if (t)
              return t.call(e);
            if (e && typeof e.length == "number")
              return { next: function() {
                return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
              } };
            throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function Qa(e, r) {
            var t = typeof Symbol == "function" && e[Symbol.iterator];
            if (!t)
              return e;
            var s = t.call(e), a2, n = [], u;
            try {
              for (; (r === void 0 || r-- > 0) && !(a2 = s.next()).done; )
                n.push(a2.value);
            } catch (i) {
              u = { error: i };
            } finally {
              try {
                a2 && !a2.done && (t = s.return) && t.call(s);
              } finally {
                if (u)
                  throw u.error;
              }
            }
            return n;
          }
          function lm() {
            for (var e = [], r = 0; r < arguments.length; r++)
              e = e.concat(Qa(arguments[r]));
            return e;
          }
          function cm() {
            for (var e = 0, r = 0, t = arguments.length; r < t; r++)
              e += arguments[r].length;
            for (var s = Array(e), a2 = 0, r = 0; r < t; r++)
              for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a2++)
                s[a2] = n[u];
            return s;
          }
          function Xt(e) {
            return this instanceof Xt ? (this.v = e, this) : new Xt(e);
          }
          function pm(e, r, t) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var s = t.apply(e, r || []), a2, n = [];
            return a2 = {}, u("next"), u("throw"), u("return"), a2[Symbol.asyncIterator] = function() {
              return this;
            }, a2;
            function u(g) {
              s[g] && (a2[g] = function(c) {
                return new Promise(function(f2, F) {
                  n.push([g, c, f2, F]) > 1 || i(g, c);
                });
              });
            }
            function i(g, c) {
              try {
                l(s[g](c));
              } catch (f2) {
                h(n[0][3], f2);
              }
            }
            function l(g) {
              g.value instanceof Xt ? Promise.resolve(g.value.v).then(p, y) : h(n[0][2], g);
            }
            function p(g) {
              i("next", g);
            }
            function y(g) {
              i("throw", g);
            }
            function h(g, c) {
              g(c), n.shift(), n.length && i(n[0][0], n[0][1]);
            }
          }
          function fm(e) {
            var r, t;
            return r = {}, s("next"), s("throw", function(a2) {
              throw a2;
            }), s("return"), r[Symbol.iterator] = function() {
              return this;
            }, r;
            function s(a2, n) {
              r[a2] = e[a2] ? function(u) {
                return (t = !t) ? { value: Xt(e[a2](u)), done: a2 === "return" } : n ? n(u) : u;
              } : n;
            }
          }
          function Dm(e) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var r = e[Symbol.asyncIterator], t;
            return r ? r.call(e) : (e = typeof Rn == "function" ? Rn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
              return this;
            }, t);
            function s(n) {
              t[n] = e[n] && function(u) {
                return new Promise(function(i, l) {
                  u = e[n](u), a2(i, l, u.done, u.value);
                });
              };
            }
            function a2(n, u, i, l) {
              Promise.resolve(l).then(function(p) {
                n({ value: p, done: i });
              }, u);
            }
          }
          function mm(e, r) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
          }
          function dm(e) {
            if (e && e.__esModule)
              return e;
            var r = {};
            if (e != null)
              for (var t in e)
                Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);
            return r.default = e, r;
          }
          function gm(e) {
            return e && e.__esModule ? e : { default: e };
          }
          function ym(e, r) {
            if (!r.has(e))
              throw new TypeError("attempted to get private field on non-instance");
            return r.get(e);
          }
          function hm(e, r, t) {
            if (!r.has(e))
              throw new TypeError("attempted to set private field on non-instance");
            return r.set(e, t), t;
          }
          var Br, Nr, Et = ht({ "node_modules/tslib/tslib.es6.js"() {
            ne(), Br = function(e, r) {
              return Br = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
                t.__proto__ = s;
              } || function(t, s) {
                for (var a2 in s)
                  s.hasOwnProperty(a2) && (t[a2] = s[a2]);
              }, Br(e, r);
            }, Nr = function() {
              return Nr = Object.assign || function(r) {
                for (var t, s = 1, a2 = arguments.length; s < a2; s++) {
                  t = arguments[s];
                  for (var n in t)
                    Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
                }
                return r;
              }, Nr.apply(this, arguments);
            };
          } }), Za = te({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
              if (r === null || typeof r != "object")
                return JSON.stringify(r);
              if (Array.isArray(r))
                return `[${r.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
              let t = Object.keys(r);
              return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`;
            }, pair: (r) => {
              let { key: t, value: s } = r;
              return e.apiDescriptor.value({ [t]: s });
            } };
          } }), vm = te({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Za(), e);
          } }), kr = te({ "scripts/build/shims/chalk.cjs"(e, r) {
            "use strict";
            ne();
            var t = (s) => s;
            t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
          } }), eo = te({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr();
            e.commonDeprecatedHandler = (t, s, a2) => {
              let { descriptor: n } = a2, u = [`${r.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
              return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n.key(s) : n.pair(s))}`), u.join("; ") + ".";
            };
          } }), Cm = te({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(eo(), e);
          } }), Em = te({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr();
            e.commonInvalidHandler = (t, s, a2) => [`Invalid ${r.default.red(a2.descriptor.key(t))} value.`, `Expected ${r.default.blue(a2.schemas[t].expected(a2))},`, `but received ${r.default.red(a2.descriptor.value(s))}.`].join(" ");
          } }), to = te({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Em(), e);
          } }), Fm = te({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
            "use strict";
            ne();
            var t = [], s = [];
            r.exports = function(a2, n) {
              if (a2 === n)
                return 0;
              var u = a2;
              a2.length > n.length && (a2 = n, n = u);
              var i = a2.length, l = n.length;
              if (i === 0)
                return l;
              if (l === 0)
                return i;
              for (; i > 0 && a2.charCodeAt(~-i) === n.charCodeAt(~-l); )
                i--, l--;
              if (i === 0)
                return l;
              for (var p = 0; p < i && a2.charCodeAt(p) === n.charCodeAt(p); )
                p++;
              if (i -= p, l -= p, i === 0)
                return l;
              for (var y, h, g, c, f2 = 0, F = 0; f2 < i; )
                s[p + f2] = a2.charCodeAt(p + f2), t[f2] = ++f2;
              for (; F < l; )
                for (y = n.charCodeAt(p + F), g = F++, h = F, f2 = 0; f2 < i; f2++)
                  c = y === s[p + f2] ? g : g + 1, g = t[f2], h = t[f2] = g > h ? c > h ? h + 1 : c : c > g ? g + 1 : c;
              return h;
            };
          } }), ro = te({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = kr(), t = Fm();
            e.levenUnknownHandler = (s, a2, n) => {
              let { descriptor: u, logger: i, schemas: l } = n, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a2 }))}.`], y = Object.keys(l).sort().find((h) => t(s, h) < 3);
              y && p.push(`Did you mean ${r.default.blue(u.key(y))}?`), i.warn(p.join(" "));
            };
          } }), Am = te({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(ro(), e);
          } }), Sm = te({ "node_modules/vnopts/lib/handlers/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(Cm(), e), r.__exportStar(to(), e), r.__exportStar(Am(), e);
          } }), Ft = te({ "node_modules/vnopts/lib/schema.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
            function t(n, u) {
              let i = new n(u), l = Object.create(i);
              for (let p of r)
                p in u && (l[p] = a2(u[p], i, s.prototype[p].length));
              return l;
            }
            e.createSchema = t;
            var s = class {
              constructor(n) {
                this.name = n.name;
              }
              static create(n) {
                return t(this, n);
              }
              default(n) {
              }
              expected(n) {
                return "nothing";
              }
              validate(n, u) {
                return false;
              }
              deprecated(n, u) {
                return false;
              }
              forward(n, u) {
              }
              redirect(n, u) {
              }
              overlap(n, u, i) {
                return n;
              }
              preprocess(n, u) {
                return n;
              }
              postprocess(n, u) {
                return n;
              }
            };
            e.Schema = s;
            function a2(n, u, i) {
              return typeof n == "function" ? function() {
                for (var l = arguments.length, p = new Array(l), y = 0; y < l; y++)
                  p[y] = arguments[y];
                return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));
              } : () => n;
            }
          } }), xm = te({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              constructor(s) {
                super(s), this._sourceName = s.sourceName;
              }
              expected(s) {
                return s.schemas[this._sourceName].expected(s);
              }
              validate(s, a2) {
                return a2.schemas[this._sourceName].validate(s, a2);
              }
              redirect(s, a2) {
                return this._sourceName;
              }
            };
            e.AliasSchema = t;
          } }), bm = te({ "node_modules/vnopts/lib/schemas/any.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "anything";
              }
              validate() {
                return true;
              }
            };
            e.AnySchema = t;
          } }), Tm = te({ "node_modules/vnopts/lib/schemas/array.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt)), t = Ft(), s = class extends t.Schema {
              constructor(n) {
                var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
                super(Object.assign({}, l, { name: i })), this._valueSchema = u;
              }
              expected(n) {
                return `an array of ${this._valueSchema.expected(n)}`;
              }
              validate(n, u) {
                if (!Array.isArray(n))
                  return false;
                let i = [];
                for (let l of n) {
                  let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                  p !== true && i.push(p.value);
                }
                return i.length === 0 ? true : { value: i };
              }
              deprecated(n, u) {
                let i = [];
                for (let l of n) {
                  let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                  p !== false && i.push(...p.map((y) => {
                    let { value: h } = y;
                    return { value: [h] };
                  }));
                }
                return i;
              }
              forward(n, u) {
                let i = [];
                for (let l of n) {
                  let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                  i.push(...p.map(a2));
                }
                return i;
              }
              redirect(n, u) {
                let i = [], l = [];
                for (let p of n) {
                  let y = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
                  "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a2));
                }
                return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
              }
              overlap(n, u) {
                return n.concat(u);
              }
            };
            e.ArraySchema = s;
            function a2(n) {
              let { from: u, to: i } = n;
              return { from: [u], to: i };
            }
          } }), Bm = te({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "true or false";
              }
              validate(s) {
                return typeof s == "boolean";
              }
            };
            e.BooleanSchema = t;
          } }), eu = te({ "node_modules/vnopts/lib/utils.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            function r(c, f2) {
              let F = /* @__PURE__ */ Object.create(null);
              for (let _ of c) {
                let w = _[f2];
                if (F[w])
                  throw new Error(`Duplicate ${f2} ${JSON.stringify(w)}`);
                F[w] = _;
              }
              return F;
            }
            e.recordFromArray = r;
            function t(c, f2) {
              let F = /* @__PURE__ */ new Map();
              for (let _ of c) {
                let w = _[f2];
                if (F.has(w))
                  throw new Error(`Duplicate ${f2} ${JSON.stringify(w)}`);
                F.set(w, _);
              }
              return F;
            }
            e.mapFromArray = t;
            function s() {
              let c = /* @__PURE__ */ Object.create(null);
              return (f2) => {
                let F = JSON.stringify(f2);
                return c[F] ? true : (c[F] = true, false);
              };
            }
            e.createAutoChecklist = s;
            function a2(c, f2) {
              let F = [], _ = [];
              for (let w of c)
                f2(w) ? F.push(w) : _.push(w);
              return [F, _];
            }
            e.partition = a2;
            function n(c) {
              return c === Math.floor(c);
            }
            e.isInt = n;
            function u(c, f2) {
              if (c === f2)
                return 0;
              let F = typeof c, _ = typeof f2, w = ["undefined", "object", "boolean", "number", "string"];
              return F !== _ ? w.indexOf(F) - w.indexOf(_) : F !== "string" ? Number(c) - Number(f2) : c.localeCompare(f2);
            }
            e.comparePrimitive = u;
            function i(c) {
              return c === void 0 ? {} : c;
            }
            e.normalizeDefaultResult = i;
            function l(c, f2) {
              return c === true ? true : c === false ? { value: f2 } : c;
            }
            e.normalizeValidateResult = l;
            function p(c, f2) {
              let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return c === false ? false : c === true ? F ? true : [{ value: f2 }] : "value" in c ? [c] : c.length === 0 ? false : c;
            }
            e.normalizeDeprecatedResult = p;
            function y(c, f2) {
              return typeof c == "string" || "key" in c ? { from: f2, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f2, to: c.to };
            }
            e.normalizeTransferResult = y;
            function h(c, f2) {
              return c === void 0 ? [] : Array.isArray(c) ? c.map((F) => y(F, f2)) : [y(c, f2)];
            }
            e.normalizeForwardResult = h;
            function g(c, f2) {
              let F = h(typeof c == "object" && "redirect" in c ? c.redirect : c, f2);
              return F.length === 0 ? { remain: f2, redirect: F } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: F } : { redirect: F };
            }
            e.normalizeRedirectResult = g;
          } }), Nm = te({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = eu(), s = class extends r.Schema {
              constructor(a2) {
                super(a2), this._choices = t.mapFromArray(a2.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
              }
              expected(a2) {
                let { descriptor: n } = a2, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
                return i.concat(l.join(" or ")).join(", ");
              }
              validate(a2) {
                return this._choices.has(a2);
              }
              deprecated(a2) {
                let n = this._choices.get(a2);
                return n && n.deprecated ? { value: a2 } : false;
              }
              forward(a2) {
                let n = this._choices.get(a2);
                return n ? n.forward : void 0;
              }
              redirect(a2) {
                let n = this._choices.get(a2);
                return n ? n.redirect : void 0;
              }
            };
            e.ChoiceSchema = s;
          } }), no = te({ "node_modules/vnopts/lib/schemas/number.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "a number";
              }
              validate(s, a2) {
                return typeof s == "number";
              }
            };
            e.NumberSchema = t;
          } }), wm = te({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = eu(), t = no(), s = class extends t.NumberSchema {
              expected() {
                return "an integer";
              }
              validate(a2, n) {
                return n.normalizeValidateResult(super.validate(a2, n), a2) === true && r.isInt(a2);
              }
            };
            e.IntegerSchema = s;
          } }), _m = te({ "node_modules/vnopts/lib/schemas/string.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Ft(), t = class extends r.Schema {
              expected() {
                return "a string";
              }
              validate(s) {
                return typeof s == "string";
              }
            };
            e.StringSchema = t;
          } }), Pm = te({ "node_modules/vnopts/lib/schemas/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(xm(), e), r.__exportStar(bm(), e), r.__exportStar(Tm(), e), r.__exportStar(Bm(), e), r.__exportStar(Nm(), e), r.__exportStar(wm(), e), r.__exportStar(no(), e), r.__exportStar(_m(), e);
          } }), Im = te({ "node_modules/vnopts/lib/defaults.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Za(), t = eo(), s = to(), a2 = ro();
            e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a2.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
          } }), km = te({ "node_modules/vnopts/lib/normalize.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Im(), t = eu();
            e.normalize = (a2, n, u) => new s(n, u).normalize(a2);
            var s = class {
              constructor(a2, n) {
                let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: y = r.defaultDeprecatedHandler } = n || {};
                this._utils = { descriptor: i, logger: u || { warn: () => {
                } }, schemas: t.recordFromArray(a2, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = y, this.cleanHistory();
              }
              cleanHistory() {
                this._hasDeprecationWarned = t.createAutoChecklist();
              }
              normalize(a2) {
                let n = {}, u = [a2], i = () => {
                  for (; u.length !== 0; ) {
                    let l = u.shift(), p = this._applyNormalization(l, n);
                    u.push(...p);
                  }
                };
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let p = this._utils.schemas[l];
                  if (!(l in n)) {
                    let y = t.normalizeDefaultResult(p.default(this._utils));
                    "value" in y && u.push({ [l]: y.value });
                  }
                }
                i();
                for (let l of Object.keys(this._utils.schemas)) {
                  let p = this._utils.schemas[l];
                  l in n && (n[l] = p.postprocess(n[l], this._utils));
                }
                return n;
              }
              _applyNormalization(a2, n) {
                let u = [], [i, l] = t.partition(Object.keys(a2), (p) => p in this._utils.schemas);
                for (let p of i) {
                  let y = this._utils.schemas[p], h = y.preprocess(a2[p], this._utils), g = t.normalizeValidateResult(y.validate(h, this._utils), h);
                  if (g !== true) {
                    let { value: w } = g, E = this._invalidHandler(p, w, this._utils);
                    throw typeof E == "string" ? new Error(E) : E;
                  }
                  let c = (w) => {
                    let { from: E, to: N } = w;
                    u.push(typeof N == "string" ? { [N]: E } : { [N.key]: N.value });
                  }, f2 = (w) => {
                    let { value: E, redirectTo: N } = w, x = t.normalizeDeprecatedResult(y.deprecated(E, this._utils), h, true);
                    if (x !== false)
                      if (x === true)
                        this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N, this._utils));
                      else
                        for (let { value: I } of x) {
                          let P = { key: p, value: I };
                          if (!this._hasDeprecationWarned(P)) {
                            let $ = typeof N == "string" ? { key: N, value: I } : N;
                            this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));
                          }
                        }
                  };
                  t.normalizeForwardResult(y.forward(h, this._utils), h).forEach(c);
                  let _ = t.normalizeRedirectResult(y.redirect(h, this._utils), h);
                  if (_.redirect.forEach(c), "remain" in _) {
                    let w = _.remain;
                    n[p] = p in n ? y.overlap(n[p], w, this._utils) : w, f2({ value: w });
                  }
                  for (let { from: w, to: E } of _.redirect)
                    f2({ value: w, redirectTo: E });
                }
                for (let p of l) {
                  let y = a2[p], h = this._unknownHandler(p, y, this._utils);
                  if (h)
                    for (let g of Object.keys(h)) {
                      let c = { [g]: h[g] };
                      g in this._utils.schemas ? u.push(c) : Object.assign(n, c);
                    }
                }
                return u;
              }
            };
            e.Normalizer = s;
          } }), Lm = te({ "node_modules/vnopts/lib/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = (Et(), ft(vt));
            r.__exportStar(vm(), e), r.__exportStar(Sm(), e), r.__exportStar(Pm(), e), r.__exportStar(km(), e), r.__exportStar(Ft(), e);
          } }), Om = te({ "src/main/options-normalizer.js"(e, r) {
            "use strict";
            ne();
            var t = Lm(), s = lt(), a2 = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
              let { key: c, value: f2 } = g;
              return f2 === false ? `--no-${c}` : f2 === true ? a2.key(c) : f2 === "" ? `${a2.key(c)} without an argument` : `${a2.key(c)}=${f2}`;
            } }, n = (g) => {
              let { colorsModule: c, levenshteinDistance: f2 } = g;
              return class extends t.ChoiceSchema {
                constructor(_) {
                  let { name: w, flags: E } = _;
                  super({ name: w, choices: E }), this._flags = [...E].sort();
                }
                preprocess(_, w) {
                  if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
                    let E = this._flags.find((N) => f2(N, _) < 3);
                    if (E)
                      return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(E))}?`].join(" ")), E;
                  }
                  return _;
                }
                expected() {
                  return "a flag";
                }
              };
            }, u;
            function i(g, c) {
              let { logger: f2 = false, isCLI: F = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: E = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
                let o = C.schemas, { _: d } = o, v = Hn(o, vD);
                return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v }));
              }, x = F ? a2 : t.apiDescriptor, I = l(c, { isCLI: F, colorsModule: w, levenshteinDistance: E }), P = new t.Normalizer(I, { logger: f2, unknown: N, descriptor: x }), $ = f2 !== false;
              $ && u && (P._hasDeprecationWarned = u);
              let D = P.normalize(g);
              return $ && (u = P._hasDeprecationWarned), F && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
            }
            function l(g, c) {
              let { isCLI: f2, colorsModule: F, levenshteinDistance: _ } = c, w = [];
              f2 && w.push(t.AnySchema.create({ name: "_" }));
              for (let E of g)
                w.push(p(E, { isCLI: f2, optionInfos: g, colorsModule: F, levenshteinDistance: _ })), E.alias && f2 && w.push(t.AliasSchema.create({ name: E.alias, sourceName: E.name }));
              return w;
            }
            function p(g, c) {
              let { isCLI: f2, optionInfos: F, colorsModule: _, levenshteinDistance: w } = c, { name: E } = g;
              if (E === "plugin-search-dir" || E === "pluginSearchDirs")
                return t.AnySchema.create({ name: E, preprocess(P) {
                  return P === false || (P = Array.isArray(P) ? P : [P]), P;
                }, validate(P) {
                  return P === false ? true : P.every(($) => typeof $ == "string");
                }, expected() {
                  return "false or paths to plugin search dir";
                } });
              let N = { name: E }, x, I = {};
              switch (g.type) {
                case "int":
                  x = t.IntegerSchema, f2 && (N.preprocess = Number);
                  break;
                case "string":
                  x = t.StringSchema;
                  break;
                case "choice":
                  x = t.ChoiceSchema, N.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
                  break;
                case "boolean":
                  x = t.BooleanSchema;
                  break;
                case "flag":
                  x = n({ colorsModule: _, levenshteinDistance: w }), N.flags = F.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                  break;
                case "path":
                  x = t.StringSchema;
                  break;
                default:
                  throw new Error(`Unexpected type ${g.type}`);
              }
              if (g.exception ? N.validate = (P, $, D) => g.exception(P) || $.validate(P, D) : N.validate = (P, $, D) => P === void 0 || $.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f2 && !g.array) {
                let P = N.preprocess || (($) => $);
                N.preprocess = ($, D, T) => D.preprocess(P(Array.isArray($) ? s($) : $), T);
              }
              return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f2 ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x.create(N) })) : x.create(Object.assign(Object.assign({}, N), I));
            }
            function y(g, c, f2) {
              return i(g, c, f2);
            }
            function h(g, c, f2) {
              return i(g, c, Object.assign({ isCLI: true }, f2));
            }
            r.exports = { normalizeApiOptions: y, normalizeCliOptions: h };
          } }), ut = te({ "src/language-js/loc.js"(e, r) {
            "use strict";
            ne();
            var t = Kn();
            function s(l) {
              var p, y;
              let h = l.range ? l.range[0] : l.start, g = (p = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && p !== void 0 ? p : l.decorators;
              return t(g) ? Math.min(s(g[0]), h) : h;
            }
            function a2(l) {
              return l.range ? l.range[1] : l.end;
            }
            function n(l, p) {
              let y = s(l);
              return Number.isInteger(y) && y === s(p);
            }
            function u(l, p) {
              let y = a2(l);
              return Number.isInteger(y) && y === a2(p);
            }
            function i(l, p) {
              return n(l, p) && u(l, p);
            }
            r.exports = { locStart: s, locEnd: a2, hasSameLocStart: n, hasSameLoc: i };
          } }), jm = te({ "src/main/load-parser.js"(e, r) {
            ne(), r.exports = () => {
            };
          } }), qm = te({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
            "use strict";
            ne();
            var t = kr(), s = { shouldHighlight: () => false, getChalk: () => t };
            r.exports = s;
          } }), Mm = te({ "node_modules/@babel/code-frame/lib/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
            var r = qm(), t = false;
            function s(l) {
              return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
            }
            var a2 = /\r\n|[\n\r\u2028\u2029]/;
            function n(l, p, y) {
              let h = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h, l.end), { linesAbove: c = 2, linesBelow: f2 = 3 } = y || {}, F = h.line, _ = h.column, w = g.line, E = g.column, N = Math.max(F - (c + 1), 0), x = Math.min(p.length, w + f2);
              F === -1 && (N = 0), w === -1 && (x = p.length);
              let I = w - F, P = {};
              if (I)
                for (let $ = 0; $ <= I; $++) {
                  let D = $ + F;
                  if (!_)
                    P[D] = true;
                  else if ($ === 0) {
                    let T = p[D - 1].length;
                    P[D] = [_, T - _ + 1];
                  } else if ($ === I)
                    P[D] = [0, E];
                  else {
                    let T = p[D - $].length;
                    P[D] = [0, T];
                  }
                }
              else
                _ === E ? _ ? P[F] = [_, 0] : P[F] = true : P[F] = [_, E - _];
              return { start: N, end: x, markerLines: P };
            }
            function u(l, p) {
              let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (y.highlightCode || y.forceColor) && (0, r.shouldHighlight)(y), g = (0, r.getChalk)(y), c = s(g), f2 = ($, D) => h ? $(D) : D, F = l.split(a2), { start: _, end: w, markerLines: E } = n(p, F, y), N = p.start && typeof p.start.column == "number", x = String(w).length, P = (h ? (0, r.default)(l, y) : l).split(a2, w).slice(_, w).map(($, D) => {
                let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x)} |`, o = E[T], d = !E[T + 1];
                if (o) {
                  let v = "";
                  if (Array.isArray(o)) {
                    let S = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                    v = [`
 `, f2(c.gutter, C.replace(/\d/g, " ")), " ", S, f2(c.marker, "^").repeat(b)].join(""), d && y.message && (v += " " + f2(c.message, y.message));
                  }
                  return [f2(c.marker, ">"), f2(c.gutter, C), $.length > 0 ? ` ${$}` : "", v].join("");
                } else
                  return ` ${f2(c.gutter, C)}${$.length > 0 ? ` ${$}` : ""}`;
              }).join(`
`);
              return y.message && !N && (P = `${" ".repeat(x + 1)}${y.message}
${P}`), h ? g.reset(P) : P;
            }
            function i(l, p, y) {
              let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
              if (!t) {
                t = true;
                let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                if (wt.emitWarning)
                  wt.emitWarning(c, "DeprecationWarning");
                else {
                  let f2 = new Error(c);
                  f2.name = "DeprecationWarning", console.warn(new Error(c));
                }
              }
              return y = Math.max(y, 0), u(l, { start: { column: y, line: p } }, h);
            }
          } }), tu = te({ "src/main/parser.js"(e, r) {
            "use strict";
            ne();
            var { ConfigError: t } = Qt(), s = ut(), a2 = jm(), { locStart: n, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
            function p(g) {
              let c = {};
              for (let f2 of g.plugins)
                if (f2.parsers)
                  for (let F of i(f2.parsers))
                    Object.defineProperty(c, F, l(f2.parsers, F));
              return c;
            }
            function y(g) {
              let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g);
              if (typeof g.parser == "function")
                return { parse: g.parser, astFormat: "estree", locStart: n, locEnd: u };
              if (typeof g.parser == "string") {
                if (Object.prototype.hasOwnProperty.call(c, g.parser))
                  return c[g.parser];
                throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
              }
            }
            function h(g, c) {
              let f2 = p(c), F = Object.defineProperties({}, Object.fromEntries(Object.keys(f2).map((w) => [w, { enumerable: true, get() {
                return f2[w].parse;
              } }]))), _ = y(c, f2);
              try {
                return _.preprocess && (g = _.preprocess(g, c)), { text: g, ast: _.parse(g, F, c) };
              } catch (w) {
                let { loc: E } = w;
                if (E) {
                  let { codeFrameColumns: N } = Mm();
                  throw w.codeFrame = N(g, E, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
                }
                throw w;
              }
            }
            r.exports = { parse: h, resolveParser: y };
          } }), uo = te({ "src/main/options.js"(e, r) {
            "use strict";
            ne();
            var t = ZD(), { UndefinedParserError: s } = Qt(), { getSupportInfo: a2 } = Xn(), n = Om(), { resolveParser: u } = tu(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
            function l(h) {
              let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, h), f2 = a2({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, F = Object.assign(Object.assign({}, i), Object.fromEntries(f2.filter((x) => x.default !== void 0).map((x) => [x.name, x.default])));
              if (!c.parser) {
                if (!c.filepath)
                  (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
                else if (c.parser = y(c.filepath, c.plugins), !c.parser)
                  throw new s(`No parser could be inferred for file: ${c.filepath}`);
              }
              let _ = u(n.normalizeApiOptions(c, [f2.find((x) => x.name === "parser")], { passThrough: true, logger: false }));
              c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
              let w = p(c);
              c.printer = w.printers[c.astFormat];
              let E = Object.fromEntries(f2.filter((x) => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map((x) => [x.name, x.pluginDefaults[w.name]])), N = Object.assign(Object.assign({}, F), E);
              for (let [x, I] of Object.entries(N))
                (c[x] === null || c[x] === void 0) && (c[x] = I);
              return c.parser === "json" && (c.trailingComma = "none"), n.normalizeApiOptions(c, f2, Object.assign({ passThrough: Object.keys(i) }, g));
            }
            function p(h) {
              let { astFormat: g } = h;
              if (!g)
                throw new Error("getPlugin() requires astFormat to be set");
              let c = h.plugins.find((f2) => f2.printers && f2.printers[g]);
              if (!c)
                throw new Error(`Couldn't find plugin for AST format "${g}"`);
              return c;
            }
            function y(h, g) {
              let c = t.basename(h).toLowerCase(), F = a2({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c));
              return F && F.parsers[0];
            }
            r.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
          } }), Rm = te({ "src/main/massage-ast.js"(e, r) {
            "use strict";
            ne();
            function t(s, a2, n) {
              if (Array.isArray(s))
                return s.map((p) => t(p, a2, n)).filter(Boolean);
              if (!s || typeof s != "object")
                return s;
              let u = a2.printer.massageAstNode, i;
              u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
              let l = {};
              for (let [p, y] of Object.entries(s))
                !i.has(p) && typeof y != "function" && (l[p] = t(y, a2, s));
              if (u) {
                let p = u(s, l, n);
                if (p === null)
                  return;
                if (p)
                  return p;
              }
              return l;
            }
            r.exports = t;
          } }), Zt = te({ "scripts/build/shims/assert.cjs"(e, r) {
            "use strict";
            ne();
            var t = () => {
            };
            t.ok = t, t.strictEqual = t, r.exports = t;
          } }), et = te({ "src/main/comments.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { builders: { line: s, hardline: a2, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p } } = qe(), { hasNewline: y, skipNewline: h, skipSpaces: g, isPreviousLineEmpty: c, addLeadingComment: f2, addDanglingComment: F, addTrailingComment: _ } = Ue(), w = /* @__PURE__ */ new WeakMap();
            function E(k, M, R) {
              if (!k)
                return;
              let { printer: q, locStart: J, locEnd: L } = M;
              if (R) {
                if (q.canAttachComment && q.canAttachComment(k)) {
                  let V;
                  for (V = R.length - 1; V >= 0 && !(J(R[V]) <= J(k) && L(R[V]) <= L(k)); --V)
                    ;
                  R.splice(V + 1, 0, k);
                  return;
                }
              } else if (w.has(k))
                return w.get(k);
              let Q = q.getCommentChildNodes && q.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
                let [j] = V;
                return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
              }).map((V) => {
                let [, j] = V;
                return j;
              });
              if (Q) {
                R || (R = [], w.set(k, R));
                for (let V of Q)
                  E(V, M, R);
                return R;
              }
            }
            function N(k, M, R, q) {
              let { locStart: J, locEnd: L } = R, Q = J(M), V = L(M), j = E(k, R), Y, ie, ee = 0, ce = j.length;
              for (; ee < ce; ) {
                let W = ee + ce >> 1, K = j[W], de = J(K), ue = L(K);
                if (de <= Q && V <= ue)
                  return N(K, M, R, K);
                if (ue <= Q) {
                  Y = K, ee = W + 1;
                  continue;
                }
                if (V <= de) {
                  ie = K, ce = W;
                  continue;
                }
                throw new Error("Comment location overlaps with node location");
              }
              if (q && q.type === "TemplateLiteral") {
                let { quasis: W } = q, K = C(W, M, R);
                Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);
              }
              return { enclosingNode: q, precedingNode: Y, followingNode: ie };
            }
            var x = () => false;
            function I(k, M, R, q) {
              if (!Array.isArray(k))
                return;
              let J = [], { locStart: L, locEnd: Q, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x, endOfLine: ie = x, remaining: ee = x } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q)), {}, { comment: W, text: R, options: q, ast: M, isLastComment: k.length - 1 === K }));
              for (let [W, K] of ce.entries()) {
                let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U, options: Z, ast: se, isLastComment: fe } = K;
                if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                  if (L(de) - L(se) <= 0) {
                    f2(se, de);
                    continue;
                  }
                  if (Q(de) - Q(se) >= 0) {
                    _(se, de);
                    continue;
                  }
                }
                let ge;
                if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $(U, Z, ce, W))
                  de.placement = "ownLine", Y(...ge) || (z ? f2(z, de) : ue ? _(ue, de) : F(Fe || se, de));
                else if (D(U, Z, ce, W))
                  de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f2(z, de) : F(Fe || se, de));
                else if (de.placement = "remaining", !ee(...ge))
                  if (ue && z) {
                    let he = J.length;
                    he > 0 && J[he - 1].followingNode !== z && T(J, U, Z), J.push(K);
                  } else
                    ue ? _(ue, de) : z ? f2(z, de) : F(Fe || se, de);
              }
              if (T(J, R, q), !j)
                for (let W of k)
                  delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
            }
            var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
            function $(k, M, R, q) {
              let { comment: J, precedingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = Q(J);
              if (L)
                for (let Y = q - 1; Y >= 0; Y--) {
                  let { comment: ie, precedingNode: ee } = R[Y];
                  if (ee !== L || !P(k.slice(V(ie), j)))
                    break;
                  j = Q(ie);
                }
              return y(k, j, { backwards: true });
            }
            function D(k, M, R, q) {
              let { comment: J, followingNode: L } = R[q], { locStart: Q, locEnd: V } = M, j = V(J);
              if (L)
                for (let Y = q + 1; Y < R.length; Y++) {
                  let { comment: ie, followingNode: ee } = R[Y];
                  if (ee !== L || !P(k.slice(j, Q(ie))))
                    break;
                  j = V(ie);
                }
              return y(k, j);
            }
            function T(k, M, R) {
              let q = k.length;
              if (q === 0)
                return;
              let { precedingNode: J, followingNode: L, enclosingNode: Q } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q) || /^[\s(]*$/, j = R.locStart(L), Y;
              for (Y = q; Y > 0; --Y) {
                let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
                t.strictEqual(ee, J), t.strictEqual(ce, L);
                let W = M.slice(R.locEnd(ie), j);
                if (V.test(W))
                  j = R.locStart(ie);
                else
                  break;
              }
              for (let [ie, { comment: ee }] of k.entries())
                ie < Y ? _(J, ee) : f2(L, ee);
              for (let ie of [J, L])
                ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));
              k.length = 0;
            }
            function m(k, M) {
              let R = k.getValue();
              return R.printed = true, M.printer.printComment(k, M);
            }
            function C(k, M, R) {
              let q = R.locStart(M) - 1;
              for (let J = 1; J < k.length; ++J)
                if (q < R.locStart(k[J]))
                  return J - 1;
              return 0;
            }
            function o(k, M) {
              let R = k.getValue(), q = [m(k, M)], { printer: J, originalText: L, locStart: Q, locEnd: V } = M;
              if (J.isBlockComment && J.isBlockComment(R)) {
                let ie = y(L, V(R)) ? y(L, Q(R), { backwards: true }) ? a2 : s : " ";
                q.push(ie);
              } else
                q.push(a2);
              let Y = h(L, g(L, V(R)));
              return Y !== false && y(L, Y) && q.push(a2), q;
            }
            function d(k, M) {
              let R = k.getValue(), q = m(k, M), { printer: J, originalText: L, locStart: Q } = M, V = J.isBlockComment && J.isBlockComment(R);
              if (y(L, Q(R), { backwards: true })) {
                let Y = c(L, R, Q);
                return i([a2, Y ? a2 : "", q]);
              }
              let j = [" ", q];
              return V || (j = [i(j), n]), j;
            }
            function v(k, M, R, q) {
              let J = [], L = k.getValue();
              return !L || !L.comments || (k.each(() => {
                let Q = k.getValue();
                !Q.leading && !Q.trailing && (!q || q(Q)) && J.push(m(k, M));
              }, "comments"), J.length === 0) ? "" : R ? l(a2, J) : u([a2, l(a2, J)]);
            }
            function S(k, M, R) {
              let q = k.getValue();
              if (!q)
                return {};
              let J = q.comments || [];
              R && (J = J.filter((j) => !R.has(j)));
              let L = q === M.cursorNode;
              if (J.length === 0) {
                let j = L ? p : "";
                return { leading: j, trailing: j };
              }
              let Q = [], V = [];
              return k.each(() => {
                let j = k.getValue();
                if (R && R.has(j))
                  return;
                let { leading: Y, trailing: ie } = j;
                Y ? Q.push(o(k, M)) : ie && V.push(d(k, M));
              }, "comments"), L && (Q.unshift(p), V.push(p)), { leading: Q, trailing: V };
            }
            function b(k, M, R, q) {
              let { leading: J, trailing: L } = S(k, R, q);
              return !J && !L ? M : [J, M, L];
            }
            function B(k) {
              if (k)
                for (let M of k) {
                  if (!M.printed)
                    throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                  delete M.printed;
                }
            }
            r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: E, ensureAllCommentsPrinted: B };
          } }), $m = te({ "src/common/ast-path.js"(e, r) {
            "use strict";
            ne();
            var t = lt();
            function s(u, i) {
              let l = a2(u.stack, i);
              return l === -1 ? null : u.stack[l];
            }
            function a2(u, i) {
              for (let l = u.length - 1; l >= 0; l -= 2) {
                let p = u[l];
                if (p && !Array.isArray(p) && --i < 0)
                  return l;
              }
              return -1;
            }
            var n = class {
              constructor(u) {
                this.stack = [u];
              }
              getName() {
                let { stack: u } = this, { length: i } = u;
                return i > 1 ? u[i - 2] : null;
              }
              getValue() {
                return t(this.stack);
              }
              getNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u);
              }
              getParentNode() {
                let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
                return s(this, u + 1);
              }
              call(u) {
                let { stack: i } = this, { length: l } = i, p = t(i);
                for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h[g - 1] = arguments[g];
                for (let f2 of h)
                  p = p[f2], i.push(f2, p);
                let c = u(this);
                return i.length = l, c;
              }
              callParent(u) {
                let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a2(this.stack, i + 1), p = this.stack.splice(l + 1), y = u(this);
                return this.stack.push(...p), y;
              }
              each(u) {
                let { stack: i } = this, { length: l } = i, p = t(i);
                for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                  h[g - 1] = arguments[g];
                for (let c of h)
                  p = p[c], i.push(c, p);
                for (let c = 0; c < p.length; ++c)
                  i.push(c, p[c]), u(this, c, p), i.length -= 2;
                i.length = l;
              }
              map(u) {
                let i = [];
                for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
                  p[y - 1] = arguments[y];
                return this.each((h, g, c) => {
                  i[g] = u(h, g, c);
                }, ...p), i;
              }
              try(u) {
                let { stack: i } = this, l = [...i];
                try {
                  return u();
                } finally {
                  i.length = 0, i.push(...l);
                }
              }
              match() {
                let u = this.stack.length - 1, i = null, l = this.stack[u--];
                for (var p = arguments.length, y = new Array(p), h = 0; h < p; h++)
                  y[h] = arguments[h];
                for (let g of y) {
                  if (l === void 0)
                    return false;
                  let c = null;
                  if (typeof i == "number" && (c = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c))
                    return false;
                  i = this.stack[u--], l = this.stack[u--];
                }
                return true;
              }
              findAncestor(u) {
                let i = this.stack.length - 1, l = null, p = this.stack[i--];
                for (; p; ) {
                  let y = null;
                  if (typeof l == "number" && (y = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, y))
                    return p;
                  l = this.stack[i--], p = this.stack[i--];
                }
              }
            };
            r.exports = n;
          } }), Vm = te({ "src/main/multiparser.js"(e, r) {
            "use strict";
            ne();
            var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = uo(), a2 = et();
            function n(i, l, p, y) {
              if (p.printer.embed && p.embeddedLanguageFormatting === "auto")
                return p.printer.embed(i, l, (h, g, c) => u(h, g, p, y, c), p);
            }
            function u(i, l, p, y) {
              let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c = tu().parse(i, g), { ast: f2 } = c;
              i = c.text;
              let F = f2.comments;
              delete f2.comments, a2.attach(F, f2, i, g), g[Symbol.for("comments")] = F || [], g[Symbol.for("tokens")] = f2.tokens || [];
              let _ = y(f2, g);
              return a2.ensureAllCommentsPrinted(F), h ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
            }
            r.exports = { printSubtree: n };
          } }), Wm = te({ "src/main/ast-to-doc.js"(e, r) {
            "use strict";
            ne();
            var t = $m(), { builders: { hardline: s, addAlignmentToDoc: a2 }, utils: { propagateBreaks: n } } = qe(), { printComments: u } = et(), i = Vm();
            function l(h, g) {
              let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f2 } = g;
              f2.preprocess && (h = f2.preprocess(h, g));
              let F = /* @__PURE__ */ new Map(), _ = new t(h), w = E();
              return c > 0 && (w = a2([s, w], c, g.tabWidth)), n(w), w;
              function E(x, I) {
                return x === void 0 || x === _ ? N(I) : Array.isArray(x) ? _.call(() => N(I), ...x) : _.call(() => N(I), x);
              }
              function N(x) {
                let I = _.getValue(), P = I && typeof I == "object" && x === void 0;
                if (P && F.has(I))
                  return F.get(I);
                let $ = y(_, g, E, x);
                return P && F.set(I, $), $;
              }
            }
            function p(h, g) {
              let { originalText: c, [Symbol.for("comments")]: f2, locStart: F, locEnd: _ } = g, w = F(h), E = _(h), N = /* @__PURE__ */ new Set();
              for (let x of f2)
                F(x) >= w && _(x) <= E && (x.printed = true, N.add(x));
              return { doc: c.slice(w, E), printedComments: N };
            }
            function y(h, g, c, f2) {
              let F = h.getValue(), { printer: _ } = g, w, E;
              if (_.hasPrettierIgnore && _.hasPrettierIgnore(h))
                ({ doc: w, printedComments: E } = p(F, g));
              else {
                if (F)
                  try {
                    w = i.printSubtree(h, c, g, l);
                  } catch (N) {
                    if (globalThis.PRETTIER_DEBUG)
                      throw N;
                  }
                w || (w = _.print(h, g, c, f2));
              }
              return (!_.willPrintOwnComments || !_.willPrintOwnComments(h, g)) && (w = u(h, w, g, E)), w;
            }
            r.exports = l;
          } }), Hm = te({ "src/main/range-util.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), s = et(), a2 = (f2) => {
              let { parser: F } = f2;
              return F === "json" || F === "json5" || F === "json-stringify";
            };
            function n(f2, F) {
              let _ = [f2.node, ...f2.parentNodes], w = /* @__PURE__ */ new Set([F.node, ...F.parentNodes]);
              return _.find((E) => y.has(E.type) && w.has(E));
            }
            function u(f2) {
              let F = f2.length - 1;
              for (; ; ) {
                let _ = f2[F];
                if (_ && (_.type === "Program" || _.type === "File"))
                  F--;
                else
                  break;
              }
              return f2.slice(0, F + 1);
            }
            function i(f2, F, _) {
              let { locStart: w, locEnd: E } = _, N = f2.node, x = F.node;
              if (N === x)
                return { startNode: N, endNode: x };
              let I = w(f2.node);
              for (let $ of u(F.parentNodes))
                if (w($) >= I)
                  x = $;
                else
                  break;
              let P = E(F.node);
              for (let $ of u(f2.parentNodes)) {
                if (E($) <= P)
                  N = $;
                else
                  break;
                if (N === x)
                  break;
              }
              return { startNode: N, endNode: x };
            }
            function l(f2, F, _, w) {
              let E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N = arguments.length > 5 ? arguments[5] : void 0, { locStart: x, locEnd: I } = _, P = x(f2), $ = I(f2);
              if (!(F > $ || F < P || N === "rangeEnd" && F === P || N === "rangeStart" && F === $)) {
                for (let D of s.getSortedChildNodes(f2, _)) {
                  let T = l(D, F, _, w, [f2, ...E], N);
                  if (T)
                    return T;
                }
                if (!w || w(f2, E[0]))
                  return { node: f2, parentNodes: E };
              }
            }
            function p(f2, F) {
              return F !== "DeclareExportDeclaration" && f2 !== "TypeParameterDeclaration" && (f2 === "Directive" || f2 === "TypeAlias" || f2 === "TSExportAssignment" || f2.startsWith("Declare") || f2.startsWith("TSDeclare") || f2.endsWith("Statement") || f2.endsWith("Declaration"));
            }
            var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
            function g(f2, F, _) {
              if (!F)
                return false;
              switch (f2.parser) {
                case "flow":
                case "babel":
                case "babel-flow":
                case "babel-ts":
                case "typescript":
                case "acorn":
                case "espree":
                case "meriyah":
                case "__babel_estree":
                  return p(F.type, _ && _.type);
                case "json":
                case "json5":
                case "json-stringify":
                  return y.has(F.type);
                case "graphql":
                  return h.has(F.kind);
                case "vue":
                  return F.tag !== "root";
              }
              return false;
            }
            function c(f2, F, _) {
              let { rangeStart: w, rangeEnd: E, locStart: N, locEnd: x } = F;
              t.ok(E > w);
              let I = f2.slice(w, E).search(/\S/), P = I === -1;
              if (!P)
                for (w += I; E > w && !/\S/.test(f2[E - 1]); --E)
                  ;
              let $ = l(_, w, F, (C, o) => g(F, C, o), [], "rangeStart"), D = P ? $ : l(_, E, F, (C) => g(F, C), [], "rangeEnd");
              if (!$ || !D)
                return { rangeStart: 0, rangeEnd: 0 };
              let T, m;
              if (a2(F)) {
                let C = n($, D);
                T = C, m = C;
              } else
                ({ startNode: T, endNode: m } = i($, D, F));
              return { rangeStart: Math.min(N(T), N(m)), rangeEnd: Math.max(x(T), x(m)) };
            }
            r.exports = { calculateRange: c, findNodeAtOffset: l };
          } }), Gm = te({ "src/main/core.js"(e, r) {
            "use strict";
            ne();
            var { diffArrays: t } = BD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a2 } } = qe(), { getAlignmentSize: n } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Jn(), y = uo().normalize, h = Rm(), g = et(), c = tu(), f2 = Wm(), F = Hm(), _ = "\uFEFF", w = Symbol("cursor");
            function E(m, C, o) {
              let d = C.comments;
              return d && (delete C.comments, g.attach(d, C, m, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, d;
            }
            function N(m, C) {
              let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              if (!m || m.trim().length === 0)
                return { formatted: "", cursorOffset: -1, comments: [] };
              let { ast: d, text: v } = c.parse(m, C);
              if (C.cursorOffset >= 0) {
                let k = F.findNodeAtOffset(d, C.cursorOffset, C);
                k && k.node && (C.cursorNode = k.node);
              }
              let S = E(v, d, C), b = f2(d, C, o), B = s(b, C);
              if (g.ensureAllCommentsPrinted(S), o > 0) {
                let k = B.formatted.trim();
                B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
              }
              if (C.cursorOffset >= 0) {
                let k, M, R, q, J;
                if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q = B.cursorNodeStart, J = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q = 0, J = B.formatted), M === J)
                  return { formatted: B.formatted, cursorOffset: q + R, comments: S };
                let L = [...M];
                L.splice(R, 0, w);
                let Q = [...J], V = t(L, Q), j = q;
                for (let Y of V)
                  if (Y.removed) {
                    if (Y.value.includes(w))
                      break;
                  } else
                    j += Y.count;
                return { formatted: B.formatted, cursorOffset: j, comments: S };
              }
              return { formatted: B.formatted, cursorOffset: -1, comments: S };
            }
            function x(m, C) {
              let { ast: o, text: d } = c.parse(m, C), { rangeStart: v, rangeEnd: S } = F.calculateRange(d, C, o), b = d.slice(v, S), B = Math.min(v, d.lastIndexOf(`
`, v) + 1), k = d.slice(B, v).match(/^\s*/)[0], M = n(k, C.tabWidth), R = N(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q = R.formatted.trimEnd(), { cursorOffset: J } = C;
              J > S ? J += q.length - b.length : R.cursorOffset >= 0 && (J = R.cursorOffset + v);
              let L = d.slice(0, v) + q + d.slice(S);
              if (C.endOfLine !== "lf") {
                let Q = i(C.endOfLine);
                J >= 0 && Q === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Q);
              }
              return { formatted: L, cursorOffset: J, comments: R.comments };
            }
            function I(m, C, o) {
              return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
            }
            function P(m, C) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: v } = C;
              return o = I(m, o, -1), d = I(m, d, 0), v = I(m, v, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v });
            }
            function $(m, C) {
              let { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
              if (b && (m = m.slice(1), o--, d--, v--), S === "auto" && (S = u(m)), m.includes("\r")) {
                let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
                o -= B(o), d -= B(d), v -= B(v), m = p(m);
              }
              return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: d, rangeEnd: v, endOfLine: S })) };
            }
            function D(m, C) {
              let o = c.resolveParser(C);
              return !o.hasPragma || o.hasPragma(m);
            }
            function T(m, C) {
              let { hasBOM: o, text: d, options: v } = $(m, y(C));
              if (v.rangeStart >= v.rangeEnd && d !== "" || v.requirePragma && !D(d, v))
                return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
              let S;
              return v.rangeStart > 0 || v.rangeEnd < d.length ? S = x(d, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(d, v) && (d = v.printer.insertPragma(d)), S = N(d, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
            }
            r.exports = { formatWithCursor: T, parse(m, C, o) {
              let { text: d, options: v } = $(m, y(C)), S = c.parse(d, v);
              return o && (S.ast = h(S.ast, v)), S;
            }, formatAST(m, C) {
              C = y(C);
              let o = f2(m, C);
              return s(o, C);
            }, formatDoc(m, C) {
              return T(a2(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
            }, printToDoc(m, C) {
              C = y(C);
              let { ast: o, text: d } = c.parse(m, C);
              return E(d, o, C), f2(o, C);
            }, printDocToString(m, C) {
              return s(m, y(C));
            } };
          } }), Um = te({ "src/common/util-shared.js"(e, r) {
            "use strict";
            ne();
            var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a2, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: c, hasNewline: f2, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D } = Ue();
            r.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a2, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: c, hasNewline: f2, hasNewlineInRange: F, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: E, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: D };
          } }), _t = te({ "src/utils/create-language.js"(e, r) {
            "use strict";
            ne(), r.exports = function(t, s) {
              let { languageId: a2 } = t, n = Hn(t, CD);
              return Object.assign(Object.assign({ linguistLanguageId: a2 }, n), s(t));
            };
          } }), Jm = te({ "node_modules/esutils/lib/ast.js"(e, r) {
            ne(), function() {
              "use strict";
              function t(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "ArrayExpression":
                  case "AssignmentExpression":
                  case "BinaryExpression":
                  case "CallExpression":
                  case "ConditionalExpression":
                  case "FunctionExpression":
                  case "Identifier":
                  case "Literal":
                  case "LogicalExpression":
                  case "MemberExpression":
                  case "NewExpression":
                  case "ObjectExpression":
                  case "SequenceExpression":
                  case "ThisExpression":
                  case "UnaryExpression":
                  case "UpdateExpression":
                    return true;
                }
                return false;
              }
              function s(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "DoWhileStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "WhileStatement":
                    return true;
                }
                return false;
              }
              function a2(l) {
                if (l == null)
                  return false;
                switch (l.type) {
                  case "BlockStatement":
                  case "BreakStatement":
                  case "ContinueStatement":
                  case "DebuggerStatement":
                  case "DoWhileStatement":
                  case "EmptyStatement":
                  case "ExpressionStatement":
                  case "ForInStatement":
                  case "ForStatement":
                  case "IfStatement":
                  case "LabeledStatement":
                  case "ReturnStatement":
                  case "SwitchStatement":
                  case "ThrowStatement":
                  case "TryStatement":
                  case "VariableDeclaration":
                  case "WhileStatement":
                  case "WithStatement":
                    return true;
                }
                return false;
              }
              function n(l) {
                return a2(l) || l != null && l.type === "FunctionDeclaration";
              }
              function u(l) {
                switch (l.type) {
                  case "IfStatement":
                    return l.alternate != null ? l.alternate : l.consequent;
                  case "LabeledStatement":
                  case "ForStatement":
                  case "ForInStatement":
                  case "WhileStatement":
                  case "WithStatement":
                    return l.body;
                }
                return null;
              }
              function i(l) {
                var p;
                if (l.type !== "IfStatement" || l.alternate == null)
                  return false;
                p = l.consequent;
                do {
                  if (p.type === "IfStatement" && p.alternate == null)
                    return true;
                  p = u(p);
                } while (p);
                return false;
              }
              r.exports = { isExpression: t, isStatement: a2, isIterationStatement: s, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
            }();
          } }), so = te({ "node_modules/esutils/lib/code.js"(e, r) {
            ne(), function() {
              "use strict";
              var t, s, a2, n, u, i;
              s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
              function l(E) {
                return 48 <= E && E <= 57;
              }
              function p(E) {
                return 48 <= E && E <= 57 || 97 <= E && E <= 102 || 65 <= E && E <= 70;
              }
              function y(E) {
                return E >= 48 && E <= 55;
              }
              a2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
              function h(E) {
                return E === 32 || E === 9 || E === 11 || E === 12 || E === 160 || E >= 5760 && a2.indexOf(E) >= 0;
              }
              function g(E) {
                return E === 10 || E === 13 || E === 8232 || E === 8233;
              }
              function c(E) {
                if (E <= 65535)
                  return String.fromCharCode(E);
                var N = String.fromCharCode(Math.floor((E - 65536) / 1024) + 55296), x = String.fromCharCode((E - 65536) % 1024 + 56320);
                return N + x;
              }
              for (n = new Array(128), i = 0; i < 128; ++i)
                n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
              for (u = new Array(128), i = 0; i < 128; ++i)
                u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
              function f2(E) {
                return E < 128 ? n[E] : s.NonAsciiIdentifierStart.test(c(E));
              }
              function F(E) {
                return E < 128 ? u[E] : s.NonAsciiIdentifierPart.test(c(E));
              }
              function _(E) {
                return E < 128 ? n[E] : t.NonAsciiIdentifierStart.test(c(E));
              }
              function w(E) {
                return E < 128 ? u[E] : t.NonAsciiIdentifierPart.test(c(E));
              }
              r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: y, isWhiteSpace: h, isLineTerminator: g, isIdentifierStartES5: f2, isIdentifierPartES5: F, isIdentifierStartES6: _, isIdentifierPartES6: w };
            }();
          } }), zm = te({ "node_modules/esutils/lib/keyword.js"(e, r) {
            ne(), function() {
              "use strict";
              var t = so();
              function s(f2) {
                switch (f2) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "let":
                    return true;
                  default:
                    return false;
                }
              }
              function a2(f2, F) {
                return !F && f2 === "yield" ? false : n(f2, F);
              }
              function n(f2, F) {
                if (F && s(f2))
                  return true;
                switch (f2.length) {
                  case 2:
                    return f2 === "if" || f2 === "in" || f2 === "do";
                  case 3:
                    return f2 === "var" || f2 === "for" || f2 === "new" || f2 === "try";
                  case 4:
                    return f2 === "this" || f2 === "else" || f2 === "case" || f2 === "void" || f2 === "with" || f2 === "enum";
                  case 5:
                    return f2 === "while" || f2 === "break" || f2 === "catch" || f2 === "throw" || f2 === "const" || f2 === "yield" || f2 === "class" || f2 === "super";
                  case 6:
                    return f2 === "return" || f2 === "typeof" || f2 === "delete" || f2 === "switch" || f2 === "export" || f2 === "import";
                  case 7:
                    return f2 === "default" || f2 === "finally" || f2 === "extends";
                  case 8:
                    return f2 === "function" || f2 === "continue" || f2 === "debugger";
                  case 10:
                    return f2 === "instanceof";
                  default:
                    return false;
                }
              }
              function u(f2, F) {
                return f2 === "null" || f2 === "true" || f2 === "false" || a2(f2, F);
              }
              function i(f2, F) {
                return f2 === "null" || f2 === "true" || f2 === "false" || n(f2, F);
              }
              function l(f2) {
                return f2 === "eval" || f2 === "arguments";
              }
              function p(f2) {
                var F, _, w;
                if (f2.length === 0 || (w = f2.charCodeAt(0), !t.isIdentifierStartES5(w)))
                  return false;
                for (F = 1, _ = f2.length; F < _; ++F)
                  if (w = f2.charCodeAt(F), !t.isIdentifierPartES5(w))
                    return false;
                return true;
              }
              function y(f2, F) {
                return (f2 - 55296) * 1024 + (F - 56320) + 65536;
              }
              function h(f2) {
                var F, _, w, E, N;
                if (f2.length === 0)
                  return false;
                for (N = t.isIdentifierStartES6, F = 0, _ = f2.length; F < _; ++F) {
                  if (w = f2.charCodeAt(F), 55296 <= w && w <= 56319) {
                    if (++F, F >= _ || (E = f2.charCodeAt(F), !(56320 <= E && E <= 57343)))
                      return false;
                    w = y(w, E);
                  }
                  if (!N(w))
                    return false;
                  N = t.isIdentifierPartES6;
                }
                return true;
              }
              function g(f2, F) {
                return p(f2) && !u(f2, F);
              }
              function c(f2, F) {
                return h(f2) && !i(f2, F);
              }
              r.exports = { isKeywordES5: a2, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: h, isIdentifierES5: g, isIdentifierES6: c };
            }();
          } }), Xm = te({ "node_modules/esutils/lib/utils.js"(e) {
            ne(), function() {
              "use strict";
              e.ast = Jm(), e.code = so(), e.keyword = zm();
            }();
          } }), Pt = te({ "src/language-js/utils/is-block-comment.js"(e, r) {
            "use strict";
            ne();
            var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a2) => t.has(a2 == null ? void 0 : a2.type);
            r.exports = s;
          } }), Km = te({ "src/language-js/utils/is-node-matches.js"(e, r) {
            "use strict";
            ne();
            function t(a2, n) {
              let u = n.split(".");
              for (let i = u.length - 1; i >= 0; i--) {
                let l = u[i];
                if (i === 0)
                  return a2.type === "Identifier" && a2.name === l;
                if (a2.type !== "MemberExpression" || a2.optional || a2.computed || a2.property.type !== "Identifier" || a2.property.name !== l)
                  return false;
                a2 = a2.object;
              }
            }
            function s(a2, n) {
              return n.some((u) => t(a2, u));
            }
            r.exports = s;
          } }), Ke = te({ "src/language-js/utils/index.js"(e, r) {
            "use strict";
            ne();
            var t = Xm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a2, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue(), { locStart: p, locEnd: y, hasSameLocStart: h } = ut(), g = Pt(), c = Km(), f2 = "(?:(?=.)\\s)", F = new RegExp(`^${f2}*:`), _ = new RegExp(`^${f2}*::`);
            function w(O) {
              var me, _e;
              return ((me = O.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && F.test(O.trailingComments[0].value);
            }
            function E(O) {
              let me = O == null ? void 0 : O[0];
              return g(me) && _.test(me.value);
            }
            function N(O, me) {
              if (!O || typeof O != "object")
                return false;
              if (Array.isArray(O))
                return O.some((He) => N(He, me));
              let _e = me(O);
              return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N(He, me));
            }
            function x(O) {
              return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st(O) || O.type === "TSNonNullExpression";
            }
            function I(O) {
              var me, _e, He, Ge, it, Qe;
              return O.expressions ? O.expressions[0] : (me = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me !== void 0 ? me : O.expression;
            }
            function P(O, me) {
              if (me.expressions)
                return ["expressions", 0];
              if (me.left)
                return ["left"];
              if (me.test)
                return ["test"];
              if (me.object)
                return ["object"];
              if (me.callee)
                return ["callee"];
              if (me.tag)
                return ["tag"];
              if (me.argument)
                return ["argument"];
              if (me.expression)
                return ["expression"];
              throw new Error("Unexpected node has no left side.");
            }
            function $(O) {
              return O = new Set(O), (me) => O.has(me == null ? void 0 : me.type);
            }
            var D = $(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
            function m(O) {
              let me = O.getParentNode();
              return O.getName() === "declaration" && T(me) ? me : null;
            }
            var C = $(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
            function o(O) {
              return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
            }
            function d(O) {
              return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
            }
            function v(O) {
              return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
            }
            var S = $(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $(["FunctionExpression", "ArrowFunctionExpression"]);
            function B(O) {
              return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
            }
            function k(O) {
              return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
            }
            var M = $(["JSXElement", "JSXFragment"]);
            function R(O, me) {
              if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
                return false;
              let _e = me.getNode();
              if (!_e.expression || !M(_e.expression))
                return false;
              let He = me.getParentNode();
              return He.type === "Program" && He.body.length === 1;
            }
            function q(O) {
              return O.kind === "get" || O.kind === "set";
            }
            function J(O) {
              return q(O) || h(O, O.value);
            }
            function L(O) {
              return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J(O);
            }
            function Q(O) {
              return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !h(O, O.typeAnnotation);
            }
            var V = $(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
            function j(O) {
              return ue(O) || O.type === "BindExpression" && Boolean(O.object);
            }
            var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
            function ie(O) {
              return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
            }
            function ee(O) {
              let me = /^(?:before|after)(?:Each|All)$/;
              return O.callee.type === "Identifier" && me.test(O.callee.name) && O.arguments.length === 1;
            }
            var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
            function W(O) {
              return c(O, ce);
            }
            function K(O, me) {
              if (O.type !== "CallExpression")
                return false;
              if (O.arguments.length === 1) {
                if (k(O) && me && K(me))
                  return b(O.arguments[0]);
                if (ee(O))
                  return k(O.arguments[0]);
              } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee))
                return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
              return false;
            }
            var de = $(["CallExpression", "OptionalCallExpression"]), ue = $(["MemberExpression", "OptionalMemberExpression"]);
            function Fe(O) {
              let me = "expressions";
              O.type === "TSTemplateLiteralType" && (me = "types");
              let _e = O[me];
              return _e.length === 0 ? false : _e.every((He) => {
                if (Me(He))
                  return false;
                if (He.type === "Identifier" || He.type === "ThisExpression")
                  return true;
                if (ue(He)) {
                  let Ge = He;
                  for (; ue(Ge); )
                    if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me(Ge)))
                      return false;
                  return Ge.type === "Identifier" || Ge.type === "ThisExpression";
                }
                return false;
              });
            }
            function z(O, me) {
              return O === "+" || O === "-" ? O + me : me;
            }
            function U(O, me) {
              let _e = p(me), He = n(O, y(me));
              return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
            }
            function Z(O, me) {
              return M(me) ? Oe(me) : Me(me, Te.Leading, (_e) => a2(O, y(_e)));
            }
            function se(O, me) {
              return me.parser !== "json" && v(O.key) && oe(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me.parser === "babel-ts" && O.type === "ClassProperty" || me.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
            }
            function fe(O) {
              return /^(?:\d+|\d+\.\d+)$/.test(O);
            }
            function ge(O, me) {
              let _e = /^[fx]?(?:describe|it|test)$/;
              return me.type === "TaggedTemplateExpression" && me.quasi === O && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && _e.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && _e.test(me.tag.object.object.name));
            }
            function he(O) {
              return O.quasis.some((me) => me.value.raw.includes(`
`));
            }
            function we(O, me) {
              return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a2(me, p(O), { backwards: true });
            }
            function ke(O) {
              if (!Me(O))
                return false;
              let me = s(ae(O, Te.Dangling));
              return me && !g(me);
            }
            function Re(O) {
              if (O.length <= 1)
                return false;
              let me = 0;
              for (let _e of O)
                if (b(_e)) {
                  if (me += 1, me > 1)
                    return true;
                } else if (de(_e)) {
                  for (let He of _e.arguments)
                    if (b(He))
                      return true;
                }
              return false;
            }
            function Ne(O) {
              let me = O.getValue(), _e = O.getParentNode();
              return de(me) && de(_e) && _e.callee === me && me.arguments.length > _e.arguments.length && _e.arguments.length > 0;
            }
            function Pe(O, me) {
              if (me >= 2)
                return false;
              let _e = (Qe) => Pe(Qe, me + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
              if (He && l(He) > 5)
                return false;
              if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import")
                return true;
              if (O.type === "TemplateLiteral")
                return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
              if (O.type === "ObjectExpression")
                return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
              if (O.type === "ArrayExpression")
                return O.elements.every((Qe) => Qe === null || _e(Qe));
              if (tt(O))
                return (O.type === "ImportExpression" || Pe(O.callee, me)) && Ye(O).every(_e);
              if (ue(O))
                return Pe(O.object, me) && Pe(O.property, me);
              let Ge = { "!": true, "-": true, "+": true, "~": true };
              if (O.type === "UnaryExpression" && Ge[O.operator])
                return Pe(O.argument, me);
              let it = { "++": true, "--": true };
              return O.type === "UpdateExpression" && it[O.operator] ? Pe(O.argument, me) : O.type === "TSNonNullExpression" ? Pe(O.expression, me) : false;
            }
            function oe(O) {
              var me, _e;
              return (me = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me !== void 0 ? me : O.raw;
            }
            function H(O) {
              return O;
            }
            function pe(O) {
              return O.filepath && /\.tsx$/i.test(O.filepath);
            }
            function X(O) {
              let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
              return O.trailingComma === "es5" && me === "es5" || O.trailingComma === "all" && (me === "all" || me === "es5");
            }
            function le(O, me) {
              switch (O.type) {
                case "BinaryExpression":
                case "LogicalExpression":
                case "AssignmentExpression":
                case "NGPipeExpression":
                  return le(O.left, me);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return le(O.object, me);
                case "TaggedTemplateExpression":
                  return O.tag.type === "FunctionExpression" ? false : le(O.tag, me);
                case "CallExpression":
                case "OptionalCallExpression":
                  return O.callee.type === "FunctionExpression" ? false : le(O.callee, me);
                case "ConditionalExpression":
                  return le(O.test, me);
                case "UpdateExpression":
                  return !O.prefix && le(O.argument, me);
                case "BindExpression":
                  return O.object && le(O.object, me);
                case "SequenceExpression":
                  return le(O.expressions[0], me);
                case "TSSatisfiesExpression":
                case "TSAsExpression":
                case "TSNonNullExpression":
                  return le(O.expression, me);
                default:
                  return me(O);
              }
            }
            var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
            function A2(O, me) {
              return !(re(me) !== re(O) || O === "**" || Ae[O] && Ae[me] || me === "%" && Ee[O] || O === "%" && Ee[me] || me !== O && Ee[me] && Ee[O] || De[O] && De[me]);
            }
            var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me) => O.map((_e) => [_e, me])));
            function re(O) {
              return G.get(O);
            }
            function ye(O) {
              return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
            }
            function Ce(O) {
              var me;
              if (O.rest)
                return true;
              let _e = ve(O);
              return ((me = s(_e)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
            }
            var Be = /* @__PURE__ */ new WeakMap();
            function ve(O) {
              if (Be.has(O))
                return Be.get(O);
              let me = [];
              return O.this && me.push(O.this), Array.isArray(O.parameters) ? me.push(...O.parameters) : Array.isArray(O.params) && me.push(...O.params), O.rest && me.push(O.rest), Be.set(O, me), me;
            }
            function ze(O, me) {
              let _e = O.getValue(), He = 0, Ge = (it) => me(it, He++);
              _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
            }
            var be = /* @__PURE__ */ new WeakMap();
            function Ye(O) {
              if (be.has(O))
                return be.get(O);
              let me = O.arguments;
              return O.type === "ImportExpression" && (me = [O.source], O.attributes && me.push(O.attributes)), be.set(O, me), me;
            }
            function Se(O, me) {
              let _e = O.getValue();
              _e.type === "ImportExpression" ? (O.call((He) => me(He, 0), "source"), _e.attributes && O.call((He) => me(He, 1), "attributes")) : O.each(me, "arguments");
            }
            function Ie(O) {
              return O.value.trim() === "prettier-ignore" && !O.unignore;
            }
            function Oe(O) {
              return O && (O.prettierIgnore || Me(O, Te.PrettierIgnore));
            }
            function Je(O) {
              let me = O.getValue();
              return Oe(me);
            }
            var Te = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me) => {
              if (typeof O == "function" && (me = O, O = 0), O || me)
                return (_e, He, Ge) => !(O & Te.Leading && !_e.leading || O & Te.Trailing && !_e.trailing || O & Te.Dangling && (_e.leading || _e.trailing) || O & Te.Block && !g(_e) || O & Te.Line && !D(_e) || O & Te.First && He !== 0 || O & Te.Last && He !== Ge.length - 1 || O & Te.PrettierIgnore && !Ie(_e) || me && !me(_e));
            };
            function Me(O, me, _e) {
              if (!u(O == null ? void 0 : O.comments))
                return false;
              let He = je(me, _e);
              return He ? O.comments.some(He) : true;
            }
            function ae(O, me, _e) {
              if (!Array.isArray(O == null ? void 0 : O.comments))
                return [];
              let He = je(me, _e);
              return He ? O.comments.filter(He) : O.comments;
            }
            var nt = (O, me) => {
              let { originalText: _e } = me;
              return i(_e, y(O));
            };
            function tt(O) {
              return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
            }
            function Ve(O) {
              return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
            }
            function We(O) {
              return Boolean(O.__isUsingHackPipeline);
            }
            var Xe = Symbol("ifWithoutBlockAndSameLineComment");
            function st(O) {
              return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
            }
            r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: E, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x, hasNode: N, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U, isFunctionCompositionArgs: Re, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe, isTypeAnnotationAFunction: Q, isNextLineEmpty: nt, needsHardlineAfterDanglingComment: ke, rawText: oe, shouldPrintComma: X, isBitwiseOperator: ye, shouldFlatten: A2, startsWithNoLookaheadToken: le, getPrecedence: re, hasComment: Me, getComments: ae, CommentCheckFlags: Te, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st };
          } }), jt = te({ "src/language-js/print/template-literal.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { getStringWidth: s, getIndentSize: a2 } = Ue(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p, align: y, lineSuffixBoundary: h, addAlignmentToDoc: g }, printer: { printDocToString: c }, utils: { mapDoc: f2 } } = qe(), { isBinaryish: F, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: E, isMemberExpression: N, isTSTypeExpression: x } = Ke();
            function I(C, o, d) {
              let v = C.getValue();
              if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
                let R = P(C, d, o);
                if (R)
                  return R;
              }
              let b = "expressions";
              v.type === "TSTemplateLiteralType" && (b = "types");
              let B = [], k = C.map(o, b), M = w(v);
              return M && (k = k.map((R) => c(R, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(h, "`"), C.each((R) => {
                let q = R.getName();
                if (B.push(o()), q < k.length) {
                  let { tabWidth: J } = d, L = R.getValue(), Q = a2(L.value.raw, J), V = k[q];
                  if (!M) {
                    let Y = v[b][q];
                    (E(Y) || N(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x(Y) || F(Y)) && (V = [p([i, V]), i]);
                  }
                  let j = Q === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Q, J);
                  B.push(l(["${", j, h, "}"]));
                }
              }, "quasis"), B.push("`"), B;
            }
            function P(C, o, d) {
              let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
              if (S.length > 1 || S.some((b) => b.length > 0)) {
                o.__inJestEach = true;
                let b = C.map(d, "expressions");
                o.__inJestEach = false;
                let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
                for (let L = 1; L < v.quasis.length; L++) {
                  let Q = t(M), V = k[L - 1];
                  Q.cells.push(V), V.includes(`
`) && (Q.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
                }
                let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q = Array.from({ length: R }).fill(0), J = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
                for (let { cells: L } of J.filter((Q) => !Q.hasLineBreak))
                  for (let [Q, V] of L.entries())
                    q[Q] = Math.max(q[Q], s(V));
                return B.push(h, "`", p([u, n(u, J.map((L) => n(" | ", L.cells.map((Q, V) => L.hasLineBreak ? Q : Q + " ".repeat(q[V] - s(Q))))))]), u, "`"), B;
              }
            }
            function $(C, o) {
              let d = C.getValue(), v = o();
              return E(d) && (v = l([p([i, v]), i])), ["${", v, h, "}"];
            }
            function D(C, o) {
              return C.map((d) => $(d, o), "expressions");
            }
            function T(C, o) {
              return f2(C, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m(d) : d);
            }
            function m(C) {
              return C.replace(/([\\`]|\${)/g, "\\$1");
            }
            r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
          } }), Ym = te({ "src/language-js/embed/markdown.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t, softline: s, literalline: a2, dedentToRoot: n } } = qe(), { escapeTemplateCharacters: u } = jt();
            function i(p, y, h) {
              let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, E) => "\\".repeat(E.length / 2) + "`"), f2 = l(c), F = f2 !== "";
              F && (c = c.replace(new RegExp(`^${f2}`, "gm"), ""));
              let _ = u(h(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
              return ["`", F ? t([s, _]) : [a2, n(_)], s, "`"];
            }
            function l(p) {
              let y = p.match(/^([^\S\n]*)\S/m);
              return y === null ? "" : y[1];
            }
            r.exports = i;
          } }), Qm = te({ "src/language-js/embed/css.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, hardline: a2, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = jt();
            function y(c, f2, F) {
              let _ = c.getValue(), w = _.quasis.map((P) => P.value.raw), E = 0, N = w.reduce((P, $, D) => D === 0 ? $ : P + "@prettier-placeholder-" + E++ + "-id" + $, ""), x = F(N, { parser: "scss" }, { stripTrailingHardline: true }), I = p(c, f2);
              return h(x, _, I);
            }
            function h(c, f2, F) {
              if (f2.quasis.length === 1 && !f2.quasis[0].value.raw.trim())
                return "``";
              let w = g(c, F);
              if (!w)
                throw new Error("Couldn't insert all the expressions");
              return ["`", s([a2, w]), n, "`"];
            }
            function g(c, f2) {
              if (!t(f2))
                return c;
              let F = 0, _ = u(l(c), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((E, N) => N % 2 === 0 ? i(E) : (F++, f2[E])));
              return f2.length === F ? _ : null;
            }
            r.exports = y;
          } }), Zm = te({ "src/language-js/embed/graphql.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t, join: s, hardline: a2 } } = qe(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = jt();
            function i(p, y, h) {
              let g = p.getValue(), c = g.quasis.length;
              if (c === 1 && g.quasis[0].value.raw.trim() === "")
                return "``";
              let f2 = u(p, y), F = [];
              for (let _ = 0; _ < c; _++) {
                let w = g.quasis[_], E = _ === 0, N = _ === c - 1, x = w.value.cooked, I = x.split(`
`), P = I.length, $ = f2[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
                if (!N && /#[^\n\r]*$/.test(I[P - 1]))
                  return null;
                let C = null;
                m ? C = l(I) : C = h(x, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !E && D && F.push(""), F.push(C), !N && T && F.push("")) : !E && !N && D && F.push(""), $ && F.push($);
              }
              return ["`", t([a2, s(a2, F)]), a2, "`"];
            }
            function l(p) {
              let y = [], h = false, g = p.map((c) => c.trim());
              for (let [c, f2] of g.entries())
                f2 !== "" && (g[c - 1] === "" && h ? y.push([a2, f2]) : y.push(f2), h = true);
              return y.length === 0 ? null : s(a2, y);
            }
            r.exports = i;
          } }), ed = te({ "src/language-js/embed/html.js"(e, r) {
            "use strict";
            ne();
            var { builders: { indent: t, line: s, hardline: a2, group: n }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt(), p = 0;
            function y(h, g, c, f2, F) {
              let { parser: _ } = F, w = h.getValue(), E = p;
              p = p + 1 >>> 0;
              let N = (d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${E}_IN_JS`, x = w.quasis.map((d, v, S) => v === S.length - 1 ? d.value.cooked : d.value.cooked + N(v)).join(""), I = i(h, g);
              if (I.length === 0 && x.trim().length === 0)
                return "``";
              let P = new RegExp(N("(\\d+)"), "g"), $ = 0, D = c(x, { parser: _, __onHtmlRoot(d) {
                $ = d.children.length;
              } }, { stripTrailingHardline: true }), T = u(D, (d) => {
                if (typeof d != "string")
                  return d;
                let v = [], S = d.split(P);
                for (let b = 0; b < S.length; b++) {
                  let B = S[b];
                  if (b % 2 === 0) {
                    B && (B = l(B), f2.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
                    continue;
                  }
                  let k = Number(B);
                  v.push(I[k]);
                }
                return v;
              }), m = /^\s/.test(x) ? " " : "", C = /\s$/.test(x) ? " " : "", o = f2.htmlWhitespaceSensitivity === "ignore" ? a2 : m && C ? s : null;
              return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m, $ > 1 ? t(n(T)) : n(T), C, "`"]);
            }
            r.exports = y;
          } }), td = te({ "src/language-js/embed.js"(e, r) {
            "use strict";
            ne();
            var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a2 } = Ke(), n = Ym(), u = Qm(), i = Zm(), l = ed();
            function p(D) {
              if (g(D) || _(D) || w(D) || c(D))
                return "css";
              if (x(D))
                return "graphql";
              if (P(D))
                return "html";
              if (f2(D))
                return "angular";
              if (h(D))
                return "markdown";
            }
            function y(D, T, m, C) {
              let o = D.getValue();
              if (o.type !== "TemplateLiteral" || $(o))
                return;
              let d = p(D);
              if (d) {
                if (d === "markdown")
                  return n(D, T, m);
                if (d === "css")
                  return u(D, T, m);
                if (d === "graphql")
                  return i(D, T, m);
                if (d === "html" || d === "angular")
                  return l(D, T, m, C, { parser: d });
              }
            }
            function h(D) {
              let T = D.getValue(), m = D.getParentNode();
              return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
            }
            function g(D) {
              let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
              return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
            }
            function c(D) {
              return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a2(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...F);
            }
            function f2(D) {
              return D.match((T) => T.type === "TemplateLiteral", (T, m) => a2(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...F);
            }
            var F = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
            function _(D) {
              let T = D.getParentNode();
              if (!T || T.type !== "TaggedTemplateExpression")
                return false;
              let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
              switch (m.type) {
                case "MemberExpression":
                  return E(m.object) || N(m);
                case "CallExpression":
                  return E(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (E(m.callee.object.object) || N(m.callee.object)) || m.callee.object.type === "CallExpression" && E(m.callee.object.callee));
                case "Identifier":
                  return m.name === "css";
                default:
                  return false;
              }
            }
            function w(D) {
              let T = D.getParentNode(), m = D.getParentNode(1);
              return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
            }
            function E(D) {
              return D.type === "Identifier" && D.name === "styled";
            }
            function N(D) {
              return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
            }
            function x(D) {
              let T = D.getValue(), m = D.getParentNode();
              return I(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
            }
            function I(D, T) {
              return t(D, s.Block | s.Leading, (m) => {
                let { value: C } = m;
                return C === ` ${T} `;
              });
            }
            function P(D) {
              return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
            }
            function $(D) {
              let { quasis: T } = D;
              return T.some((m) => {
                let { value: { cooked: C } } = m;
                return C === null;
              });
            }
            r.exports = y;
          } }), rd = te({ "src/language-js/clean.js"(e, r) {
            "use strict";
            ne();
            var t = Pt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a2 = (u) => {
              for (let i of u.quasis)
                delete i.value;
            };
            function n(u, i, l) {
              if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
                return null;
              if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h) => h.name.name === "jsx"))
                for (let { type: h, expression: g } of i.children)
                  h === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a2(g);
              u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a2(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
              let p = u.expression || u.callee;
              if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
                let h = u.expression.arguments[0].properties;
                for (let [g, c] of i.expression.arguments[0].properties.entries())
                  switch (h[g].key.name) {
                    case "styles":
                      c.value.type === "ArrayExpression" && a2(c.value.elements[0]);
                      break;
                    case "template":
                      c.value.type === "TemplateLiteral" && a2(c.value);
                      break;
                  }
              }
              if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a2(i.quasi), u.type === "TemplateLiteral") {
                var y;
                (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t(g) && ["GraphQL", "HTML"].some((c) => g.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a2(i);
              }
              if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
                return i.types[0];
            }
            n.ignoredProperties = s, r.exports = n;
          } }), io = {};
          Kt(io, { EOL: () => Wn, arch: () => nd, cpus: () => Do, default: () => vo, endianness: () => ao, freemem: () => po, getNetworkInterfaces: () => ho, hostname: () => oo, loadavg: () => lo, networkInterfaces: () => yo, platform: () => ud, release: () => go, tmpDir: () => $n, tmpdir: () => Vn, totalmem: () => fo, type: () => mo, uptime: () => co });
          function ao() {
            if (typeof Tr > "u") {
              var e = new ArrayBuffer(2), r = new Uint8Array(e), t = new Uint16Array(e);
              if (r[0] = 1, r[1] = 2, t[0] === 258)
                Tr = "BE";
              else if (t[0] === 513)
                Tr = "LE";
              else
                throw new Error("unable to figure out endianess");
            }
            return Tr;
          }
          function oo() {
            return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
          }
          function lo() {
            return [];
          }
          function co() {
            return 0;
          }
          function po() {
            return Number.MAX_VALUE;
          }
          function fo() {
            return Number.MAX_VALUE;
          }
          function Do() {
            return [];
          }
          function mo() {
            return "Browser";
          }
          function go() {
            return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
          }
          function yo() {
          }
          function ho() {
          }
          function nd() {
            return "javascript";
          }
          function ud() {
            return "browser";
          }
          function $n() {
            return "/tmp";
          }
          var Tr, Vn, Wn, vo, sd = ht({ "node-modules-polyfills:os"() {
            ne(), Vn = $n, Wn = `
`, vo = { EOL: Wn, tmpdir: Vn, tmpDir: $n, networkInterfaces: yo, getNetworkInterfaces: ho, release: go, type: mo, cpus: Do, totalmem: fo, freemem: po, uptime: co, loadavg: lo, hostname: oo, endianness: ao };
          } }), id = te({ "node-modules-polyfills-commonjs:os"(e, r) {
            ne();
            var t = (sd(), ft(io));
            if (t && t.default) {
              r.exports = t.default;
              for (let s in t)
                r.exports[s] = t[s];
            } else
              t && (r.exports = t);
          } }), ad = te({ "node_modules/detect-newline/index.js"(e, r) {
            "use strict";
            ne();
            var t = (s) => {
              if (typeof s != "string")
                throw new TypeError("Expected a string");
              let a2 = s.match(/(?:\r?\n)/g) || [];
              if (a2.length === 0)
                return;
              let n = a2.filter((i) => i === `\r
`).length, u = a2.length - n;
              return n > u ? `\r
` : `
`;
            };
            r.exports = t, r.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
          } }), od = te({ "node_modules/jest-docblock/build/index.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c, e.parse = F, e.parseWithComments = _, e.print = w, e.strip = f2;
            function r() {
              let N = id();
              return r = function() {
                return N;
              }, N;
            }
            function t() {
              let N = s(ad());
              return t = function() {
                return N;
              }, N;
            }
            function s(N) {
              return N && N.__esModule ? N : { default: N };
            }
            var a2 = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, g = [];
            function c(N) {
              let x = N.match(u);
              return x ? x[0].trimLeft() : "";
            }
            function f2(N) {
              let x = N.match(u);
              return x && x[0] ? N.substring(x[0].length) : N;
            }
            function F(N) {
              return _(N).pragmas;
            }
            function _(N) {
              let x = (0, t().default)(N) || r().EOL;
              N = N.replace(n, "").replace(a2, "").replace(h, "$1");
              let I = "";
              for (; I !== N; )
                I = N, N = N.replace(p, `${x}$1 $2${x}`);
              N = N.replace(l, "").trimRight();
              let P = /* @__PURE__ */ Object.create(null), $ = N.replace(y, "").replace(l, "").trimRight(), D;
              for (; D = y.exec(N); ) {
                let T = D[2].replace(i, "");
                typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
              }
              return { comments: $, pragmas: P };
            }
            function w(N) {
              let { comments: x = "", pragmas: I = {} } = N, P = (0, t().default)(x) || r().EOL, $ = "/**", D = " *", T = " */", m = Object.keys(I), C = m.map((d) => E(d, I[d])).reduce((d, v) => d.concat(v), []).map((d) => `${D} ${d}${P}`).join("");
              if (!x) {
                if (m.length === 0)
                  return "";
                if (m.length === 1 && !Array.isArray(I[m[0]])) {
                  let d = I[m[0]];
                  return `${$} ${E(m[0], d)[0]}${T}`;
                }
              }
              let o = x.split(P).map((d) => `${D} ${d}`).join(P) + P;
              return $ + P + (x ? o : "") + (x && m.length ? D + P : "") + C + T;
            }
            function E(N, x) {
              return g.concat(x).map((I) => `@${N} ${I}`.trim());
            }
          } }), ld = te({ "src/language-js/utils/get-shebang.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              if (!s.startsWith("#!"))
                return "";
              let a2 = s.indexOf(`
`);
              return a2 === -1 ? s : s.slice(0, a2);
            }
            r.exports = t;
          } }), Co = te({ "src/language-js/pragma.js"(e, r) {
            "use strict";
            ne();
            var { parseWithComments: t, strip: s, extract: a2, print: n } = od(), { normalizeEndOfLine: u } = Jn(), i = ld();
            function l(h) {
              let g = i(h);
              g && (h = h.slice(g.length + 1));
              let c = a2(h), { pragmas: f2, comments: F } = t(c);
              return { shebang: g, text: h, pragmas: f2, comments: F };
            }
            function p(h) {
              let g = Object.keys(l(h).pragmas);
              return g.includes("prettier") || g.includes("format");
            }
            function y(h) {
              let { shebang: g, text: c, pragmas: f2, comments: F } = l(h), _ = s(c), w = n({ pragmas: Object.assign({ format: "" }, f2), comments: F.trimStart() });
              return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
            }
            r.exports = { hasPragma: p, insertPragma: y };
          } }), cd = te({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
            "use strict";
            ne();
            var t = Pt();
            function s(a2) {
              return t(a2) && a2.value[0] === "*" && /@(?:type|satisfies)\b/.test(a2.value);
            }
            r.exports = s;
          } }), Eo = te({ "src/language-js/comments.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a2, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h } = Ue(), { getFunctionParameters: g, isPrettierIgnoreComment: c, isJsxNode: f2, hasFlowShorthandAnnotationComment: F, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: E, getCallArguments: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isLineComment: $, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: C, locEnd: o } = ut(), d = Pt(), v = cd();
            function S(De) {
              return [H, Fe, Q, q, J, L, ie, he, se, ge, we, ke, ce, z, U].some((A2) => A2(De));
            }
            function b(De) {
              return [R, Fe, V, we, q, J, L, ie, z, Z, fe, ge, Pe, U, X].some((A2) => A2(De));
            }
            function B(De) {
              return [H, q, J, j, ue, ce, ge, de, K, pe, U, oe].some((A2) => A2(De));
            }
            function k(De, A2) {
              let G = (De.body || De.properties).find((re) => {
                let { type: ye } = re;
                return ye !== "EmptyStatement";
              });
              G ? i(G, A2) : p(De, A2);
            }
            function M(De, A2) {
              De.type === "BlockStatement" ? k(De, A2) : i(De, A2);
            }
            function R(De) {
              let { comment: A2, followingNode: G } = De;
              return G && v(A2) ? (i(G, A2), true) : false;
            }
            function q(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye)
                return false;
              if (n(Ce, A2, o) === ")")
                return l(G, A2), true;
              if (G === re.consequent && ye === re.alternate) {
                if (G.type === "BlockStatement")
                  l(G, A2);
                else {
                  let ve = A2.type === "SingleLine" || A2.loc.start.line === A2.loc.end.line, ze = A2.loc.start.line === G.loc.start.line;
                  ve && ze ? p(G, A2, m) : p(re, A2);
                }
                return true;
              }
              return ye.type === "BlockStatement" ? (k(ye, A2), true) : ye.type === "IfStatement" ? (M(ye.consequent, A2), true) : re.consequent === ye ? (i(ye, A2), true) : false;
            }
            function J(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye ? false : n(Ce, A2, o) === ")" ? (l(G, A2), true) : ye.type === "BlockStatement" ? (k(ye, A2), true) : re.body === ye ? (i(ye, A2), true) : false;
            }
            function L(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye ? false : re.type === "CatchClause" && G ? (l(G, A2), true) : ye.type === "BlockStatement" ? (k(ye, A2), true) : ye.type === "TryStatement" ? (M(ye.finalizer, A2), true) : ye.type === "CatchClause" ? (M(ye.body, A2), true) : false;
            }
            function Q(De) {
              let { comment: A2, enclosingNode: G, followingNode: re } = De;
              return I(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A2), true) : false;
            }
            function V(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De, Be = G && !u(Ce, o(G), C(A2));
              return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye ? (i(ye, A2), true) : false;
            }
            function j(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re } = De;
              return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A2), true) : false;
            }
            var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
            function ie(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              if (Y.has(re == null ? void 0 : re.type)) {
                if (h(re.decorators) && !(ye && ye.type === "Decorator"))
                  return l(t(re.decorators), A2), true;
                if (re.body && ye === re.body)
                  return k(re.body, A2), true;
                if (ye) {
                  if (re.superClass && ye === re.superClass && G && (G === re.id || G === re.typeParameters))
                    return l(G, A2), true;
                  for (let Ce of ["implements", "extends", "mixins"])
                    if (re[Ce] && ye === re[Ce][0])
                      return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A2) : p(re, A2, Ce), true;
                }
              }
              return false;
            }
            var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
            function ce(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, text: ye } = De;
              return re && G && n(ye, A2, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n(ye, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re == null ? void 0 : re.type) ? (l(G, A2), true) : false;
            }
            var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
            function K(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, text: ye } = De;
              return n(ye, A2, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A2), true) : false;
            }
            function de(De) {
              let { comment: A2, enclosingNode: G, text: re } = De;
              if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
                return false;
              let ye = y(re, A2, o);
              return ye !== false && re.slice(ye, ye + 2) === "=>" ? (p(G, A2), true) : false;
            }
            function ue(De) {
              let { comment: A2, enclosingNode: G, text: re } = De;
              return n(re, A2, o) !== ")" ? false : G && (le(G) && g(G).length === 0 || E(G) && N(G).length === 0) ? (p(G, A2), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p(G.value, A2), true) : false;
            }
            function Fe(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye, text: Ce } = De;
              if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye == null ? void 0 : ye.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le(re) && n(Ce, A2, o) === ")")
                return l(G, A2), true;
              if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye == null ? void 0 : ye.type) === "BlockStatement") {
                let Be = (() => {
                  let ve = g(re);
                  if (ve.length > 0)
                    return a2(Ce, o(t(ve)));
                  let ze = a2(Ce, o(re.id));
                  return ze !== false && a2(Ce, ze + 1);
                })();
                if (C(A2) > Be)
                  return k(ye, A2), true;
              }
              return false;
            }
            function z(De) {
              let { comment: A2, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A2), true) : false;
            }
            function U(De) {
              let { comment: A2, enclosingNode: G } = De;
              return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A2), true) : false;
            }
            function Z(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re } = De;
              return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A2), true) : false;
            }
            function se(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c(A2) && (ye.prettierIgnore = true, A2.unignore = true), G ? (l(G, A2), true) : false) : (((ye == null ? void 0 : ye.type) === "UnionTypeAnnotation" || (ye == null ? void 0 : ye.type) === "TSUnionType") && c(A2) && (ye.types[0].prettierIgnore = true, A2.unignore = true), false);
            }
            function fe(De) {
              let { comment: A2, enclosingNode: G } = De;
              return P(G) ? (i(G, A2), true) : false;
            }
            function ge(De) {
              let { comment: A2, enclosingNode: G, followingNode: re, ast: ye, isLastComment: Ce } = De;
              return ye && ye.body && ye.body.length === 0 ? (Ce ? p(ye, A2) : i(ye, A2), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h(G.directives) ? (Ce ? p(G, A2) : i(G, A2), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A2), true) : false;
            }
            function he(De) {
              let { comment: A2, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A2), true) : false;
            }
            function we(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, text: ye } = De;
              if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier")
                return i(re, A2), true;
              let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
              return (Ce || Be) && s(ye, o(A2)) ? (l(G, A2), true) : false;
            }
            function ke(De) {
              let { comment: A2, enclosingNode: G } = De;
              return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A2), true) : false;
            }
            var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
            function Pe(De) {
              let { comment: A2, enclosingNode: G, followingNode: re } = De;
              return Re.has(G == null ? void 0 : G.type) && re && (Ne.has(re.type) || d(A2)) ? (i(re, A2), true) : false;
            }
            function oe(De) {
              let { comment: A2, enclosingNode: G, followingNode: re, text: ye } = De;
              return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye, A2, o) === ";" ? (l(G, A2), true) : false;
            }
            function H(De) {
              let { comment: A2, enclosingNode: G, followingNode: re } = De;
              if (c(A2) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint)
                return G.prettierIgnore = true, A2.unignore = true, true;
            }
            function pe(De) {
              let { comment: A2, precedingNode: G, enclosingNode: re, followingNode: ye } = De;
              return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye == null ? void 0 : ye.type) === "TSTypeParameter" && ye.name ? (i(ye.name, A2), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A2), true) : false;
            }
            function X(De) {
              let { comment: A2, enclosingNode: G, followingNode: re } = De;
              return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $(A2) ? k(re, A2) : p(G, A2), true);
            }
            function le(De) {
              return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
            }
            function Ae(De, A2) {
              if ((A2.parser === "typescript" || A2.parser === "flow" || A2.parser === "acorn" || A2.parser === "espree" || A2.parser === "meriyah" || A2.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !h(De.value.typeParameters) && De.value.body)
                return [...De.decorators || [], De.key, De.value.body];
            }
            function Ee(De) {
              let A2 = De.getValue(), G = De.getParentNode(), re = (ye) => _(D(ye, T.Leading)) || _(D(ye, T.Trailing));
              return (A2 && (f2(A2) || F(A2) || x(G) && re(A2)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A2)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
            }
            r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
          } }), qt = te({ "src/language-js/needs-parens.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), s = Kn(), { getFunctionParameters: a2, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: y, shouldFlatten: h, getPrecedence: g, isCallExpression: c, isMemberExpression: f2, isObjectProperty: F, isTSTypeExpression: _ } = Ke();
            function w(D, T) {
              let m = D.getParentNode();
              if (!m)
                return false;
              let C = D.getName(), o = D.getNode();
              if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D))
                return true;
              if (E(o))
                return false;
              if (T.parser !== "flow" && u(D.getValue()))
                return true;
              if (o.type === "Identifier") {
                if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement")
                  return true;
                if (o.name === "let") {
                  var d;
                  let S = (d = D.findAncestor((b) => b.type === "ForOfStatement")) === null || d === void 0 ? void 0 : d.left;
                  if (S && y(S, (b) => b === o))
                    return true;
                }
                if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
                  let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
                  if (b && y(b, (B) => B === o))
                    return true;
                }
                return false;
              }
              if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
                var v;
                let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
                if (S && y(S, (b) => b === o))
                  return true;
              }
              switch (m.type) {
                case "ParenthesizedExpression":
                  return false;
                case "ClassDeclaration":
                case "ClassExpression": {
                  if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                    return true;
                  break;
                }
                case "ExportDefaultDeclaration":
                  return $(D, T) || o.type === "SequenceExpression";
                case "Decorator": {
                  if (C === "expression") {
                    if (f2(o) && o.computed)
                      return true;
                    let S = false, b = false, B = o;
                    for (; B; )
                      switch (B.type) {
                        case "MemberExpression":
                          b = true, B = B.object;
                          break;
                        case "CallExpression":
                          if (b || S)
                            return T.parser !== "typescript";
                          S = true, B = B.callee;
                          break;
                        case "Identifier":
                          return false;
                        case "TaggedTemplateExpression":
                          return T.parser !== "typescript";
                        default:
                          return true;
                      }
                    return true;
                  }
                  break;
                }
                case "ArrowFunctionExpression": {
                  if (C === "body" && o.type !== "SequenceExpression" && y(o, (S) => S.type === "ObjectExpression"))
                    return true;
                  break;
                }
              }
              switch (o.type) {
                case "UpdateExpression":
                  if (m.type === "UnaryExpression")
                    return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
                case "UnaryExpression":
                  switch (m.type) {
                    case "UnaryExpression":
                      return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "TaggedTemplateExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "BinaryExpression":
                      return C === "left" && m.operator === "**";
                    case "TSNonNullExpression":
                      return true;
                    default:
                      return false;
                  }
                case "BinaryExpression": {
                  if (m.type === "UpdateExpression" || o.operator === "in" && N(D))
                    return true;
                  if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                    let S = D.getParentNode(1);
                    if (S.type === "BinaryExpression" && S.operator === "|>")
                      return true;
                  }
                }
                case "TSTypeAssertion":
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "LogicalExpression":
                  switch (m.type) {
                    case "TSSatisfiesExpression":
                    case "TSAsExpression":
                      return !_(o);
                    case "ConditionalExpression":
                      return _(o);
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ClassExpression":
                    case "ClassDeclaration":
                      return C === "superClass";
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "AssignmentExpression":
                    case "AssignmentPattern":
                      return C === "left" && (o.type === "TSTypeAssertion" || _(o));
                    case "LogicalExpression":
                      if (o.type === "LogicalExpression")
                        return m.operator !== o.operator;
                    case "BinaryExpression": {
                      let { operator: S, type: b } = o;
                      if (!S && b !== "TSTypeAssertion")
                        return true;
                      let B = g(S), k = m.operator, M = g(k);
                      return M > B || C === "right" && M === B || M === B && !h(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p(k);
                    }
                    default:
                      return false;
                  }
                case "SequenceExpression":
                  switch (m.type) {
                    case "ReturnStatement":
                      return false;
                    case "ForStatement":
                      return false;
                    case "ExpressionStatement":
                      return C !== "expression";
                    case "ArrowFunctionExpression":
                      return C !== "body";
                    default:
                      return true;
                  }
                case "YieldExpression":
                  if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression")
                    return true;
                case "AwaitExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                      return true;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ConditionalExpression":
                      return C === "test";
                    case "BinaryExpression":
                      return !(!o.argument && m.operator === "|>");
                    default:
                      return false;
                  }
                case "TSConditionalType":
                case "TSFunctionType":
                case "TSConstructorType":
                  if (C === "extendsType" && m.type === "TSConditionalType") {
                    if (o.type === "TSConditionalType")
                      return true;
                    let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
                    if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint)
                      return true;
                  }
                  if (C === "checkType" && m.type === "TSConditionalType")
                    return true;
                case "TSUnionType":
                case "TSIntersectionType":
                  if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
                    return true;
                case "TSInferType":
                  if (o.type === "TSInferType" && m.type === "TSRestType")
                    return false;
                case "TSTypeOperator":
                  return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
                case "TSTypeQuery":
                  return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
                case "TypeofTypeAnnotation":
                  return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C === "elementType" && m.type === "ArrayTypeAnnotation";
                case "ArrayTypeAnnotation":
                  return m.type === "NullableTypeAnnotation";
                case "IntersectionTypeAnnotation":
                case "UnionTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "NullableTypeAnnotation":
                  return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
                case "FunctionTypeAnnotation": {
                  let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
                  return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a2(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
                }
                case "OptionalIndexedAccessType":
                  return C === "objectType" && m.type === "IndexedAccessType";
                case "StringLiteral":
                case "NumericLiteral":
                case "Literal":
                  if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                    let S = D.getParentNode(1);
                    return S.type === "Program" || S.type === "BlockStatement";
                  }
                  return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
                case "AssignmentExpression": {
                  let S = D.getParentNode(1);
                  return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
                }
                case "ConditionalExpression":
                  switch (m.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                      return true;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "ConditionalExpression":
                      return C === "test";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    default:
                      return false;
                  }
                case "FunctionExpression":
                  switch (m.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "TaggedTemplateExpression":
                      return true;
                    default:
                      return false;
                  }
                case "ArrowFunctionExpression":
                  switch (m.type) {
                    case "BinaryExpression":
                      return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression":
                      return C === "callee";
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                      return C === "object";
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSNonNullExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion":
                      return true;
                    case "ConditionalExpression":
                      return C === "test";
                    default:
                      return false;
                  }
                case "ClassExpression":
                  if (s(o.decorators))
                    return true;
                  switch (m.type) {
                    case "NewExpression":
                      return C === "callee";
                    default:
                      return false;
                  }
                case "OptionalMemberExpression":
                case "OptionalCallExpression": {
                  let S = D.getParentNode(1);
                  if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m)
                    return true;
                }
                case "CallExpression":
                case "MemberExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                  if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                    let S = o;
                    for (; S; )
                      switch (S.type) {
                        case "CallExpression":
                        case "OptionalCallExpression":
                          return true;
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                        case "BindExpression":
                          S = S.object;
                          break;
                        case "TaggedTemplateExpression":
                          S = S.tag;
                          break;
                        case "TSNonNullExpression":
                          S = S.expression;
                          break;
                        default:
                          return false;
                      }
                  }
                  return false;
                case "BindExpression":
                  return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f2(m);
                case "NGPipeExpression":
                  return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
                case "JSXFragment":
                case "JSXElement":
                  return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !F(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
                case "TypeAnnotation":
                  return C === "returnType" && m.type === "ArrowFunctionExpression" && x(o);
              }
              return false;
            }
            function E(D) {
              return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
            }
            function N(D) {
              let T = 0, m = D.getValue();
              for (; m; ) {
                let C = D.getParentNode(T++);
                if (C && C.type === "ForStatement" && C.init === m)
                  return true;
                m = C;
              }
              return false;
            }
            function x(D) {
              return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }
            function I(D) {
              switch (D.type) {
                case "ObjectExpression":
                  return true;
                default:
                  return false;
              }
            }
            function P(D) {
              let T = D.getValue(), m = D.getParentNode(), C = D.getName();
              switch (m.type) {
                case "NGPipeExpression":
                  if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C)
                    return D.callParent(P);
                  break;
                case "ObjectProperty":
                  if (C === "value") {
                    let o = D.getParentNode(1);
                    return t(o.properties) === m;
                  }
                  break;
                case "BinaryExpression":
                case "LogicalExpression":
                  if (C === "right")
                    return D.callParent(P);
                  break;
                case "ConditionalExpression":
                  if (C === "alternate")
                    return D.callParent(P);
                  break;
                case "UnaryExpression":
                  if (m.prefix)
                    return D.callParent(P);
                  break;
              }
              return false;
            }
            function $(D, T) {
              let m = D.getValue(), C = D.getParentNode();
              return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $(o, T), ...n(D, m));
            }
            r.exports = w;
          } }), Fo = te({ "src/language-js/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            function t(s, a2) {
              switch (a2.parser) {
                case "json":
                case "json5":
                case "json-stringify":
                case "__js_expression":
                case "__vue_expression":
                case "__vue_ts_expression":
                  return Object.assign(Object.assign({}, s), {}, { type: a2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a2.rootMarker });
                default:
                  return s;
              }
            }
            r.exports = t;
          } }), pd = te({ "src/language-js/print/html-binding.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, line: s, group: a2, softline: n, indent: u } } = qe();
            function i(p, y, h) {
              let g = p.getValue();
              if (y.__onHtmlBindingRoot && p.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
                if (y.__isVueForBindingLeft)
                  return p.call((c) => {
                    let f2 = t([",", s], c.map(h, "params")), { params: F } = c.getValue();
                    return F.length === 1 ? f2 : ["(", u([n, a2(f2)]), n, ")"];
                  }, "program", "body", 0);
                if (y.__isVueBindings)
                  return p.call((c) => t([",", s], c.map(h, "params")), "program", "body", 0);
              }
            }
            function l(p) {
              switch (p.type) {
                case "MemberExpression":
                  switch (p.property.type) {
                    case "Identifier":
                    case "NumericLiteral":
                    case "StringLiteral":
                      return l(p.object);
                  }
                  return false;
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
          } }), ru = te({ "src/language-js/print/binaryish.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t } = et(), { getLast: s } = Ue(), { builders: { join: a2, line: n, softline: u, group: i, indent: l, align: p, indentIfBreak: y }, utils: { cleanDoc: h, getDocParts: g, isConcat: c } } = qe(), { hasLeadingOwnLineComment: f2, isBinaryish: F, isJsxNode: _, shouldFlatten: w, hasComment: E, CommentCheckFlags: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $ } = Ke(), D = 0;
            function T(o, d, v) {
              let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $(d) && S.operator === "|>", R = m(o, v, d, false, k);
              if (k)
                return R;
              if (M)
                return i(R);
              if (x(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed)
                return i([l([u, ...R]), u]);
              let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x(B) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = F(S.left) && w(S.operator, S.left.operator);
              if (q || C(S) && !L || !C(S) && J)
                return i(R);
              if (R.length === 0)
                return "";
              let Q = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R.slice(0, V === -1 ? 1 : V + 1), Y = R.slice(j.length, Q ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
              if (!Q)
                return ee;
              let ce = s(R);
              return i([ee, y(ce, { groupId: ie })]);
            }
            function m(o, d, v, S, b) {
              let B = o.getValue();
              if (!F(B))
                return [i(d())];
              let k = [];
              w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, d, v, true, b), "left") : k.push(i(d("left")));
              let M = C(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f2(v.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a2([n, ": "], o.map(d, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
              if (M)
                L = [q, " ", d("right"), J];
              else {
                let ie = $(v) && q === "|>" ? o.call((ee) => m(ee, d, v, true, b), "right") : d("right");
                L = [R ? n : "", q, R ? " " : n, ie, J];
              }
              let Q = o.getParentNode(), V = E(B.left, N.Trailing | N.Line), j = V || !(b && B.type === "LogicalExpression") && Q.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
              if (k.push(R ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && E(B)) {
                let Y = h(t(o, k, v));
                return c(Y) || Y.type === "fill" ? g(Y) : [Y];
              }
              return k;
            }
            function C(o) {
              return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
            }
            r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
          } }), fd = te({ "src/language-js/print/angular.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, line: s, group: a2 } } = qe(), { hasNode: n, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = ru();
            function p(g, c, f2) {
              let F = g.getValue();
              if (F.type.startsWith("NG"))
                switch (F.type) {
                  case "NGRoot":
                    return [f2("node"), u(F.node) ? " //" + i(F.node)[0].value.trimEnd() : ""];
                  case "NGPipeExpression":
                    return l(g, c, f2);
                  case "NGChainedExpression":
                    return a2(t([";", s], g.map((_) => h(_) ? f2() : ["(", f2(), ")"], "expressions")));
                  case "NGEmptyExpression":
                    return "";
                  case "NGQuotedExpression":
                    return [F.prefix, ": ", F.value.trim()];
                  case "NGMicrosyntax":
                    return g.map((_, w) => [w === 0 ? "" : y(_.getValue(), w, F) ? " " : [";", s], f2()], "body");
                  case "NGMicrosyntaxKey":
                    return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(F.name) ? F.name : JSON.stringify(F.name);
                  case "NGMicrosyntaxExpression":
                    return [f2("expression"), F.alias === null ? "" : [" as ", f2("alias")]];
                  case "NGMicrosyntaxKeyedExpression": {
                    let _ = g.getName(), w = g.getParentNode(), E = y(F, _, w) || (_ === 1 && (F.key.name === "then" || F.key.name === "else") || _ === 2 && F.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
                    return [f2("key"), E ? " " : ": ", f2("expression")];
                  }
                  case "NGMicrosyntaxLet":
                    return ["let ", f2("key"), F.value === null ? "" : [" = ", f2("value")]];
                  case "NGMicrosyntaxAs":
                    return [f2("key"), " as ", f2("alias")];
                  default:
                    throw new Error(`Unknown Angular node type: ${JSON.stringify(F.type)}.`);
                }
            }
            function y(g, c, f2) {
              return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c === 1 && f2.body[0].type === "NGMicrosyntaxLet" && f2.body[0].value === null;
            }
            function h(g) {
              return n(g.getValue(), (c) => {
                switch (c.type) {
                  case void 0:
                    return false;
                  case "CallExpression":
                  case "OptionalCallExpression":
                  case "AssignmentExpression":
                    return true;
                }
              });
            }
            r.exports = { printAngular: p };
          } }), Dd = te({ "src/language-js/print/jsx.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t, printDanglingComments: s, printCommentsSeparately: a2 } = et(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, fill: h, ifBreak: g, lineSuffixBoundary: c, join: f2 }, utils: { willBreak: F } } = qe(), { getLast: _, getPreferredQuote: w } = Ue(), { isJsxNode: E, rawText: N, isCallExpression: x, isStringLiteral: I, isBinaryish: P, hasComment: $, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke(), m = qt(), { willPrintOwnComments: C } = Eo(), o = (U) => U === "" || U === n || U === u || U === i;
            function d(U, Z, se) {
              let fe = U.getValue();
              if (fe.type === "JSXElement" && de(fe))
                return [se("openingElement"), se("closingElement")];
              let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
              if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
                return [ge, ...U.map(se, "children"), he];
              fe.children = fe.children.map((A2) => Fe(A2) ? { type: "JSXText", value: " ", raw: " " } : A2);
              let we = fe.children.some(E), ke = fe.children.filter((A2) => A2.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = F(ge) || we || Re || ke, Pe = U.getParentNode().rootMarker === "mdx", oe = Z.singleQuote ? "{' '}" : '{" "}', H = Pe ? " " : g([oe, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U, Z, se, H, pe), le = fe.children.some((A2) => ue(A2));
              for (let A2 = X.length - 2; A2 >= 0; A2--) {
                let G = X[A2] === "" && X[A2 + 1] === "", re = X[A2] === u && X[A2 + 1] === "" && X[A2 + 2] === u, ye = (X[A2] === i || X[A2] === u) && X[A2 + 1] === "" && X[A2 + 2] === H, Ce = X[A2] === H && X[A2 + 1] === "" && (X[A2 + 2] === i || X[A2 + 2] === u), Be = X[A2] === H && X[A2 + 1] === "" && X[A2 + 2] === H, ve = X[A2] === i && X[A2 + 1] === "" && X[A2 + 2] === u || X[A2] === u && X[A2 + 1] === "" && X[A2 + 2] === i;
                re && le || G || ye || Be || ve ? X.splice(A2, 2) : Ce && X.splice(A2 + 1, 2);
              }
              for (; X.length > 0 && o(_(X)); )
                X.pop();
              for (; X.length > 1 && o(X[0]) && o(X[1]); )
                X.shift(), X.shift();
              let Ae = [];
              for (let [A2, G] of X.entries()) {
                if (G === H) {
                  if (A2 === 1 && X[A2 - 1] === "") {
                    if (X.length === 2) {
                      Ae.push(oe);
                      continue;
                    }
                    Ae.push([oe, u]);
                    continue;
                  } else if (A2 === X.length - 1) {
                    Ae.push(oe);
                    continue;
                  } else if (X[A2 - 1] === "" && X[A2 - 2] === u) {
                    Ae.push(oe);
                    continue;
                  }
                }
                Ae.push(G), F(G) && (Ne = true);
              }
              let Ee = le ? h(Ae) : l(Ae, { shouldBreak: true });
              if (Pe)
                return Ee;
              let De = l([ge, p([u, Ee]), u, he]);
              return Ne ? De : y([l([ge, ...X, he]), De]);
            }
            function v(U, Z, se, fe, ge) {
              let he = [];
              return U.each((we, ke, Re) => {
                let Ne = we.getValue();
                if (Ne.type === "JSXText") {
                  let Pe = N(Ne);
                  if (ue(Ne)) {
                    let oe = Pe.split(ce);
                    if (oe[0] === "") {
                      if (he.push(""), oe.shift(), /\n/.test(oe[0])) {
                        let pe = Re[ke + 1];
                        he.push(b(ge, oe[1], Ne, pe));
                      } else
                        he.push(fe);
                      oe.shift();
                    }
                    let H;
                    if (_(oe) === "" && (oe.pop(), H = oe.pop()), oe.length === 0)
                      return;
                    for (let [pe, X] of oe.entries())
                      pe % 2 === 1 ? he.push(n) : he.push(X);
                    if (H !== void 0)
                      if (/\n/.test(H)) {
                        let pe = Re[ke + 1];
                        he.push(b(ge, _(he), Ne, pe));
                      } else
                        he.push(fe);
                    else {
                      let pe = Re[ke + 1];
                      he.push(S(ge, _(he), Ne, pe));
                    }
                  } else
                    /\n/.test(Pe) ? Pe.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
                } else {
                  let Pe = se();
                  he.push(Pe);
                  let oe = Re[ke + 1];
                  if (oe && ue(oe)) {
                    let pe = K(N(oe)).split(ce)[0];
                    he.push(S(ge, pe, Ne, oe));
                  } else
                    he.push(u);
                }
              }, "children"), he;
            }
            function S(U, Z, se, fe) {
              return U ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
            }
            function b(U, Z, se, fe) {
              return U ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
            }
            function B(U, Z, se) {
              let fe = U.getParentNode();
              if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
                return Z;
              let he = U.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x, (ke) => ke.type === "JSXExpressionContainer"), we = m(U, se);
              return l([we ? "" : g("("), p([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
            }
            function k(U, Z, se) {
              let fe = U.getValue(), ge = [];
              if (ge.push(se("name")), fe.value) {
                let he;
                if (I(fe.value)) {
                  let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe } = w(ke, Z.jsxSingleQuote ? "'" : '"');
                  ke = ke.replace(Pe, Re);
                  let { leading: oe, trailing: H } = U.call(() => a2(U, Z), "value");
                  he = [oe, Ne, ke, Ne, H];
                } else
                  he = se("value");
                ge.push("=", he);
              }
              return ge;
            }
            function M(U, Z, se) {
              let fe = U.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || E(we) && (he.type === "ConditionalExpression" || P(he)));
              return ge(fe.expression, U.getParentNode(0)) ? l(["{", se("expression"), c, "}"]) : l(["{", p([i, se("expression")]), i, c, "}"]);
            }
            function R(U, Z, se) {
              let fe = U.getValue(), ge = fe.name && $(fe.name) || fe.typeParameters && $(fe.typeParameters);
              if (fe.selfClosing && fe.attributes.length === 0 && !ge)
                return ["<", se("name"), se("typeParameters"), " />"];
              if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$(fe.attributes[0]))
                return l(["<", se("name"), se("typeParameters"), " ", ...U.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
              let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;
              return l(["<", se("name"), se("typeParameters"), p(U.map(() => [we, se()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: he });
            }
            function q(U, Z, se) {
              return U.selfClosing ? [n, "/>"] : J(U, Z, se) ? [">"] : [i, ">"];
            }
            function J(U, Z, se) {
              let fe = U.attributes.length > 0 && $(_(U.attributes), D.Trailing);
              return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;
            }
            function L(U, Z, se) {
              let fe = U.getValue(), ge = [];
              ge.push("</");
              let he = se("name");
              return $(fe.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
            }
            function Q(U, Z) {
              let se = U.getValue(), fe = $(se), ge = $(se, D.Line), he = se.type === "JSXOpeningFragment";
              return [he ? "<" : "</", p([ge ? u : fe && !he ? " " : "", s(U, Z, true)]), ge ? u : "", ">"];
            }
            function V(U, Z, se) {
              let fe = t(U, d(U, Z, se), Z);
              return B(U, fe, Z);
            }
            function j(U, Z) {
              let se = U.getValue(), fe = $(se, D.Line);
              return [s(U, Z, !fe), fe ? u : ""];
            }
            function Y(U, Z, se) {
              let fe = U.getValue();
              return ["{", U.call((ge) => {
                let he = ["...", se()], we = ge.getValue();
                return !$(we) || !C(ge) ? he : [p([i, t(ge, he, Z)]), i];
              }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
            }
            function ie(U, Z, se) {
              let fe = U.getValue();
              if (fe.type.startsWith("JSX"))
                switch (fe.type) {
                  case "JSXAttribute":
                    return k(U, Z, se);
                  case "JSXIdentifier":
                    return String(fe.name);
                  case "JSXNamespacedName":
                    return f2(":", [se("namespace"), se("name")]);
                  case "JSXMemberExpression":
                    return f2(".", [se("object"), se("property")]);
                  case "JSXSpreadAttribute":
                    return Y(U, Z, se);
                  case "JSXSpreadChild":
                    return Y(U, Z, se);
                  case "JSXExpressionContainer":
                    return M(U, Z, se);
                  case "JSXFragment":
                  case "JSXElement":
                    return V(U, Z, se);
                  case "JSXOpeningElement":
                    return R(U, Z, se);
                  case "JSXClosingElement":
                    return L(U, Z, se);
                  case "JSXOpeningFragment":
                  case "JSXClosingFragment":
                    return Q(U, Z);
                  case "JSXEmptyExpression":
                    return j(U, Z);
                  case "JSXText":
                    throw new Error("JSXText should be handled by JSXElement");
                  default:
                    throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
                }
            }
            var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U) => U.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
            function de(U) {
              if (U.children.length === 0)
                return true;
              if (U.children.length > 1)
                return false;
              let Z = U.children[0];
              return Z.type === "JSXText" && !ue(Z);
            }
            function ue(U) {
              return U.type === "JSXText" && (W.test(N(U)) || !/\n/.test(N(U)));
            }
            function Fe(U) {
              return U.type === "JSXExpressionContainer" && I(U.expression) && U.expression.value === " " && !$(U.expression);
            }
            function z(U) {
              let Z = U.getValue(), se = U.getParentNode();
              if (!se || !Z || !E(Z) || !E(se))
                return false;
              let fe = se.children.indexOf(Z), ge = null;
              for (let he = fe; he > 0; he--) {
                let we = se.children[he - 1];
                if (!(we.type === "JSXText" && !ue(we))) {
                  ge = we;
                  break;
                }
              }
              return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
            }
            r.exports = { hasJsxIgnoreComment: z, printJsx: ie };
          } }), ct = te({ "src/language-js/print/misc.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, join: a2, line: n } } = qe(), { isFlowAnnotationComment: u } = Ke();
            function i(_) {
              let w = _.getValue();
              return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
            }
            function l(_) {
              return _.getValue().definite || _.match(void 0, (w, E) => E === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
            }
            function p(_, w, E) {
              let N = _.getValue();
              return N.typeArguments ? E("typeArguments") : N.typeParameters ? E("typeParameters") : "";
            }
            function y(_, w, E) {
              let N = _.getValue();
              if (!N.typeAnnotation)
                return "";
              let x = _.getParentNode(), I = x.type === "DeclareFunction" && x.id === N;
              return u(w.originalText, N.typeAnnotation) ? [" /*: ", E("typeAnnotation"), " */"] : [I ? "" : ": ", E("typeAnnotation")];
            }
            function h(_, w, E) {
              return ["::", E("callee")];
            }
            function g(_, w, E) {
              let N = _.getValue();
              return t(N.modifiers) ? [a2(" ", _.map(E, "modifiers")), " "] : "";
            }
            function c(_, w, E) {
              return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || E ? [" ", w] : s([n, w]);
            }
            function f2(_, w, E) {
              return ["...", E("argument"), y(_, w, E)];
            }
            function F(_, w) {
              let E = _.slice(1, -1);
              if (E.includes('"') || E.includes("'"))
                return _;
              let N = w.singleQuote ? "'" : '"';
              return N + E + N;
            }
            r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: h, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: f2, adjustClause: c, printDirective: F };
          } }), er = te({ "src/language-js/print/array.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a2, hardline: n, group: u, indent: i, ifBreak: l, fill: p } } = qe(), { getLast: y, hasNewline: h } = Ue(), { shouldPrintComma: g, hasComment: c, CommentCheckFlags: f2, isNextLineEmpty: F, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke(), { locStart: E } = ut(), { printOptionalToken: N, printTypeAnnotation: x } = ct();
            function I(T, m, C) {
              let o = T.getValue(), d = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
              if (o.elements.length === 0)
                c(o, f2.Dangling) ? d.push(u([v, t(T, m), a2, S])) : d.push(v, S);
              else {
                let b = y(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q, V) => {
                  let j = L && L.type;
                  if (j !== "ArrayExpression" && j !== "ObjectExpression")
                    return false;
                  let Y = V[Q + 1];
                  if (Y && j !== Y.type)
                    return false;
                  let ie = j === "ArrayExpression" ? "elements" : "properties";
                  return L[ie] && L[ie].length > 1;
                }), q = P(o, m), J = B ? k ? "," : g(m) ? q ? l(",", "", { groupId: M }) : l(",") : "" : "";
                d.push(u([v, i([a2, q ? D(T, m, C, J) : [$(T, m, "elements", C), J], t(T, m, true)]), a2, S], { shouldBreak: R, id: M }));
              }
              return d.push(N(T), x(T, m, C)), d;
            }
            function P(T, m) {
              return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f2.Trailing | f2.Line, (o) => !h(m.originalText, E(o), { backwards: true })));
            }
            function $(T, m, C, o) {
              let d = [], v = [];
              return T.each((S) => {
                d.push(v, u(o())), v = [",", s], S.getValue() && F(S.getValue(), m) && v.push(a2);
              }, C), d;
            }
            function D(T, m, C, o) {
              let d = [];
              return T.each((v, S, b) => {
                let B = S === b.length - 1;
                d.push([C(), B ? o : ","]), B || d.push(F(v.getValue(), m) ? [n, n] : c(b[S + 1], f2.Leading | f2.Line) ? n : s);
              }, "elements"), p(d);
            }
            r.exports = { printArray: I, printArrayItems: $, isConciselyPrintedArray: P };
          } }), Ao = te({ "src/language-js/print/call-arguments.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a2 } = Ue(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: y, shouldPrintComma: h, getCallArguments: g, iterateCallArgumentsPath: c, isNextLineEmpty: f2, isCallExpression: F, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: E } = Ke(), { builders: { line: N, hardline: x, softline: I, group: P, indent: $, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Qt(), { isConciselyPrintedArray: d } = er();
            function v(q, J, L) {
              let Q = q.getValue(), V = Q.type === "ImportExpression", j = g(Q);
              if (j.length === 0)
                return ["(", t(q, J, true), ")"];
              if (k(j))
                return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
              let Y = false, ie = false, ee = j.length - 1, ce = [];
              c(q, (z, U) => {
                let Z = z.getNode(), se = [L()];
                U === ee || (f2(Z, J) ? (U === 0 && (ie = true), Y = true, se.push(",", x, x)) : se.push(",", N)), ce.push(se);
              });
              let W = !(V || Q.callee && Q.callee.type === "Import") && h(J, "all") ? "," : "";
              function K() {
                return P(["(", $([N, ...ce]), W, N, ")"], { shouldBreak: true });
              }
              if (Y || q.getParentNode().type !== "Decorator" && l(j))
                return K();
              let de = B(j), ue = b(j, J);
              if (de || ue) {
                if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C))
                  return K();
                let z = [];
                try {
                  q.try(() => {
                    c(q, (U, Z) => {
                      de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x : N, ie ? x : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
                    });
                  });
                } catch (U) {
                  if (U instanceof o)
                    return K();
                  throw U;
                }
                return [ce.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K()])];
              }
              let Fe = ["(", $([I, ...ce]), T(W), I, ")"];
              return y(q) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
            }
            function S(q) {
              let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || E(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (F(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
            }
            function b(q, J) {
              let L = s(q), Q = a2(q);
              return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q || Q.type !== L.type) && (q.length !== 2 || Q.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d(L, J));
            }
            function B(q) {
              if (q.length !== 2)
                return false;
              let [J, L] = q;
              return J.type === "ModuleExpression" && R(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
            }
            function k(q) {
              return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
            }
            function M(q) {
              return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
            }
            function R(q) {
              return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
            }
            r.exports = v;
          } }), So = te({ "src/language-js/print/member.js"(e, r) {
            "use strict";
            ne();
            var { builders: { softline: t, group: s, indent: a2, label: n } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: p } = ct();
            function y(g, c, f2) {
              let F = g.getValue(), _ = g.getParentNode(), w, E = 0;
              do
                w = g.getParentNode(E), E++;
              while (w && (i(w) || w.type === "TSNonNullExpression"));
              let N = f2("object"), x = h(g, c, f2), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || F.computed || F.object.type === "Identifier" && F.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(F.object) && F.object.arguments.length > 0 || F.object.type === "TSNonNullExpression" && l(F.object.expression) && F.object.expression.arguments.length > 0 || N.label === "member-chain");
              return n(N.label === "member-chain" ? "member-chain" : "member", [N, I ? x : s(a2([t, x]))]);
            }
            function h(g, c, f2) {
              let F = f2("property"), _ = g.getValue(), w = p(g);
              return _.computed ? !_.property || u(_.property) ? [w, "[", F, "]"] : s([w, "[", a2([t, F]), t, "]"]) : [w, ".", F];
            }
            r.exports = { printMemberExpression: y, printMemberLookup: h };
          } }), md = te({ "src/language-js/print/member-chain.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a2, getNextNonSpaceNonCommentCharacterIndex: n } = Ue(), u = qt(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: y, isMemberish: h, isNumericLiteral: g, isSimpleCallArgument: c, hasComment: f2, CommentCheckFlags: F, isNextLineEmpty: _ } = Ke(), { locEnd: w } = ut(), { builders: { join: E, hardline: N, group: x, indent: I, conditionalGroup: P, breakParent: $, label: D }, utils: { willBreak: T } } = qe(), m = Ao(), { printMemberLookup: C } = So(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: v } = ct();
            function S(b, B, k) {
              let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q = [];
              function J(Ne) {
                let { originalText: Pe } = B, oe = n(Pe, Ne, w);
                return Pe.charAt(oe) === ")" ? oe !== false && a2(Pe, oe + 1) : _(Ne, B);
              }
              function L(Ne) {
                let Pe = Ne.getValue();
                i(Pe) && (h(Pe.callee) || i(Pe.callee)) ? (q.unshift({ node: Pe, printed: [t(Ne, [o(Ne), d(Ne, B, k), m(Ne, B, k)], B), J(Pe) ? N : ""] }), Ne.call((oe) => L(oe), "callee")) : h(Pe) ? (q.unshift({ node: Pe, needsParens: u(Ne, B), printed: t(Ne, l(Pe) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe) => L(oe), "object")) : Pe.type === "TSNonNullExpression" ? (q.unshift({ node: Pe, printed: t(Ne, "!", B) }), Ne.call((oe) => L(oe), "expression")) : q.unshift({ node: Pe, printed: k() });
              }
              let Q = b.getValue();
              q.unshift({ node: Q, printed: [o(b), d(b, B, k), m(b, B, k)] }), Q.callee && b.call((Ne) => L(Ne), "callee");
              let V = [], j = [q[0]], Y = 1;
              for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g(q[Y].node.property)); ++Y)
                j.push(q[Y]);
              if (!i(q[0].node))
                for (; Y + 1 < q.length && (h(q[Y].node) && h(q[Y + 1].node)); ++Y)
                  j.push(q[Y]);
              V.push(j), j = [];
              let ie = false;
              for (; Y < q.length; ++Y) {
                if (ie && h(q[Y].node)) {
                  if (q[Y].node.computed && g(q[Y].node.property)) {
                    j.push(q[Y]);
                    continue;
                  }
                  V.push(j), j = [], ie = false;
                }
                (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie = true), j.push(q[Y]), f2(q[Y].node, F.Trailing) && (V.push(j), j = [], ie = false);
              }
              j.length > 0 && V.push(j);
              function ee(Ne) {
                return /^[A-Z]|^[$_]+$/.test(Ne);
              }
              function ce(Ne) {
                return Ne.length <= B.tabWidth;
              }
              function W(Ne) {
                let Pe = Ne[1].length > 0 && Ne[1][0].node.computed;
                if (Ne[0].length === 1) {
                  let H = Ne[0][0].node;
                  return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R && ce(H.name) || Pe);
                }
                let oe = s(Ne[0]).node;
                return l(oe) && oe.property.type === "Identifier" && (ee(oe.property.name) || Pe);
              }
              let K = V.length >= 2 && !f2(V[1][0].node) && W(V);
              function de(Ne) {
                let Pe = Ne.map((oe) => oe.printed);
                return Ne.length > 0 && s(Ne).needsParens ? ["(", ...Pe, ")"] : Pe;
              }
              function ue(Ne) {
                return Ne.length === 0 ? "" : I(x([N, E(N, Ne.map(de))]));
              }
              let Fe = V.map(de), z = Fe, U = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f2(Ne.node, F.Leading)) || Z.slice(0, -1).some((Ne) => f2(Ne.node, F.Trailing)) || V[U] && f2(V[U][0].node, F.Leading);
              if (V.length <= U && !se)
                return y(b) ? z : x(z);
              let fe = s(V[K ? 1 : 0]).node, ge = !i(fe) && J(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N : "", ue(V.slice(K ? 2 : 1))], we = q.map((Ne) => {
                let { node: Pe } = Ne;
                return Pe;
              }).filter(i);
              function ke() {
                let Ne = s(s(V)).node, Pe = s(Fe);
                return i(Ne) && T(Pe) && we.slice(0, -1).some((oe) => oe.arguments.some(p));
              }
              let Re;
              return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe) => c(Pe, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x(he) : Re = [T(z) || ge ? $ : "", P([z, he])], D("member-chain", Re);
            }
            r.exports = S;
          } }), xo = te({ "src/language-js/print/call-expression.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, group: s } } = qe(), a2 = qt(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: y, isTestCall: h, iterateCallArgumentsPath: g } = Ke(), c = md(), f2 = Ao(), { printOptionalToken: F, printFunctionTypeParameters: _ } = ct();
            function w(N, x, I) {
              let P = N.getValue(), $ = N.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = F(N), C = n(P);
              if (C.length > 0 && (!T && !D && E(P, $) || C.length === 1 && y(C[0], x.originalText) || !D && h(P, $))) {
                let v = [];
                return g(N, () => {
                  v.push(I());
                }), [D ? "new " : "", I("callee"), m, _(N, x, I), "(", t(", ", v), ")"];
              }
              let o = (x.parser === "babel" || x.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
              if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N.call((v) => a2(v, x), "callee"))
                return c(N, x, I);
              let d = [D ? "new " : "", T ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N, x, I), f2(N, x, I)];
              return T || i(P.callee) ? s(d) : d;
            }
            function E(N, x) {
              if (N.callee.type !== "Identifier")
                return false;
              if (N.callee.name === "require")
                return true;
              if (N.callee.name === "define") {
                let I = n(N);
                return x.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p(I[0]) && I[1].type === "ArrayExpression");
              }
              return false;
            }
            r.exports = { printCallExpression: w };
          } }), tr = te({ "src/language-js/print/assignment.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t, getStringWidth: s } = Ue(), { builders: { line: a2, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: y, canBreak: h } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: c, isStringLiteral: f2, isLiteral: F, isNumericLiteral: _, isCallExpression: w, isMemberExpression: E, getCallArguments: N, rawText: x, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $ } = Ke(), { shouldInlineLogicalExpression: D } = ru(), { printCallExpression: T } = xo();
            function m(W, K, de, ue, Fe, z) {
              let U = d(W, K, de, ue, z), Z = de(z, { assignmentLayout: U });
              switch (U) {
                case "break-after-operator":
                  return n([n(ue), Fe, n(u([a2, Z]))]);
                case "never-break-after-operator":
                  return n([n(ue), Fe, " ", Z]);
                case "fluid": {
                  let se = Symbol("assignment");
                  return n([n(ue), Fe, n(u(a2), { id: se }), l, i(Z, { groupId: se })]);
                }
                case "break-lhs":
                  return n([ue, Fe, " ", n(Z)]);
                case "chain":
                  return [n(ue), Fe, a2, Z];
                case "chain-tail":
                  return [n(ue), Fe, u([a2, Z])];
                case "chain-tail-arrow-chain":
                  return [n(ue), Fe, Z];
                case "only-left":
                  return ue;
              }
            }
            function C(W, K, de) {
              let ue = W.getValue();
              return m(W, K, de, de("left"), [" ", ue.operator], "right");
            }
            function o(W, K, de) {
              return m(W, K, de, de("id"), " =", "init");
            }
            function d(W, K, de, ue, Fe) {
              let z = W.getValue(), U = z[Fe];
              if (!U)
                return "only-left";
              let Z = !b(U);
              if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration"))
                return Z ? U.type === "ArrowFunctionExpression" && U.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
              if (!Z && b(U.right) || g(K.originalText, U))
                return "break-after-operator";
              if (U.type === "CallExpression" && U.callee.name === "require" || K.parser === "json5" || K.parser === "json")
                return "never-break-after-operator";
              if (S(z) || k(z) || q(z) || J(z) && h(ue))
                return "break-lhs";
              let ge = ie(z, ue, K);
              return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U.type === "TemplateLiteral" || U.type === "TaggedTemplateExpression" || U.type === "BooleanLiteral" || _(U) || U.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
            }
            function v(W, K, de, ue) {
              let Fe = W.getValue();
              if (c(Fe) && !D(Fe))
                return true;
              switch (Fe.type) {
                case "StringLiteralTypeAnnotation":
                case "SequenceExpression":
                  return true;
                case "ConditionalExpression": {
                  let { test: Z } = Fe;
                  return c(Z) && !D(Z);
                }
                case "ClassExpression":
                  return t(Fe.decorators);
              }
              if (ue)
                return false;
              let z = Fe, U = [];
              for (; ; )
                if (z.type === "UnaryExpression")
                  z = z.argument, U.push("argument");
                else if (z.type === "TSNonNullExpression")
                  z = z.expression, U.push("expression");
                else
                  break;
              return !!(f2(z) || W.call(() => V(W, K, de), ...U));
            }
            function S(W) {
              if (B(W)) {
                let K = W.left || W.id;
                return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
              }
              return false;
            }
            function b(W) {
              return W.type === "AssignmentExpression";
            }
            function B(W) {
              return b(W) || W.type === "VariableDeclarator";
            }
            function k(W) {
              let K = M(W);
              if (t(K)) {
                let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
                if (K.length > 1 && K.some((ue) => ue[de] || ue.default))
                  return true;
              }
              return false;
            }
            function M(W) {
              return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function R(W) {
              return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
            }
            function q(W) {
              if (W.type !== "VariableDeclarator")
                return false;
              let { typeAnnotation: K } = W.id;
              if (!K || !K.typeAnnotation)
                return false;
              let de = L(K.typeAnnotation);
              return t(de) && de.length > 1 && de.some((ue) => t(L(ue)) || ue.type === "TSConditionalType");
            }
            function J(W) {
              return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
            }
            function L(W) {
              return Q(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
            }
            function Q(W) {
              return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
            }
            function V(W, K, de) {
              let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
              if (Fe.type === "TSNonNullExpression")
                return W.call(z, "expression");
              if (w(Fe)) {
                if (T(W, K, de).label === "member-chain")
                  return false;
                let Z = N(Fe);
                return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
              }
              return E(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
            }
            var j = 0.25;
            function Y(W, K) {
              let { printWidth: de } = K;
              if (I(W))
                return false;
              let ue = de * j;
              if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument))
                return true;
              let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
              return Fe ? Fe.length <= ue : f2(W) ? x(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : F(W);
            }
            function ie(W, K, de) {
              if (!$(W))
                return false;
              K = p(K);
              let ue = 3;
              return typeof K == "string" && s(K) < de.tabWidth + ue;
            }
            function ee(W, K) {
              let de = ce(W);
              if (t(de)) {
                if (de.length > 1)
                  return true;
                if (de.length === 1) {
                  let Fe = de[0];
                  if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation")
                    return true;
                }
                let ue = W.typeParameters ? "typeParameters" : "typeArguments";
                if (y(K(ue)))
                  return true;
              }
              return false;
            }
            function ce(W) {
              return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
            }
            r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J };
          } }), Lr = te({ "src/language-js/print/function-parameters.js"(e, r) {
            "use strict";
            ne();
            var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a2, hardline: n, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: y, willBreak: h } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: c, isSimpleType: f2, isTestCall: F, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: E, hasRestParameter: N, shouldPrintComma: x, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $ } = ut(), { ArgExpansionBailout: D } = Qt(), { printFunctionTypeParameters: T } = ct();
            function m(v, S, b, B, k) {
              let M = v.getValue(), R = g(M), q = k ? T(v, b, S) : "";
              if (R.length === 0)
                return [q, "(", s(v, b, true, (ie) => t(b.originalText, ie, $) === ")"), ")"];
              let J = v.getParentNode(), L = F(J), Q = C(M), V = [];
              if (c(v, (ie, ee) => {
                let ce = ee === R.length - 1;
                ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q ? V.push(" ") : P(R[ee], b) ? V.push(n, n) : V.push(a2));
              }), B) {
                if (h(q) || h(V))
                  throw new D();
                return i([y(q), "(", y(V), ")"]);
              }
              let j = R.every((ie) => !ie.decorators);
              return Q && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (E(J) || _(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f2(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N(M) && x(b, "all") ? "," : ""), u, ")"];
            }
            function C(v) {
              if (!v)
                return false;
              let S = g(v);
              if (S.length !== 1)
                return false;
              let [b] = S;
              return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
            }
            function o(v) {
              let S;
              return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
            }
            function d(v, S) {
              let b = o(v);
              if (!b)
                return false;
              let B = v.typeParameters && v.typeParameters.params;
              if (B) {
                if (B.length > 1)
                  return false;
                if (B.length === 1) {
                  let k = B[0];
                  if (k.constraint || k.default)
                    return false;
                }
              }
              return g(v).length === 1 && (w(b) || h(S));
            }
            r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: d };
          } }), Or = te({ "src/language-js/print/type-annotation.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a2 } = Ue(), { builders: { group: n, join: u, line: i, softline: l, indent: p, align: y, ifBreak: h } } = qe(), g = qt(), { locStart: c } = ut(), { isSimpleType: f2, isObjectType: F, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: E } = Ke(), { printAssignment: N } = tr(), { printFunctionParameters: x, shouldGroupFunctionParameters: I } = Lr(), { printArrayItems: P } = er();
            function $(b) {
              if (f2(b) || F(b))
                return true;
              if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
                let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
                if (b.types.length - 1 === B && k)
                  return true;
              }
              return false;
            }
            function D(b, B, k) {
              let M = B.semi ? ";" : "", R = b.getValue(), q = [];
              return q.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q.push(": ", k("supertype")), R.impltype && q.push(" = ", k("impltype")), q.push(M), q;
            }
            function T(b, B, k) {
              let M = B.semi ? ";" : "", R = b.getValue(), q = [];
              R.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
              let J = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
              return [N(b, B, k, q, " =", J), M];
            }
            function m(b, B, k) {
              let M = b.getValue(), R = b.map(k, "types"), q = [], J = false;
              for (let L = 0; L < R.length; ++L)
                L === 0 ? q.push(R[L]) : F(M.types[L - 1]) && F(M.types[L]) ? q.push([" & ", J ? p(R[L]) : R[L]]) : !F(M.types[L - 1]) && !F(M.types[L]) ? q.push(p([" &", i, R[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? p(R[L]) : R[L]));
              return n(q);
            }
            function C(b, B, k) {
              let M = b.getValue(), R = b.getParentNode(), q = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J = $(M), L = b.map((j) => {
                let Y = k();
                return J || (Y = y(2, Y)), t(j, Y, B);
              }, "types");
              if (J)
                return u(" | ", L);
              let Q = q && !_(B.originalText, M), V = [h([Q ? i : "", "| "]), u([i, "| "], L)];
              return g(b, B) ? n([p(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n([p([h(["(", l]), V]), l, h(")")]) : n(q ? p(V) : V);
            }
            function o(b, B, k) {
              let M = b.getValue(), R = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Q = M.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c(q) === c(M) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
              w(q) && (Q = true, V = true), j && R.push("(");
              let Y = x(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
              return R.push(ee ? n(Y) : Y), ie && R.push(ie), j && R.push(")"), n(R);
            }
            function d(b, B, k) {
              let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q = M[R], J = a2(q), L = J ? l : "";
              return n(["[", p([L, P(b, B, R, k)]), h(J && E(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
            }
            function v(b, B, k) {
              let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
              return [k("objectType"), R, k("indexType"), "]"];
            }
            function S(b, B, k) {
              let M = b.getValue();
              return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
            }
            r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: d, printIndexedAccessType: v, shouldHugType: $, printJSDocType: S };
          } }), jr = te({ "src/language-js/print/type-parameters.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { builders: { join: s, line: a2, hardline: n, softline: u, group: i, indent: l, ifBreak: p } } = qe(), { isTestCall: y, hasComment: h, CommentCheckFlags: g, isTSXFile: c, shouldPrintComma: f2, getFunctionParameters: F, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke(), { createGroupIdMapper: E } = Ue(), { shouldHugType: N } = Or(), { isArrowFunctionVariableDeclarator: x } = tr(), I = E("typeParameters");
            function P(T, m, C, o) {
              let d = T.getValue();
              if (!d[o])
                return "";
              if (!Array.isArray(d[o]))
                return C(o);
              let v = T.getNode(2), S = v && y(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x);
              if (d[o].length === 0 || !b && (S || d[o].length === 1 && (d[o][0].type === "NullableTypeAnnotation" || N(d[o][0]))))
                return ["<", s(", ", T.map(C, o)), $(T, m), ">"];
              let k = d.type === "TSTypeParameterInstantiation" ? "" : F(d).length === 1 && c(m) && !d[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f2(m, "all") ? p(",") : "";
              return i(["<", l([u, s([",", a2], T.map(C, o))]), k, u, ">"], { id: I(d) });
            }
            function $(T, m) {
              let C = T.getValue();
              if (!h(C, g.Dangling))
                return "";
              let o = !h(C, g.Line), d = t(T, m, o);
              return o ? d : [d, n];
            }
            function D(T, m, C) {
              let o = T.getValue(), d = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v = T.getParentNode();
              return v.type === "TSMappedType" ? (v.readonly && d.push(w(v.readonly, "readonly"), " "), d.push("[", C("name")), o.constraint && d.push(" in ", C("constraint")), v.nameType && d.push(" as ", T.callParent(() => C("nameType"))), d.push("]"), d) : (o.variance && d.push(C("variance")), o.in && d.push("in "), o.out && d.push("out "), d.push(C("name")), o.bound && d.push(": ", C("bound")), o.constraint && d.push(" extends ", C("constraint")), o.default && d.push(" = ", C("default")), d);
            }
            r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
          } }), rr = te({ "src/language-js/print/property.js"(e, r) {
            "use strict";
            ne();
            var { printComments: t } = et(), { printString: s, printNumber: a2 } = Ue(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke(), { printAssignment: y } = tr(), h = /* @__PURE__ */ new WeakMap();
            function g(f2, F, _) {
              let w = f2.getNode();
              if (w.computed)
                return ["[", _("key"), "]"];
              let E = f2.getParentNode(), { key: N } = w;
              if (F.quoteProps === "consistent" && !h.has(E)) {
                let x = (E.properties || E.body || E.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, F));
                h.set(E, x);
              }
              if ((N.type === "Identifier" || n(N) && u(a2(p(N))) && String(N.value) === a2(p(N)) && !(F.parser === "typescript" || F.parser === "babel-ts")) && (F.parser === "json" || F.quoteProps === "consistent" && h.get(E))) {
                let x = s(JSON.stringify(N.type === "Identifier" ? N.name : N.value.toString()), F);
                return f2.call((I) => t(I, x, F), "key");
              }
              return l(w, F) && (F.quoteProps === "as-needed" || F.quoteProps === "consistent" && !h.get(E)) ? f2.call((x) => t(x, /^\d/.test(N.value) ? a2(N.value) : N.value, F), "key") : _("key");
            }
            function c(f2, F, _) {
              return f2.getValue().shorthand ? _("value") : y(f2, F, _, g(f2, F, _), ":", "value");
            }
            r.exports = { printProperty: c, printPropertyKey: g };
          } }), qr = te({ "src/language-js/print/function.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { printDanglingComments: s, printCommentsSeparately: a2 } = et(), n = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: l, group: p, indent: y, ifBreak: h, hardline: g, join: c, indentIfBreak: f2 }, utils: { removeLines: F, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Qt(), { getFunctionParameters: E, hasLeadingOwnLineComment: N, isFlowAnnotationComment: x, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: d, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke(), { locEnd: M } = ut(), { printFunctionParameters: R, shouldGroupFunctionParameters: q } = Lr(), { printPropertyKey: J } = rr(), { printFunctionTypeParameters: L } = ct();
            function Q(U, Z, se, fe) {
              let ge = U.getValue(), he = false;
              if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
                let Pe = U.getParentNode();
                S(Pe) && b(Pe).length > 1 && (he = true);
              }
              let we = [];
              ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
              let ke = R(U, Z, se, he), Re = K(U, Z, se), Ne = q(ge, Re);
              return we.push(L(U, se, Z), p([Ne ? p(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
            }
            function V(U, Z, se) {
              let fe = U.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
              return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J(U, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U, Z, se)) : he.type === "FunctionExpression" ? we.push(U.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
            }
            function j(U, Z, se) {
              let fe = U.getNode(), ge = R(U, se, Z), he = K(U, se, Z), we = q(fe, he), ke = [L(U, Z, se), p([we ? p(ge) : ge, he])];
              return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
            }
            function Y(U, Z, se, fe) {
              let ge = U.getValue(), he = [];
              if (ge.async && he.push("async "), W(U, Z))
                he.push(se(["params", 0]));
              else {
                let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U, se, Z);
                if (ke) {
                  if (_(Re))
                    throw new w();
                  Re = p(F(Re));
                }
                he.push(p([R(U, se, Z, ke, true), Re]));
              }
              let we = s(U, Z, true, (ke) => {
                let Re = u(Z.originalText, ke, M);
                return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
              });
              return we && he.push(" ", we), he;
            }
            function ie(U, Z, se, fe, ge, he) {
              let we = U.getName(), ke = U.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe = Re && Pe || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
              return he.body.type === "SequenceExpression" && (ge = p(["(", y([l, ge]), l, ")"])), p([p(y([Re || Ne ? l : "", p(c([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe }), " =>", f2(Pe ? y([i, ge]) : [" ", ge], { groupId: H }), Re ? h(l, "", { groupId: H }) : ""]);
            }
            function ee(U, Z, se, fe) {
              let ge = U.getValue(), he = [], we = [], ke = false;
              if (function H() {
                let pe = Y(U, Z, se, fe);
                if (he.length === 0)
                  he.push(pe);
                else {
                  let { leading: X, trailing: le } = a2(U, Z);
                  he.push([X, pe]), we.unshift(le);
                }
                ke = ke || ge.returnType && E(ge).length > 0 || ge.typeParameters || E(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U.call(H, "body"));
              }(), he.length > 1)
                return ie(U, fe, he, ke, we, ge);
              let Re = he;
              if (Re.push(" =>"), !N(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
                return p([...Re, " ", we]);
              if (ge.body.type === "SequenceExpression")
                return p([...Re, p([" (", y([l, we]), l, ")"])]);
              let Ne = (fe && fe.expandLastArg || U.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe = fe && fe.expandLastArg && $(Z, "all"), oe = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
              return p([...Re, p([y([i, oe ? h("", "(") : "", we, oe ? h("", ")") : ""]), Ne ? [h(Pe ? "," : ""), l] : ""])]);
            }
            function ce(U) {
              let Z = E(U);
              return Z.length === 1 && !U.typeParameters && !C(U, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;
            }
            function W(U, Z) {
              if (Z.arrowParens === "always")
                return false;
              if (Z.arrowParens === "avoid") {
                let se = U.getValue();
                return ce(se);
              }
              return false;
            }
            function K(U, Z, se) {
              let fe = U.getValue(), ge = Z("returnType");
              if (fe.returnType && x(se.originalText, fe.returnType))
                return [" /*: ", ge, " */"];
              let he = [ge];
              return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
            }
            function de(U, Z, se) {
              let fe = U.getValue(), ge = Z.semi ? ";" : "", he = [];
              fe.argument && (z(Z, fe.argument) ? he.push([" (", y([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p([h(" (", " "), y([l, se("argument")]), l, h(")")])) : he.push(" ", se("argument")));
              let we = o(fe), ke = n(we), Re = ke && m(ke);
              return Re && he.push(ge), C(fe, d.Dangling) && he.push(" ", s(U, Z, true)), Re || he.push(ge), he;
            }
            function ue(U, Z, se) {
              return ["return", de(U, Z, se)];
            }
            function Fe(U, Z, se) {
              return ["throw", de(U, Z, se)];
            }
            function z(U, Z) {
              if (N(U.originalText, Z))
                return true;
              if (B(Z)) {
                let se = Z, fe;
                for (; fe = k(se); )
                  if (se = fe, N(U.originalText, se))
                    return true;
              }
              return false;
            }
            r.exports = { printFunction: Q, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
          } }), nu = te({ "src/language-js/print/decorators.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t, hasNewline: s } = Ue(), { builders: { line: a2, hardline: n, join: u, breakParent: i, group: l } } = qe(), { locStart: p, locEnd: y } = ut(), { getParentExportDeclaration: h } = Ke();
            function g(w, E, N) {
              let x = w.getValue();
              return l([u(a2, w.map(N, "decorators")), F(x, E) ? n : a2]);
            }
            function c(w, E, N) {
              return [u(n, w.map(N, "declaration", "decorators")), n];
            }
            function f2(w, E, N) {
              let x = w.getValue(), { decorators: I } = x;
              if (!t(I) || _(w.getParentNode()))
                return;
              let P = x.type === "ClassExpression" || x.type === "ClassDeclaration" || F(x, E);
              return [h(w) ? n : P ? i : "", u(a2, w.map(N, "decorators")), a2];
            }
            function F(w, E) {
              return w.decorators.some((N) => s(E.originalText, y(N)));
            }
            function _(w) {
              if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration")
                return false;
              let E = w.declaration && w.declaration.decorators;
              return t(E) && p(w) === p(E[0]);
            }
            r.exports = { printDecorators: f2, printClassMemberDecorators: g, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
          } }), nr = te({ "src/language-js/print/class.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue(), { printComments: a2, printDanglingComments: n } = et(), { builders: { join: u, line: i, hardline: l, softline: p, group: y, indent: h, ifBreak: g } } = qe(), { hasComment: c, CommentCheckFlags: f2 } = Ke(), { getTypeParametersGroupId: F } = jr(), { printMethod: _ } = qr(), { printOptionalToken: w, printTypeAnnotation: E, printDefiniteToken: N } = ct(), { printPropertyKey: x } = rr(), { printAssignment: I } = tr(), { printClassMemberDecorators: P } = nu();
            function $(b, B, k) {
              let M = b.getValue(), R = [];
              M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
              let q = M.id && c(M.id, f2.Trailing) || M.typeParameters && c(M.typeParameters, f2.Trailing) || M.superClass && c(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), J = [], L = [];
              if (M.id && J.push(" ", k("id")), J.push(k("typeParameters")), M.superClass) {
                let Q = [d(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a2(j, Q, B)], "superClass");
                q ? L.push(i, y(V)) : L.push(" ", V);
              } else
                L.push(o(b, B, k, "extends"));
              if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
                let Q;
                C(M) ? Q = [...J, h(L)] : Q = h([...J, L]), R.push(y(Q, { id: D(M) }));
              } else
                R.push(...J, ...L);
              return R.push(" ", k("body")), R;
            }
            var D = s("heritageGroup");
            function T(b) {
              return g(l, "", { groupId: D(b) });
            }
            function m(b) {
              return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
            }
            function C(b) {
              return b.typeParameters && !c(b.typeParameters, f2.Trailing | f2.Line) && !m(b);
            }
            function o(b, B, k, M) {
              let R = b.getValue();
              if (!t(R[M]))
                return "";
              let q = n(b, B, true, (J) => {
                let { marker: L } = J;
                return L === M;
              });
              return [C(R) ? g(" ", i, { groupId: F(R.typeParameters) }) : i, q, q && l, M, y(h([i, u([",", i], b.map(k, M))]))];
            }
            function d(b, B, k) {
              let M = k("superClass");
              return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h([p, M]), p, ")"], M)) : M;
            }
            function v(b, B, k) {
              let M = b.getValue(), R = [];
              return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
            }
            function S(b, B, k) {
              let M = b.getValue(), R = [], q = B.semi ? ";" : "";
              return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x(b, B, k), w(b), N(b), E(b, B, k)), [I(b, B, k, R, " =", "value"), q];
            }
            r.exports = { printClass: $, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
          } }), bo = te({ "src/language-js/print/interface.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { join: s, line: a2, group: n, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: y } = Ke(), { getTypeParametersGroupId: h } = jr(), { printTypeScriptModifiers: g } = ct();
            function c(f2, F, _) {
              let w = f2.getValue(), E = [];
              w.declare && E.push("declare "), w.type === "TSInterfaceDeclaration" && E.push(w.abstract ? "abstract " : "", g(f2, F, _)), E.push("interface");
              let N = [], x = [];
              w.type !== "InterfaceTypeAnnotation" && N.push(" ", _("id"), _("typeParameters"));
              let I = w.typeParameters && !l(w.typeParameters, y.Trailing | y.Line);
              return t(w.extends) && x.push(I ? i(" ", a2, { groupId: h(w.typeParameters) }) : a2, "extends ", (w.extends.length === 1 ? p : u)(s([",", a2], f2.map(_, "extends")))), w.id && l(w.id, y.Trailing) || t(w.extends) ? I ? E.push(n([...N, u(x)])) : E.push(n(u([...N, ...x]))) : E.push(...N, ...x), E.push(" ", _("body")), n(E);
            }
            r.exports = { printInterface: c };
          } }), To = te({ "src/language-js/print/module.js"(e, r) {
            "use strict";
            ne();
            var { isNonEmptyArray: t } = Ue(), { builders: { softline: s, group: a2, indent: n, join: u, line: i, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: y } = et(), { hasComment: h, CommentCheckFlags: g, shouldPrintComma: c, needsHardlineAfterDanglingComment: f2, isStringLiteral: F, rawText: _ } = Ke(), { locStart: w, hasSameLoc: E } = ut(), { hasDecoratorsBeforeExport: N, printDecoratorsBeforeExport: x } = nu();
            function I(S, b, B) {
              let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q } = k;
              return R.push("import"), q && q !== "value" && R.push(" ", q), R.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R;
            }
            function P(S, b, B) {
              let k = S.getValue(), M = [];
              N(k) && M.push(x(S, b, B));
              let { type: R, exportKind: q, declaration: J } = k;
              return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), h(k, g.Dangling) && (M.push(" ", y(S, b, true)), f2(k) && M.push(p)), J ? M.push(" ", B("declaration")) : M.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
            }
            function $(S, b, B) {
              let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q, exported: J } = k;
              return R.push("export"), q === "type" && R.push(" type"), R.push(" *"), J && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
            }
            function D(S, b) {
              if (!b.semi)
                return false;
              let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
              if (!k)
                return true;
              let { type: R } = k;
              return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
            }
            function T(S, b, B) {
              let k = S.getValue();
              if (!k.source)
                return "";
              let M = [];
              return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
            }
            function m(S, b, B) {
              let k = S.getValue();
              if (C(k, b))
                return "";
              let M = [" "];
              if (t(k.specifiers)) {
                let R = [], q = [];
                S.each(() => {
                  let J = S.getValue().type;
                  if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                    R.push(B());
                  else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                    q.push(B());
                  else
                    throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
                }, "specifiers"), M.push(u(", ", R)), q.length > 0 && (R.length > 0 && M.push(", "), q.length > 1 || R.length > 0 || k.specifiers.some((L) => h(L)) ? M.push(a2(["{", n([b.bracketSpacing ? i : s, u([",", i], q)]), l(c(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
              } else
                M.push("{}");
              return M;
            }
            function C(S, b) {
              let { type: B, importKind: k, source: M, specifiers: R } = S;
              return B !== "ImportDeclaration" || t(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
            }
            function o(S, b, B) {
              let k = S.getNode();
              return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
            }
            function d(S, b, B) {
              let k = S.getNode(), { type: M } = k, R = [], q = M === "ImportSpecifier" ? k.importKind : k.exportKind;
              q && q !== "value" && R.push(q, " ");
              let J = M.startsWith("Import"), L = J ? "imported" : "local", Q = J ? "local" : "exported", V = k[L], j = k[Q], Y = "", ie = "";
              return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q)), R.push(Y, Y && ie ? " as " : "", ie), R;
            }
            function v(S) {
              if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier")
                return false;
              let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
              if (b.type !== B.type || !E(b, B))
                return false;
              if (F(b))
                return b.value === B.value && _(b) === _(B);
              switch (b.type) {
                case "Identifier":
                  return b.name === B.name;
                default:
                  return false;
              }
            }
            r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $, printModuleSpecifier: d };
          } }), uu = te({ "src/language-js/print/object.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { builders: { line: s, softline: a2, group: n, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: y, hasNewline: h, isNonEmptyArray: g } = Ue(), { shouldPrintComma: c, hasComment: f2, getComments: F, CommentCheckFlags: _, isNextLineEmpty: w } = Ke(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Lr(), { shouldHugType: $ } = Or(), { printHardlineAfterHeritage: D } = nr();
            function T(m, C, o) {
              let d = C.semi ? ";" : "", v = m.getValue(), S;
              v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
              let b = v.type === "ObjectTypeAnnotation", B = [S];
              b && B.push("indexers", "callProperties", "internalSlots");
              let k = B.map((W) => v[W][0]).sort((W, K) => E(W) - E(K))[0], M = m.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m.getName() === "body", q = v.type === "TSInterfaceBody" || R || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && y(C.originalText, E(v), E(k)), J = R ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(d, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q = v.exact ? "|}" : "}", V = [];
              for (let W of B)
                m.each((K) => {
                  let de = K.getValue();
                  V.push({ node: de, printed: o(), loc: E(de) });
                }, W);
              B.length > 1 && V.sort((W, K) => W.loc - K.loc);
              let j = [], Y = V.map((W) => {
                let K = [...j, n(W.printed)];
                return j = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f2(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
              });
              if (v.inexact) {
                let W;
                if (f2(v, _.Dangling)) {
                  let K = f2(v, _.Line);
                  W = [t(m, C, true), K || h(C.originalText, N(p(F(v)))) ? l : s, "..."];
                } else
                  W = ["..."];
                Y.push([...j, ...W]);
              }
              let ie = p(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f2(ie, _.PrettierIgnore)), ce;
              if (Y.length === 0) {
                if (!f2(v, _.Dangling))
                  return [L, Q, I(m, C, o)];
                ce = n([L, t(m, C), a2, Q, x(m), I(m, C, o)]);
              } else
                ce = [R && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s : a2, ...Y]), i(ee && (J !== "," || c(C)) ? J : ""), C.bracketSpacing ? s : a2, Q, x(m), I(m, C, o)];
              return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m.match($, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n(ce, { shouldBreak: q });
            }
            r.exports = { printObject: T };
          } }), dd = te({ "src/language-js/print/flow.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { printDanglingComments: s } = et(), { printString: a2, printNumber: n } = Ue(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h, isGetterOrSetter: g, rawText: c, shouldPrintComma: f2 } = Ke(), { locStart: F, locEnd: _ } = ut(), { replaceTextEndOfLine: w } = Yt(), { printClass: E } = nr(), { printOpaqueType: N, printTypeAlias: x, printIntersectionType: I, printUnionType: P, printFunctionType: $, printTupleType: D, printIndexedAccessType: T } = Or(), { printInterface: m } = bo(), { printTypeParameter: C, printTypeParameters: o } = jr(), { printExportDeclaration: d, printExportAllDeclaration: v } = To(), { printArrayItems: S } = er(), { printObject: b } = uu(), { printPropertyKey: B } = rr(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct();
            function q(L, Q, V) {
              let j = L.getValue(), Y = Q.semi ? ";" : "", ie = [];
              switch (j.type) {
                case "DeclareClass":
                  return J(L, E(L, Q, V));
                case "DeclareFunction":
                  return J(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
                case "DeclareModule":
                  return J(L, ["module ", V("id"), " ", V("body")]);
                case "DeclareModuleExports":
                  return J(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
                case "DeclareVariable":
                  return J(L, ["var ", V("id"), Y]);
                case "DeclareOpaqueType":
                  return J(L, N(L, Q, V));
                case "DeclareInterface":
                  return J(L, m(L, Q, V));
                case "DeclareTypeAlias":
                  return J(L, x(L, Q, V));
                case "DeclareExportDeclaration":
                  return J(L, d(L, Q, V));
                case "DeclareExportAllDeclaration":
                  return J(L, v(L, Q, V));
                case "OpaqueType":
                  return N(L, Q, V);
                case "TypeAlias":
                  return x(L, Q, V);
                case "IntersectionTypeAnnotation":
                  return I(L, Q, V);
                case "UnionTypeAnnotation":
                  return P(L, Q, V);
                case "FunctionTypeAnnotation":
                  return $(L, Q, V);
                case "TupleTypeAnnotation":
                  return D(L, Q, V);
                case "GenericTypeAnnotation":
                  return [V("id"), o(L, Q, V, "typeParameters")];
                case "IndexedAccessType":
                case "OptionalIndexedAccessType":
                  return T(L, Q, V);
                case "TypeAnnotation":
                  return V("typeAnnotation");
                case "TypeParameter":
                  return C(L, Q, V);
                case "TypeofTypeAnnotation":
                  return ["typeof ", V("argument")];
                case "ExistsTypeAnnotation":
                  return "*";
                case "EmptyTypeAnnotation":
                  return "empty";
                case "MixedTypeAnnotation":
                  return "mixed";
                case "ArrayTypeAnnotation":
                  return [V("elementType"), "[]"];
                case "BooleanLiteralTypeAnnotation":
                  return String(j.value);
                case "EnumDeclaration":
                  return ["enum ", V("id"), " ", V("body")];
                case "EnumBooleanBody":
                case "EnumNumberBody":
                case "EnumStringBody":
                case "EnumSymbolBody": {
                  if (j.type === "EnumSymbolBody" || j.explicitType) {
                    let ee = null;
                    switch (j.type) {
                      case "EnumBooleanBody":
                        ee = "boolean";
                        break;
                      case "EnumNumberBody":
                        ee = "number";
                        break;
                      case "EnumStringBody":
                        ee = "string";
                        break;
                      case "EnumSymbolBody":
                        ee = "symbol";
                        break;
                    }
                    ie.push("of ", ee, " ");
                  }
                  if (j.members.length === 0 && !j.hasUnknownMembers)
                    ie.push(l(["{", s(L, Q), i, "}"]));
                  else {
                    let ee = j.members.length > 0 ? [u, S(L, Q, "members", V), j.hasUnknownMembers || f2(Q) ? "," : ""] : [];
                    ie.push(l(["{", p([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q, true), u, "}"]));
                  }
                  return ie;
                }
                case "EnumBooleanMember":
                case "EnumNumberMember":
                case "EnumStringMember":
                  return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
                case "EnumDefaultedMember":
                  return V("id");
                case "FunctionTypeParam": {
                  let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
                  return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
                }
                case "InterfaceDeclaration":
                case "InterfaceTypeAnnotation":
                  return m(L, Q, V);
                case "ClassImplements":
                case "InterfaceExtends":
                  return [V("id"), V("typeParameters")];
                case "NullableTypeAnnotation":
                  return ["?", V("typeAnnotation")];
                case "Variance": {
                  let { kind: ee } = j;
                  return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
                }
                case "ObjectTypeCallProperty":
                  return j.static && ie.push("static "), ie.push(V("value")), ie;
                case "ObjectTypeIndexer":
                  return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
                case "ObjectTypeProperty": {
                  let ee = "";
                  return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q, V), k(L), h(j) ? "" : ": ", V("value")];
                }
                case "ObjectTypeAnnotation":
                  return b(L, Q, V);
                case "ObjectTypeInternalSlot":
                  return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
                case "ObjectTypeSpreadProperty":
                  return R(L, Q, V);
                case "QualifiedTypeofIdentifier":
                case "QualifiedTypeIdentifier":
                  return [V("qualification"), ".", V("id")];
                case "StringLiteralTypeAnnotation":
                  return w(a2(c(j), Q));
                case "NumberLiteralTypeAnnotation":
                  t.strictEqual(typeof j.value, "number");
                case "BigIntLiteralTypeAnnotation":
                  return j.extra ? n(j.extra.raw) : n(j.raw);
                case "TypeCastExpression":
                  return ["(", V("expression"), M(L, Q, V), ")"];
                case "TypeParameterDeclaration":
                case "TypeParameterInstantiation": {
                  let ee = o(L, Q, V, "params");
                  if (Q.parser === "flow") {
                    let ce = F(j), W = _(j), K = Q.originalText.lastIndexOf("/*", ce), de = Q.originalText.indexOf("*/", W);
                    if (K !== -1 && de !== -1) {
                      let ue = Q.originalText.slice(K + 2, de).trim();
                      if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/"))
                        return ["/*:: ", ee, " */"];
                    }
                  }
                  return ee;
                }
                case "InferredPredicate":
                  return "%checks";
                case "DeclaredPredicate":
                  return ["%checks(", V("value"), ")"];
                case "AnyTypeAnnotation":
                  return "any";
                case "BooleanTypeAnnotation":
                  return "boolean";
                case "BigIntTypeAnnotation":
                  return "bigint";
                case "NullLiteralTypeAnnotation":
                  return "null";
                case "NumberTypeAnnotation":
                  return "number";
                case "SymbolTypeAnnotation":
                  return "symbol";
                case "StringTypeAnnotation":
                  return "string";
                case "VoidTypeAnnotation":
                  return "void";
                case "ThisTypeAnnotation":
                  return "this";
                case "Node":
                case "Printable":
                case "SourceLocation":
                case "Position":
                case "Statement":
                case "Function":
                case "Pattern":
                case "Expression":
                case "Declaration":
                case "Specifier":
                case "NamedSpecifier":
                case "Comment":
                case "MemberTypeAnnotation":
                case "Type":
                  throw new Error("unprintable type: " + JSON.stringify(j.type));
              }
            }
            function J(L, Q) {
              let V = y(L);
              return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q) : ["declare ", Q];
            }
            r.exports = { printFlow: q };
          } }), gd = te({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              let { type: a2 } = s;
              return a2.startsWith("TS") && a2.endsWith("Keyword");
            }
            r.exports = t;
          } }), Bo = te({ "src/language-js/print/ternary.js"(e, r) {
            "use strict";
            ne();
            var { hasNewlineInRange: t } = Ue(), { isJsxNode: s, getComments: a2, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: p } = ut(), y = Pt(), { builders: { line: h, softline: g, group: c, indent: f2, align: F, ifBreak: _, dedent: w, breakParent: E } } = qe();
            function N(D) {
              let T = [D];
              for (let m = 0; m < T.length; m++) {
                let C = T[m];
                for (let o of ["test", "consequent", "alternate"]) {
                  let d = C[o];
                  if (s(d))
                    return true;
                  d.type === "ConditionalExpression" && T.push(d);
                }
              }
              return false;
            }
            function x(D, T, m) {
              let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
              return v.type === C.type && v[d] === C ? F(2, S) : S;
            }
            var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
            function P(D) {
              let T = D.getValue();
              if (T.type !== "ConditionalExpression")
                return false;
              let m, C = T;
              for (let o = 0; !m; o++) {
                let d = D.getParentNode(o);
                if (n(d) && d.callee === C || u(d) && d.object === C || d.type === "TSNonNullExpression" && d.expression === C) {
                  C = d;
                  continue;
                }
                d.type === "NewExpression" && d.callee === C || i(d) && d.expression === C ? (m = D.getParentNode(o + 1), C = d) : m = d;
              }
              return C === T ? false : m[I.get(m.type)] === C;
            }
            function $(D, T, m) {
              let C = D.getValue(), o = C.type === "ConditionalExpression", d = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[d], B = C[v], k = [], M = false, R = D.getParentNode(), q = R.type === C.type && S.some((ue) => R[ue] === C), J = R.type === C.type && !q, L, Q, V = 0;
              do
                Q = L || C, L = D.getParentNode(V), V++;
              while (L && L.type === C.type && S.every((ue) => L[ue] !== Q));
              let j = L || R, Y = Q;
              if (o && (s(C[S[0]]) || s(b) || s(B) || N(Y))) {
                M = true, J = true;
                let ue = (z) => [_("("), f2([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
                k.push(" ? ", Fe(b) ? m(d) : ue(m(d)), " : ", B.type === C.type || Fe(B) ? m(v) : ue(m(v)));
              } else {
                let ue = [h, "? ", b.type === C.type ? _("", "(") : "", F(2, m(d)), b.type === C.type ? _("", ")") : "", h, ": ", B.type === C.type ? m(v) : F(2, m(v))];
                k.push(R.type !== C.type || R[v] === C || q ? ue : T.useTabs ? w(f2(ue)) : F(Math.max(0, T.tabWidth - 2), ue));
              }
              let ee = [...S.map((ue) => a2(C[ue])), a2(b), a2(B)].flat().some((ue) => y(ue) && t(T.originalText, l(ue), p(ue))), ce = (ue) => R === j ? c(ue, { shouldBreak: ee }) : ee ? [ue, E] : ue, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C) && !R.computed, K = P(D), de = ce([x(D, T, m), J ? k : f2(k), o && W && !K ? g : ""]);
              return q || K ? c([f2([g, de]), g]) : de;
            }
            r.exports = { printTernary: $ };
          } }), No = te({ "src/language-js/print/statement.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t } } = qe(), s = qt(), { getLeftSidePathName: a2, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: y } = Ke(), { shouldPrintParamsWithoutParens: h } = qr();
            function g(x, I, P, $) {
              let D = x.getValue(), T = [], m = D.type === "ClassBody", C = c(D[$]);
              return x.each((o, d, v) => {
                let S = o.getValue();
                if (S.type === "EmptyStatement")
                  return;
                let b = P();
                !I.semi && !m && !i(I, o) && f2(o, I) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m && E(S) && N(S, v[d + 1]) && T.push(";"), S !== C && (T.push(t), y(S, I) && T.push(t));
              }, $), T;
            }
            function c(x) {
              for (let I = x.length - 1; I >= 0; I--) {
                let P = x[I];
                if (P.type !== "EmptyStatement")
                  return P;
              }
            }
            function f2(x, I) {
              return x.getNode().type !== "ExpressionStatement" ? false : x.call(($) => F($, I), "expression");
            }
            function F(x, I) {
              let P = x.getValue();
              switch (P.type) {
                case "ParenthesizedExpression":
                case "TypeCastExpression":
                case "ArrayExpression":
                case "ArrayPattern":
                case "TemplateLiteral":
                case "TemplateElement":
                case "RegExpLiteral":
                  return true;
                case "ArrowFunctionExpression": {
                  if (!h(x, I))
                    return true;
                  break;
                }
                case "UnaryExpression": {
                  let { prefix: $, operator: D } = P;
                  if ($ && (D === "+" || D === "-"))
                    return true;
                  break;
                }
                case "BindExpression": {
                  if (!P.object)
                    return true;
                  break;
                }
                case "Literal": {
                  if (P.regex)
                    return true;
                  break;
                }
                default:
                  if (u(P))
                    return true;
              }
              return s(x, I) ? true : n(P) ? x.call(($) => F($, I), ...a2(x, P)) : false;
            }
            function _(x, I, P) {
              return g(x, I, P, "body");
            }
            function w(x, I, P) {
              return g(x, I, P, "consequent");
            }
            var E = (x) => {
              let { type: I } = x;
              return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
            };
            function N(x, I) {
              let { type: P, name: $ } = x.key;
              if (!x.computed && P === "Identifier" && ($ === "static" || $ === "get" || $ === "set" || $ === "accessor") && !x.value && !x.typeAnnotation)
                return true;
              if (!I || I.static || I.accessibility)
                return false;
              if (!I.computed) {
                let D = I.key && I.key.name;
                if (D === "in" || D === "instanceof")
                  return true;
              }
              if (E(I) && I.variance && !I.static && !I.declare)
                return true;
              switch (I.type) {
                case "ClassProperty":
                case "PropertyDefinition":
                case "TSAbstractPropertyDefinition":
                  return I.computed;
                case "MethodDefinition":
                case "TSAbstractMethodDefinition":
                case "ClassMethod":
                case "ClassPrivateMethod": {
                  if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                    return false;
                  let T = I.value ? I.value.generator : I.generator;
                  return !!(I.computed || T);
                }
                case "TSIndexSignature":
                  return true;
              }
              return false;
            }
            r.exports = { printBody: _, printSwitchCaseConsequent: w };
          } }), wo = te({ "src/language-js/print/block.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a2, indent: n } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: p } = nr(), { printBody: y } = No();
            function h(c, f2, F) {
              let _ = c.getValue(), w = [];
              if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
                let N = c.getParentNode();
                w.push(p(N));
              }
              w.push("{");
              let E = g(c, f2, F);
              if (E)
                w.push(n([a2, E]), a2);
              else {
                let N = c.getParentNode(), x = c.getParentNode(1);
                N.type === "ArrowFunctionExpression" || N.type === "FunctionExpression" || N.type === "FunctionDeclaration" || N.type === "ObjectMethod" || N.type === "ClassMethod" || N.type === "ClassPrivateMethod" || N.type === "ForStatement" || N.type === "WhileStatement" || N.type === "DoWhileStatement" || N.type === "DoExpression" || N.type === "CatchClause" && !x.finalizer || N.type === "TSModuleDeclaration" || N.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a2);
              }
              return w.push("}"), w;
            }
            function g(c, f2, F) {
              let _ = c.getValue(), w = s(_.directives), E = _.body.some((I) => I.type !== "EmptyStatement"), N = u(_, i.Dangling);
              if (!w && !E && !N)
                return "";
              let x = [];
              if (w && c.each((I, P, $) => {
                x.push(F()), (P < $.length - 1 || E || N) && (x.push(a2), l(I.getValue(), f2) && x.push(a2));
              }, "directives"), E && x.push(y(c, f2, F)), N && x.push(t(c, f2, true)), _.type === "Program") {
                let I = c.getParentNode();
                (!I || I.type !== "ModuleExpression") && x.push(a2);
              }
              return x;
            }
            r.exports = { printBlock: h, printBlockBody: g };
          } }), yd = te({ "src/language-js/print/typescript.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a2, line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: y, ifBreak: h } } = qe(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f2, isCallExpression: F, isMemberExpression: _ } = Ke(), w = gd(), { locStart: E, locEnd: N } = ut(), { printOptionalToken: x, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Bo(), { printFunctionParameters: $, shouldGroupFunctionParameters: D } = Lr(), { printTemplateLiteral: T } = jt(), { printArrayItems: m } = er(), { printObject: C } = uu(), { printClassProperty: o, printClassMethod: d } = nr(), { printTypeParameter: v, printTypeParameters: S } = jr(), { printPropertyKey: b } = rr(), { printFunction: B, printMethodInternal: k } = qr(), { printInterface: M } = bo(), { printBlock: R } = wo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Q, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = Or();
            function ie(ee, ce, W) {
              let K = ee.getValue();
              if (!K.type.startsWith("TS"))
                return;
              if (w(K))
                return K.type.slice(2, -7).toLowerCase();
              let de = ce.semi ? ";" : "", ue = [];
              switch (K.type) {
                case "TSThisType":
                  return "this";
                case "TSTypeAssertion": {
                  let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U = [h("("), p([i, W("expression")]), i, h(")")];
                  return Fe ? y([[z, W("expression")], [z, l(U, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
                }
                case "TSDeclareFunction":
                  return B(ee, W, ce);
                case "TSExportAssignment":
                  return ["export = ", W("expression"), de];
                case "TSModuleBlock":
                  return R(ee, ce, W);
                case "TSInterfaceBody":
                case "TSTypeLiteral":
                  return C(ee, ce, W);
                case "TSTypeAliasDeclaration":
                  return q(ee, ce, W);
                case "TSQualifiedName":
                  return a2(".", [W("left"), W("right")]);
                case "TSAbstractMethodDefinition":
                case "TSDeclareMethod":
                  return d(ee, ce, W);
                case "TSAbstractAccessorProperty":
                case "TSAbstractPropertyDefinition":
                  return o(ee, ce, W);
                case "TSInterfaceHeritage":
                case "TSExpressionWithTypeArguments":
                  return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
                case "TSTemplateLiteralType":
                  return T(ee, W, ce);
                case "TSNamedTupleMember":
                  return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
                case "TSRestType":
                  return ["...", W("typeAnnotation")];
                case "TSOptionalType":
                  return [W("typeAnnotation"), "?"];
                case "TSInterfaceDeclaration":
                  return M(ee, ce, W);
                case "TSClassImplements":
                  return [W("expression"), W("typeParameters")];
                case "TSTypeParameterDeclaration":
                case "TSTypeParameterInstantiation":
                  return S(ee, ce, W, "params");
                case "TSTypeParameter":
                  return v(ee, ce, W);
                case "TSSatisfiesExpression":
                case "TSAsExpression": {
                  let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
                  ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
                  let z = ee.getParentNode();
                  return F(z) && z.callee === K || _(z) && z.object === K ? l([p([i, ...ue]), i]) : ue;
                }
                case "TSArrayType":
                  return [W("elementType"), "[]"];
                case "TSPropertySignature":
                  return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
                case "TSParameterProperty":
                  return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
                case "TSTypeQuery":
                  return ["typeof ", W("exprName"), W("typeParameters")];
                case "TSIndexSignature": {
                  let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? h(f2(ce) ? "," : "") : "", U = l([p([i, a2([", ", i], ee.map(W, "parameters"))]), z, i]);
                  return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
                }
                case "TSTypePredicate":
                  return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
                case "TSNonNullExpression":
                  return [W("expression"), "!"];
                case "TSImportType":
                  return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
                case "TSLiteralType":
                  return W("literal");
                case "TSIndexedAccessType":
                  return j(ee, ce, W);
                case "TSConstructSignatureDeclaration":
                case "TSCallSignatureDeclaration":
                case "TSConstructorType": {
                  if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
                    let Fe = K.type === "TSConstructorType";
                    ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                  }
                  return ue;
                }
                case "TSTypeOperator":
                  return [K.operator, " ", W("typeAnnotation")];
                case "TSMappedType": {
                  let Fe = s(ce.originalText, E(K), N(K));
                  return l(["{", p([ce.bracketSpacing ? n : i, W("typeParameter"), K.optional ? c(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), h(de)]), t(ee, ce, true), ce.bracketSpacing ? n : i, "}"], { shouldBreak: Fe });
                }
                case "TSMethodSignature": {
                  let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
                  ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x(ee));
                  let z = $(ee, W, ce, false, true), U = K.returnType ? "returnType" : "typeAnnotation", Z = K[U], se = Z ? W(U) : "", fe = D(K, se);
                  return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
                }
                case "TSNamespaceExportDeclaration":
                  return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
                case "TSEnumDeclaration":
                  return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t(ee, ce), i, "}"])) : ue.push(l(["{", p([u, m(ee, ce, "members", W), f2(ce, "es5") ? "," : ""]), t(ee, ce, true), u, "}"])), ue;
                case "TSEnumMember":
                  return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
                case "TSImportEqualsDeclaration":
                  return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
                case "TSExternalModuleReference":
                  return ["require(", W("expression"), ")"];
                case "TSModuleDeclaration": {
                  let Fe = ee.getParentNode(), z = g(K.id), U = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
                  if (U)
                    ue.push(".");
                  else {
                    K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
                    let se = ce.originalText.slice(E(K), E(K.id));
                    K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
                  }
                  return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
                }
                case "TSConditionalType":
                  return P(ee, ce, W);
                case "TSInferType":
                  return ["infer", " ", W("typeParameter")];
                case "TSIntersectionType":
                  return J(ee, ce, W);
                case "TSUnionType":
                  return L(ee, ce, W);
                case "TSFunctionType":
                  return Q(ee, ce, W);
                case "TSTupleType":
                  return V(ee, ce, W);
                case "TSTypeReference":
                  return [W("typeName"), S(ee, ce, W, "typeParameters")];
                case "TSTypeAnnotation":
                  return W("typeAnnotation");
                case "TSEmptyBodyFunctionExpression":
                  return k(ee, ce, W);
                case "TSJSDocAllType":
                  return "*";
                case "TSJSDocUnknownType":
                  return "?";
                case "TSJSDocNullableType":
                  return Y(ee, W, "?");
                case "TSJSDocNonNullableType":
                  return Y(ee, W, "!");
                case "TSInstantiationExpression":
                  return [W("expression"), W("typeParameters")];
                default:
                  throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
              }
            }
            r.exports = { printTypescript: ie };
          } }), hd = te({ "src/language-js/print/comment.js"(e, r) {
            "use strict";
            ne();
            var { hasNewline: t } = Ue(), { builders: { join: s, hardline: a2 }, utils: { replaceTextEndOfLine: n } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = ut(), p = Pt();
            function y(c, f2) {
              let F = c.getValue();
              if (u(F))
                return f2.originalText.slice(i(F), l(F)).trimEnd();
              if (p(F)) {
                if (h(F)) {
                  let E = g(F);
                  return F.trailing && !t(f2.originalText, i(F), { backwards: true }) ? [a2, E] : E;
                }
                let _ = l(F), w = f2.originalText.slice(_ - 3, _) === "*-/";
                return ["/*", n(F.value), w ? "*-/" : "*/"];
              }
              throw new Error("Not a comment: " + JSON.stringify(F));
            }
            function h(c) {
              let f2 = `*${c.value}*`.split(`
`);
              return f2.length > 1 && f2.every((F) => F.trim()[0] === "*");
            }
            function g(c) {
              let f2 = c.value.split(`
`);
              return ["/*", s(a2, f2.map((F, _) => _ === 0 ? F.trimEnd() : " " + (_ < f2.length - 1 ? F.trim() : F.trimStart()))), "*/"];
            }
            r.exports = { printComment: y };
          } }), vd = te({ "src/language-js/print/literal.js"(e, r) {
            "use strict";
            ne();
            var { printString: t, printNumber: s } = Ue(), { replaceTextEndOfLine: a2 } = Yt(), { printDirective: n } = ct();
            function u(y, h) {
              let g = y.getNode();
              switch (g.type) {
                case "RegExpLiteral":
                  return p(g);
                case "BigIntLiteral":
                  return l(g.bigint || g.extra.raw);
                case "NumericLiteral":
                  return s(g.extra.raw);
                case "StringLiteral":
                  return a2(t(g.extra.raw, h));
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return String(g.value);
                case "DecimalLiteral":
                  return s(g.value) + "m";
                case "Literal": {
                  if (g.regex)
                    return p(g.regex);
                  if (g.bigint)
                    return l(g.raw);
                  if (g.decimal)
                    return s(g.decimal) + "m";
                  let { value: c } = g;
                  return typeof c == "number" ? s(g.raw) : typeof c == "string" ? i(y) ? n(g.raw, h) : a2(t(g.raw, h)) : String(c);
                }
              }
            }
            function i(y) {
              if (y.getName() !== "expression")
                return;
              let h = y.getParentNode();
              return h.type === "ExpressionStatement" && h.directive;
            }
            function l(y) {
              return y.toLowerCase();
            }
            function p(y) {
              let { pattern: h, flags: g } = y;
              return g = [...g].sort().join(""), `/${h}/${g}`;
            }
            r.exports = { printLiteral: u };
          } }), Cd = te({ "src/language-js/printer-estree.js"(e, r) {
            "use strict";
            ne();
            var { printDanglingComments: t } = et(), { hasNewline: s } = Ue(), { builders: { join: a2, line: n, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = td(), g = rd(), { insertPragma: c } = Co(), f2 = Eo(), F = qt(), _ = Fo(), { hasFlowShorthandAnnotationComment: w, hasComment: E, CommentCheckFlags: N, isTheOnlyJsxElementInMarkdown: x, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke(), { locStart: o, locEnd: d } = ut(), v = Pt(), { printHtmlBinding: S, isVueEventBindingExpression: b } = pd(), { printAngular: B } = fd(), { printJsx: k, hasJsxIgnoreComment: M } = Dd(), { printFlow: R } = dd(), { printTypescript: q } = yd(), { printOptionalToken: J, printBindExpressionCallee: L, printTypeAnnotation: Q, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = To(), { printTernary: de } = Bo(), { printTemplateLiteral: ue } = jt(), { printArray: Fe } = er(), { printObject: z } = uu(), { printClass: U, printClassMethod: Z, printClassProperty: se } = nr(), { printProperty: fe } = rr(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = qr(), { printCallExpression: Ne } = xo(), { printVariableDeclarator: Pe, printAssignmentExpression: oe } = tr(), { printBinaryishExpression: H } = ru(), { printSwitchCaseConsequent: pe } = No(), { printMemberExpression: X } = So(), { printBlock: le, printBlockBody: Ae } = wo(), { printComment: Ee } = hd(), { printLiteral: De } = vd(), { printDecorators: A2 } = nu();
            function G(Ce, Be, ve, ze) {
              let be = re(Ce, Be, ve, ze);
              if (!be)
                return "";
              let Ye = Ce.getValue(), { type: Se } = Ye;
              if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod")
                return be;
              let Ie = [be], Oe = A2(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
              if (Oe && (Ie = [...Oe, be], !Je))
                return l(Ie);
              if (!F(Ce, Be))
                return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === be ? be : Ie;
              if (Je && (Ie = [p([n, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
                let [je] = Ye.trailingComments;
                Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
              }
              return Je && Ie.push(n), Ie.push(")"), Ie;
            }
            function re(Ce, Be, ve, ze) {
              let be = Ce.getValue(), Ye = Be.semi ? ";" : "";
              if (!be)
                return "";
              if (typeof be == "string")
                return be;
              for (let Ie of [De, S, B, k, R, q]) {
                let Oe = Ie(Ce, Be, ve);
                if (typeof Oe < "u")
                  return Oe;
              }
              let Se = [];
              switch (be.type) {
                case "JsExpressionRoot":
                  return ve("node");
                case "JsonRoot":
                  return [ve("node"), u];
                case "File":
                  return be.program && be.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
                case "Program":
                  return Ae(Ce, Be, ve);
                case "EmptyStatement":
                  return "";
                case "ExpressionStatement": {
                  if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
                    let Oe = Ce.getParentNode();
                    if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === be)
                      return [ve("expression"), b(be.expression) ? ";" : ""];
                  }
                  let Ie = t(Ce, Be, true, (Oe) => {
                    let { marker: Je } = Oe;
                    return Je === C;
                  });
                  return [ve("expression"), x(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
                }
                case "ParenthesizedExpression":
                  return !E(be.expression) && (be.expression.type === "ObjectExpression" || be.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p([i, ve("expression")]), i, ")"]);
                case "AssignmentExpression":
                  return oe(Ce, Be, ve);
                case "VariableDeclarator":
                  return Pe(Ce, Be, ve);
                case "BinaryExpression":
                case "LogicalExpression":
                  return H(Ce, Be, ve);
                case "AssignmentPattern":
                  return [ve("left"), " = ", ve("right")];
                case "OptionalMemberExpression":
                case "MemberExpression":
                  return X(Ce, Be, ve);
                case "MetaProperty":
                  return [ve("meta"), ".", ve("property")];
                case "BindExpression":
                  return be.object && Se.push(ve("object")), Se.push(l(p([i, L(Ce, Be, ve)]))), Se;
                case "Identifier":
                  return [be.name, J(Ce), Y(Ce), Q(Ce, Be, ve)];
                case "V8IntrinsicIdentifier":
                  return ["%", be.name];
                case "SpreadElement":
                case "SpreadElementPattern":
                case "SpreadProperty":
                case "SpreadPropertyPattern":
                case "RestElement":
                  return j(Ce, Be, ve);
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return ge(Ce, ve, Be, ze);
                case "ArrowFunctionExpression":
                  return he(Ce, Be, ve, ze);
                case "YieldExpression":
                  return Se.push("yield"), be.delegate && Se.push("*"), be.argument && Se.push(" ", ve("argument")), Se;
                case "AwaitExpression": {
                  if (Se.push("await"), be.argument) {
                    Se.push(" ", ve("argument"));
                    let Ie = Ce.getParentNode();
                    if (T(Ie) && Ie.callee === be || m(Ie) && Ie.object === be) {
                      Se = [p([i, ...Se]), i];
                      let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
                      if (!Oe || Oe.type !== "AwaitExpression")
                        return l(Se);
                    }
                  }
                  return Se;
                }
                case "ExportDefaultDeclaration":
                case "ExportNamedDeclaration":
                  return ce(Ce, Be, ve);
                case "ExportAllDeclaration":
                  return W(Ce, Be, ve);
                case "ImportDeclaration":
                  return ee(Ce, Be, ve);
                case "ImportSpecifier":
                case "ExportSpecifier":
                case "ImportNamespaceSpecifier":
                case "ExportNamespaceSpecifier":
                case "ImportDefaultSpecifier":
                case "ExportDefaultSpecifier":
                  return K(Ce, Be, ve);
                case "ImportAttribute":
                  return [ve("key"), ": ", ve("value")];
                case "Import":
                  return "import";
                case "BlockStatement":
                case "StaticBlock":
                case "ClassBody":
                  return le(Ce, Be, ve);
                case "ThrowStatement":
                  return Re(Ce, Be, ve);
                case "ReturnStatement":
                  return ke(Ce, Be, ve);
                case "NewExpression":
                case "ImportExpression":
                case "OptionalCallExpression":
                case "CallExpression":
                  return Ne(Ce, Be, ve);
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  return z(Ce, Be, ve);
                case "ObjectProperty":
                case "Property":
                  return be.method || be.kind === "get" || be.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
                case "ObjectMethod":
                  return we(Ce, Be, ve);
                case "Decorator":
                  return ["@", ve("expression")];
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  return Fe(Ce, Be, ve);
                case "SequenceExpression": {
                  let Ie = Ce.getParentNode(0);
                  if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
                    let Oe = [];
                    return Ce.each((Je, Te) => {
                      Te === 0 ? Oe.push(ve()) : Oe.push(",", p([n, ve()]));
                    }, "expressions"), l(Oe);
                  }
                  return l(a2([",", n], Ce.map(ve, "expressions")));
                }
                case "ThisExpression":
                  return "this";
                case "Super":
                  return "super";
                case "Directive":
                  return [ve("value"), Ye];
                case "DirectiveLiteral":
                  return ie(be.extra.raw, Be);
                case "UnaryExpression":
                  return Se.push(be.operator), /[a-z]$/.test(be.operator) && Se.push(" "), E(be.argument) ? Se.push(l(["(", p([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
                case "UpdateExpression":
                  return Se.push(ve("argument"), be.operator), be.prefix && Se.reverse(), Se;
                case "ConditionalExpression":
                  return de(Ce, Be, ve);
                case "VariableDeclaration": {
                  let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", Te = be.declarations.some((Me) => Me.init), je;
                  return Ie.length === 1 && !E(be.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p(Ie[0])), Se = [be.declare ? "declare " : "", be.kind, je ? [" ", je] : "", p(Ie.slice(1).map((Me) => [",", Te && !Je ? u : n, Me]))], Je && Oe.body !== be || Se.push(Ye), l(Se);
                }
                case "WithStatement":
                  return l(["with (", ve("object"), ")", V(be.body, ve("body"))]);
                case "IfStatement": {
                  let Ie = V(be.consequent, ve("consequent")), Oe = l(["if (", l([p([i, ve("test")]), i]), ")", Ie]);
                  if (Se.push(Oe), be.alternate) {
                    let Je = E(be.consequent, N.Trailing | N.Line) || $(be), Te = be.consequent.type === "BlockStatement" && !Je;
                    Se.push(Te ? " " : u), E(be, N.Dangling) && Se.push(t(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(be.alternate, ve("alternate"), be.alternate.type === "IfStatement")));
                  }
                  return Se;
                }
                case "ForStatement": {
                  let Ie = V(be.body, ve("body")), Oe = t(Ce, Be, true), Je = Oe ? [Oe, i] : "";
                  return !be.init && !be.test && !be.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p([i, ve("init"), ";", n, ve("test"), ";", n, ve("update")]), i]), ")", Ie])];
                }
                case "WhileStatement":
                  return l(["while (", l([p([i, ve("test")]), i]), ")", V(be.body, ve("body"))]);
                case "ForInStatement":
                  return l(["for (", ve("left"), " in ", ve("right"), ")", V(be.body, ve("body"))]);
                case "ForOfStatement":
                  return l(["for", be.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(be.body, ve("body"))]);
                case "DoWhileStatement": {
                  let Ie = V(be.body, ve("body"));
                  return Se = [l(["do", Ie])], be.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p([i, ve("test")]), i]), ")", Ye), Se;
                }
                case "DoExpression":
                  return [be.async ? "async " : "", "do ", ve("body")];
                case "BreakStatement":
                  return Se.push("break"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
                case "ContinueStatement":
                  return Se.push("continue"), be.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
                case "LabeledStatement":
                  return be.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
                case "TryStatement":
                  return ["try ", ve("block"), be.handler ? [" ", ve("handler")] : "", be.finalizer ? [" finally ", ve("finalizer")] : ""];
                case "CatchClause":
                  if (be.param) {
                    let Ie = E(be.param, (Je) => !v(Je) || Je.leading && s(Be.originalText, d(Je)) || Je.trailing && s(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
                    return ["catch ", Ie ? ["(", p([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
                  }
                  return ["catch ", ve("body")];
                case "SwitchStatement":
                  return [l(["switch (", p([i, ve("discriminant")]), i, ")"]), " {", be.cases.length > 0 ? p([u, a2(u, Ce.map((Ie, Oe, Je) => {
                    let Te = Ie.getValue();
                    return [ve(), Oe !== Je.length - 1 && P(Te, Be) ? u : ""];
                  }, "cases"))]) : "", u, "}"];
                case "SwitchCase": {
                  be.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), E(be, N.Dangling) && Se.push(" ", t(Ce, Be, true));
                  let Ie = be.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
                  if (Ie.length > 0) {
                    let Oe = pe(Ce, Be, ve);
                    Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p([u, Oe]));
                  }
                  return Se;
                }
                case "DebuggerStatement":
                  return ["debugger", Ye];
                case "ClassDeclaration":
                case "ClassExpression":
                  return U(Ce, Be, ve);
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "MethodDefinition":
                  return Z(Ce, Be, ve);
                case "ClassProperty":
                case "PropertyDefinition":
                case "ClassPrivateProperty":
                case "ClassAccessorProperty":
                case "AccessorProperty":
                  return se(Ce, Be, ve);
                case "TemplateElement":
                  return y(be.value.raw);
                case "TemplateLiteral":
                  return ue(Ce, ve, Be);
                case "TaggedTemplateExpression":
                  return [ve("tag"), ve("typeParameters"), ve("quasi")];
                case "PrivateIdentifier":
                  return ["#", ve("name")];
                case "PrivateName":
                  return ["#", ve("id")];
                case "InterpreterDirective":
                  return Se.push("#!", be.value, u), P(be, Be) && Se.push(u), Se;
                case "TopicReference":
                  return "%";
                case "ArgumentPlaceholder":
                  return "?";
                case "ModuleExpression": {
                  Se.push("module {");
                  let Ie = ve("body");
                  return Ie && Se.push(p([u, Ie]), u), Se.push("}"), Se;
                }
                default:
                  throw new Error("unknown type: " + JSON.stringify(be.type));
              }
            }
            function ye(Ce) {
              return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
            }
            r.exports = { preprocess: _, print: G, embed: h, insertPragma: c, massageAstNode: g, hasPrettierIgnore(Ce) {
              return D(Ce) || M(Ce);
            }, willPrintOwnComments: f2.willPrintOwnComments, canAttachComment: ye, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f2.handleOwnLineComment, endOfLine: f2.handleEndOfLineComment, remaining: f2.handleRemainingComment }, getCommentChildNodes: f2.getCommentChildNodes };
          } }), Ed = te({ "src/language-js/printer-estree-json.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t, indent: s, join: a2 } } = qe(), n = Fo();
            function u(y, h, g) {
              let c = y.getValue();
              switch (c.type) {
                case "JsonRoot":
                  return [g("node"), t];
                case "ArrayExpression": {
                  if (c.elements.length === 0)
                    return "[]";
                  let f2 = y.map(() => y.getValue() === null ? "null" : g(), "elements");
                  return ["[", s([t, a2([",", t], f2)]), t, "]"];
                }
                case "ObjectExpression":
                  return c.properties.length === 0 ? "{}" : ["{", s([t, a2([",", t], y.map(g, "properties"))]), t, "}"];
                case "ObjectProperty":
                  return [g("key"), ": ", g("value")];
                case "UnaryExpression":
                  return [c.operator === "+" ? "" : c.operator, g("argument")];
                case "NullLiteral":
                  return "null";
                case "BooleanLiteral":
                  return c.value ? "true" : "false";
                case "StringLiteral":
                  return JSON.stringify(c.value);
                case "NumericLiteral":
                  return i(y) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
                case "Identifier":
                  return i(y) ? JSON.stringify(c.name) : c.name;
                case "TemplateLiteral":
                  return g(["quasis", 0]);
                case "TemplateElement":
                  return JSON.stringify(c.value.cooked);
                default:
                  throw new Error("unknown type: " + JSON.stringify(c.type));
              }
            }
            function i(y) {
              return y.getName() === "key" && y.getParentNode().type === "ObjectProperty";
            }
            var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
            function p(y, h) {
              let { type: g } = y;
              if (g === "ObjectProperty") {
                let { key: c } = y;
                c.type === "Identifier" ? h.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (h.key = { type: "StringLiteral", value: String(c.value) });
                return;
              }
              if (g === "UnaryExpression" && y.operator === "+")
                return h.argument;
              if (g === "ArrayExpression") {
                for (let [c, f2] of y.elements.entries())
                  f2 === null && h.elements.splice(c, 0, { type: "NullLiteral" });
                return;
              }
              if (g === "TemplateLiteral")
                return { type: "StringLiteral", value: y.quasis[0].value.cooked };
            }
            p.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p };
          } }), Mt = te({ "src/common/common-options.js"(e, r) {
            "use strict";
            ne();
            var t = "Common";
            r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
          } }), Fd = te({ "src/language-js/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt(), s = "JavaScript";
            r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
          } }), Ad = te({ "src/language-js/parse/parsers.js"() {
            ne();
          } }), Ln = te({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
            r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
          } }), Sd = te({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
            r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
          } }), xd = te({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
            r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
          } }), wa = te({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
            r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
          } }), bd = te({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
            r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
          } }), Td = te({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
            r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
          } }), Bd = te({ "src/language-js/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Cd(), a2 = Ed(), n = Fd(), u = Ad(), i = [t(Ln(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(Ln(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Ln(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Sd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(xd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(wa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(wa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((y) => y !== ".jsonl") })), t(bd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t(Td(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a2 };
            r.exports = { languages: i, options: n, printers: l, parsers: u };
          } }), Nd = te({ "src/language-css/clean.js"(e, r) {
            "use strict";
            ne();
            var { isFrontMatterNode: t } = Ue(), s = lt(), a2 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
            function n(i, l, p) {
              if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i))
                return null;
              if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h, g) => {
                let c = Number(h);
                return Number.isNaN(c) ? y : c + g.toLowerCase();
              })), i.type === "selector-tag") {
                let y = i.value.toLowerCase();
                ["from", "to"].includes(y) && (l.value = y);
              }
              if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
                let y = i.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
                y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
              }
              if (i.type === "value-comma_group" && i.groups.some((y) => y.type === "value-atword" && y.value.endsWith("[") || y.type === "value-word" && y.value.startsWith("]")))
                return { type: "value-atword", value: i.groups.map((y) => y.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
            }
            n.ignoredProperties = a2;
            function u(i) {
              return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
            }
            r.exports = n;
          } }), su = te({ "src/utils/front-matter/print.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t, markAsRoot: s } } = qe();
            function a2(n, u) {
              if (n.lang === "yaml") {
                let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
                return s([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
              }
            }
            r.exports = a2;
          } }), wd = te({ "src/language-css/embed.js"(e, r) {
            "use strict";
            ne();
            var { builders: { hardline: t } } = qe(), s = su();
            function a2(n, u, i) {
              let l = n.getValue();
              if (l.type === "front-matter") {
                let p = s(l, i);
                return p ? [p, t] : "";
              }
            }
            r.exports = a2;
          } }), _o = te({ "src/utils/front-matter/parse.js"(e, r) {
            "use strict";
            ne();
            var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
            function s(a2) {
              let n = a2.match(t);
              if (!n)
                return { content: a2 };
              let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n.groups, y = i.trim() || "yaml";
              if (u === "+++" && (y = "toml"), y !== "yaml" && u !== p)
                return { content: a2 };
              let [h] = n;
              return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: p, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + a2.slice(h.length) };
            }
            r.exports = s;
          } }), _d = te({ "src/language-css/pragma.js"(e, r) {
            "use strict";
            ne();
            var t = Co(), s = _o();
            function a2(u) {
              return t.hasPragma(s(u).content);
            }
            function n(u) {
              let { frontMatter: i, content: l } = s(u);
              return (i ? i.raw + `

` : "") + t.insertPragma(l);
            }
            r.exports = { hasPragma: a2, insertPragma: n };
          } }), Pd = te({ "src/language-css/utils/index.js"(e, r) {
            "use strict";
            ne();
            var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
            function s(z, U) {
              let Z = Array.isArray(U) ? U : [U], se = -1, fe;
              for (; fe = z.getParentNode(++se); )
                if (Z.includes(fe.type))
                  return se;
              return -1;
            }
            function a2(z, U) {
              let Z = s(z, U);
              return Z === -1 ? null : z.getParentNode(Z);
            }
            function n(z) {
              var U;
              let Z = a2(z, "css-decl");
              return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();
            }
            var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
            function i(z) {
              return u.has(z.toLowerCase());
            }
            function l(z, U) {
              let Z = a2(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U.toLowerCase());
            }
            function p(z) {
              return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
            }
            function y(z, U) {
              var Z;
              let se = a2(z, "value-func");
              return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;
            }
            function h(z) {
              var U;
              let Z = a2(z, "css-rule"), se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;
              return se && (se.startsWith(":import") || se.startsWith(":export"));
            }
            function g(z, U) {
              let Z = Array.isArray(U) ? U : [U], se = a2(z, "css-atrule");
              return se && Z.includes(se.name.toLowerCase());
            }
            function c(z) {
              let U = z.getValue(), Z = a2(z, "css-atrule");
              return (Z == null ? void 0 : Z.name) === "import" && U.groups[0].value === "url" && U.groups.length === 2;
            }
            function f2(z) {
              return z.type === "value-func" && z.value.toLowerCase() === "url";
            }
            function F(z, U) {
              var Z;
              let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
              return se && se.indexOf(U) === se.length - 1;
            }
            function _(z) {
              let { selector: U } = z;
              return U ? typeof U == "string" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : false;
            }
            function w(z) {
              return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
            }
            function E(z) {
              return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
            }
            function N(z) {
              return z.type === "value-word" && z.value === "in";
            }
            function x(z) {
              return z.type === "value-operator" && z.value === "*";
            }
            function I(z) {
              return z.type === "value-operator" && z.value === "/";
            }
            function P(z) {
              return z.type === "value-operator" && z.value === "+";
            }
            function $(z) {
              return z.type === "value-operator" && z.value === "-";
            }
            function D(z) {
              return z.type === "value-operator" && z.value === "%";
            }
            function T(z) {
              return x(z) || I(z) || P(z) || $(z) || D(z);
            }
            function m(z) {
              return z.type === "value-word" && ["==", "!="].includes(z.value);
            }
            function C(z) {
              return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
            }
            function o(z) {
              return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
            }
            function d(z) {
              var U;
              return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\(\s*\)$/.test(z.raws.params);
            }
            function v(z) {
              return z.name.startsWith("prettier-placeholder");
            }
            function S(z) {
              return z.prop.startsWith("@prettier-placeholder");
            }
            function b(z, U) {
              return z.value === "$$" && z.type === "value-func" && (U == null ? void 0 : U.type) === "value-word" && !U.raws.before;
            }
            function B(z) {
              var U, Z;
              return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
            }
            function k(z) {
              var U, Z, se;
              return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
            }
            function M(z) {
              var U;
              return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === "";
            }
            function R(z) {
              var U, Z;
              return z.type === "value-comma_group" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
            }
            function q(z) {
              var U;
              return z.type === "value-paren_group" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);
            }
            function J(z) {
              var U;
              let Z = z.getValue();
              if (Z.groups.length === 0)
                return false;
              let se = z.getParentNode(1);
              if (!q(Z) && !(se && q(se)))
                return false;
              let fe = a2(z, "css-decl");
              return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith("$") || q(se) || se.type === "value-func");
            }
            function L(z) {
              return z.type === "value-comment" && z.inline;
            }
            function Q(z) {
              return z.type === "value-word" && z.value === "#";
            }
            function V(z) {
              return z.type === "value-word" && z.value === "{";
            }
            function j(z) {
              return z.type === "value-word" && z.value === "}";
            }
            function Y(z) {
              return ["value-word", "value-atword"].includes(z.type);
            }
            function ie(z) {
              return (z == null ? void 0 : z.type) === "value-colon";
            }
            function ee(z, U) {
              if (!R(U))
                return false;
              let { groups: Z } = U, se = Z.indexOf(z);
              return se === -1 ? false : ie(Z[se + 1]);
            }
            function ce(z) {
              return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
            }
            function W(z) {
              return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
            }
            function K(z) {
              return /\/\//.test(z.split(/[\n\r]/).pop());
            }
            function de(z) {
              return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
            }
            function ue(z, U) {
              var Z, se;
              if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
                return false;
              if (U.type === "value-comma_group") {
                let fe = U.groups.indexOf(z) - 1, ge = U.groups[fe];
                if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                  return true;
              }
              return false;
            }
            function Fe(z) {
              var U, Z;
              return z.type === "value-paren_group" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
            }
            r.exports = { getAncestorCounter: s, getAncestorNode: a2, getPropOfDeclNode: n, maybeToLowerCase: p, insideValueFunctionNode: y, insideICSSRuleNode: h, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: F, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N, isForKeywordNode: w, isURLFunctionNode: f2, isIfElseKeywordNode: E, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Q, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
          } }), Id = te({ "src/utils/line-column-to-index.js"(e, r) {
            "use strict";
            ne(), r.exports = function(t, s) {
              let a2 = 0;
              for (let n = 0; n < t.line - 1; ++n)
                a2 = s.indexOf(`
`, a2) + 1;
              return a2 + t.column;
            };
          } }), kd = te({ "src/language-css/loc.js"(e, r) {
            "use strict";
            ne();
            var { skipEverythingButNewLine: t } = Pr(), s = lt(), a2 = Id();
            function n(c, f2) {
              return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a2(c.source.start, f2) - 1 : null;
            }
            function u(c, f2) {
              if (c.type === "css-comment" && c.inline)
                return t(f2, c.source.startOffset);
              let F = c.nodes && s(c.nodes);
              return F && c.source && !c.source.end && (c = F), c.source && c.source.end ? a2(c.source.end, f2) : null;
            }
            function i(c, f2) {
              c.source && (c.source.startOffset = n(c, f2), c.source.endOffset = u(c, f2));
              for (let F in c) {
                let _ = c[F];
                F === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i(_, f2));
              }
            }
            function l(c, f2, F) {
              c.source && (c.source.startOffset = n(c, F) + f2, c.source.endOffset = u(c, F) + f2);
              for (let _ in c) {
                let w = c[_];
                _ === "source" || !w || typeof w != "object" || l(w, f2, F);
              }
            }
            function p(c) {
              let f2 = c.source.startOffset;
              return typeof c.prop == "string" && (f2 += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f2 += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f2 += c.raws.between.length), f2;
            }
            function y(c) {
              let f2 = "initial", F = "initial", _, w = false, E = [];
              for (let N = 0; N < c.length; N++) {
                let x = c[N];
                switch (f2) {
                  case "initial":
                    if (x === "'") {
                      f2 = "single-quotes";
                      continue;
                    }
                    if (x === '"') {
                      f2 = "double-quotes";
                      continue;
                    }
                    if ((x === "u" || x === "U") && c.slice(N, N + 4).toLowerCase() === "url(") {
                      f2 = "url", N += 3;
                      continue;
                    }
                    if (x === "*" && c[N - 1] === "/") {
                      f2 = "comment-block";
                      continue;
                    }
                    if (x === "/" && c[N - 1] === "/") {
                      f2 = "comment-inline", _ = N - 1;
                      continue;
                    }
                    continue;
                  case "single-quotes":
                    if (x === "'" && c[N - 1] !== "\\" && (f2 = F, F = "initial"), x === `
` || x === "\r")
                      return c;
                    continue;
                  case "double-quotes":
                    if (x === '"' && c[N - 1] !== "\\" && (f2 = F, F = "initial"), x === `
` || x === "\r")
                      return c;
                    continue;
                  case "url":
                    if (x === ")" && (f2 = "initial"), x === `
` || x === "\r")
                      return c;
                    if (x === "'") {
                      f2 = "single-quotes", F = "url";
                      continue;
                    }
                    if (x === '"') {
                      f2 = "double-quotes", F = "url";
                      continue;
                    }
                    continue;
                  case "comment-block":
                    x === "/" && c[N - 1] === "*" && (f2 = "initial");
                    continue;
                  case "comment-inline":
                    (x === '"' || x === "'" || x === "*") && (w = true), (x === `
` || x === "\r") && (w && E.push([_, N]), f2 = "initial", w = false);
                    continue;
                }
              }
              for (let [N, x] of E)
                c = c.slice(0, N) + c.slice(N, x).replace(/["'*]/g, " ") + c.slice(x);
              return c;
            }
            function h(c) {
              return c.source.startOffset;
            }
            function g(c) {
              return c.source.endOffset;
            }
            r.exports = { locStart: h, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
          } }), Ld = te({ "src/language-css/utils/is-less-parser.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              return s.parser === "css" || s.parser === "less";
            }
            r.exports = t;
          } }), Od = te({ "src/language-css/utils/is-scss.js"(e, r) {
            "use strict";
            ne();
            function t(s, a2) {
              return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a2);
            }
            r.exports = t;
          } }), jd = te({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
            r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
          } }), qd = te({ "src/language-css/utils/print-unit.js"(e, r) {
            "use strict";
            ne();
            var t = jd();
            function s(a2) {
              let n = a2.toLowerCase();
              return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a2;
            }
            r.exports = s;
          } }), Md = te({ "src/language-css/printer-postcss.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { printNumber: s, printString: a2, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue(), { builders: { join: p, line: y, hardline: h, softline: g, group: c, fill: f2, indent: F, dedent: _, ifBreak: w, breakParent: E }, utils: { removeLines: N, getDocParts: x } } = qe(), I = Nd(), P = wd(), { insertPragma: $ } = _d(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Q, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe, isColorAdjusterFuncNode: oe, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le } = Pd(), { locStart: Ae, locEnd: Ee } = kd(), De = Ld(), A2 = Od(), G = qd();
            function re(Te) {
              return Te.trailingComma === "es5" || Te.trailingComma === "all";
            }
            function ye(Te, je, Me) {
              let ae = Te.getValue();
              if (!ae)
                return "";
              if (typeof ae == "string")
                return ae;
              switch (ae.type) {
                case "front-matter":
                  return [ae.raw, h];
                case "css-root": {
                  let Ve = Ce(Te, je, Me), We = ae.raws.after.trim();
                  return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x(Ve).length > 0 ? h : ""];
                }
                case "css-comment": {
                  let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
                  return Ve ? We.trimEnd() : We;
                }
                case "css-rule":
                  return [Me("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? y : " ", "{", ae.nodes.length > 0 ? F([h, Ce(Te, je, Me)]) : "", h, "}", M(ae) ? ";" : ""] : ";"];
                case "css-decl": {
                  let Ve = Te.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st = Xe === ":", O = W(ae) ? N(Me("value")) : Me("value");
                  return !st && H(Xe) && (O = F([h, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(Te) ? ae.prop : m(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", F([g, Ce(Te, je, Me)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(Te, ae) ? w(";") : ";"];
                }
                case "css-atrule": {
                  let Ve = Te.getParentNode(), We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
                  if (De(je)) {
                    if (ae.mixin)
                      return [Me("selector"), ae.important ? " !important" : "", We ? "" : ";"];
                    if (ae.function)
                      return [ae.name, Me("params"), We ? "" : ";"];
                    if (ae.variable)
                      return ["@", ae.name, ": ", ae.value ? Me("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : "", We ? "" : ";"];
                  }
                  return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m(ae.name), ae.params ? [z(ae) ? "" : U(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [h, h] : /^\s*\n/.test(ae.raws.afterName) ? h : " " : " ", Me("params")] : "", ae.selector ? F([" ", Me("selector")]) : "", ae.value ? c([" ", Me("value"), k(ae) ? K(ae) ? " " : y : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? y : " ", "{", F([ae.nodes.length > 0 ? g : "", Ce(Te, je, Me)]), g, "}"] : We ? "" : ";"];
                }
                case "media-query-list": {
                  let Ve = [];
                  return Te.each((We) => {
                    let Xe = We.getValue();
                    Xe.type === "media-query" && Xe.value === "" || Ve.push(Me());
                  }, "nodes"), c(F(p(y, Ve)));
                }
                case "media-query":
                  return [p(" ", Te.map(Me, "nodes")), B(Te, ae) ? "" : ","];
                case "media-type":
                  return Oe(Se(ae.value, je));
                case "media-feature-expression":
                  return ae.nodes ? ["(", ...Te.map(Me, "nodes"), ")"] : ae.value;
                case "media-feature":
                  return m(Se(ae.value.replace(/ +/g, " "), je));
                case "media-colon":
                  return [ae.value, " "];
                case "media-value":
                  return Oe(Se(ae.value, je));
                case "media-keyword":
                  return Se(ae.value, je);
                case "media-url":
                  return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
                case "media-unknown":
                  return ae.value;
                case "selector-root":
                  return c([d(Te, "custom-selector") ? [D(Te, "css-atrule").customSelector, y] : "", p([",", d(Te, ["extend", "custom-selector", "nest"]) ? y : h], Te.map(Me, "nodes"))]);
                case "selector-selector":
                  return c(F(Te.map(Me, "nodes")));
                case "selector-comment":
                  return ae.value;
                case "selector-string":
                  return Se(ae.value, je);
                case "selector-tag": {
                  let Ve = Te.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
                  return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(Te, ae.value) ? ae.value.toLowerCase() : ae.value)];
                }
                case "selector-id":
                  return ["#", ae.value];
                case "selector-class":
                  return [".", Oe(Se(ae.value, je))];
                case "selector-attribute": {
                  var nt;
                  return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt = ae.operator) !== null && nt !== void 0 ? nt : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
                }
                case "selector-combinator": {
                  if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
                    let Xe = Te.getParentNode();
                    return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : y, ae.value, B(Te, ae) ? "" : " "];
                  }
                  let Ve = ae.value.trim().startsWith("(") ? y : "", We = Oe(Se(ae.value.trim(), je)) || y;
                  return [Ve, We];
                }
                case "selector-universal":
                  return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
                case "selector-pseudo":
                  return [m(ae.value), l(ae.nodes) ? c(["(", F([g, p([",", y], Te.map(Me, "nodes"))]), g, ")"]) : ""];
                case "selector-nesting":
                  return ae.value;
                case "selector-unknown": {
                  let Ve = D(Te, "css-rule");
                  if (Ve && Ve.isSCSSNesterProperty)
                    return Oe(Se(m(ae.value), je));
                  let We = Te.getParentNode();
                  if (We.raws && We.raws.selector) {
                    let st = Ae(We), O = st + We.raws.selector.length;
                    return je.originalText.slice(st, O).trim();
                  }
                  let Xe = Te.getParentNode(1);
                  if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                    let st = Ee(We.open) + 1, O = Ae(We.close), me = je.originalText.slice(st, O).trim();
                    return H(me) ? [E, me] : me;
                  }
                  return ae.value;
                }
                case "value-value":
                case "value-root":
                  return Me("group");
                case "value-comment":
                  return je.originalText.slice(Ae(ae), Ee(ae));
                case "value-comma_group": {
                  let Ve = Te.getParentNode(), We = Te.getParentNode(1), Xe = T(Te), st = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(Te, "css-atrule"), me = O && k(O), _e = ae.groups.some((at) => ge(at)), He = Te.map(Me, "groups"), Ge = [], it = C(Te, "url"), Qe = false, rt = false;
                  for (let at = 0; at < ae.groups.length; ++at) {
                    var tt;
                    Ge.push(He[at]);
                    let Ze = ae.groups[at - 1], Le = ae.groups[at], $e = ae.groups[at + 1], sr = ae.groups[at + 2];
                    if (it) {
                      ($e && Q($e) || Q(Le)) && Ge.push(" ");
                      continue;
                    }
                    if (d(Te, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e))
                      continue;
                    if (Le.type === "value-string" && Le.quoted) {
                      let $r = Le.value.lastIndexOf("#{"), Vr = Le.value.lastIndexOf("}");
                      $r !== -1 && Vr !== -1 ? Qe = $r > Vr : $r !== -1 ? Qe = true : Vr !== -1 && (Qe = false);
                    }
                    if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e))
                      continue;
                    let Rr = j(Le), ou = j($e);
                    if ((Rr && he($e) || ou && ke(Le)) && de($e) || !Ze && L(Le) || C(Te, "calc") && (Q(Le) || Q($e) || V(Le) || V($e)) && de($e))
                      continue;
                    let qo = (Q(Le) || V(Le)) && at === 0 && ($e.type === "value-number" || $e.isHex) && We && oe(We) && !de($e), lu = sr && sr.type === "value-func" || sr && Re(sr) || Le.type === "value-func" || Re(Le), cu = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
                    if (!(!(J($e) || J(Le)) && !C(Te, "calc") && !qo && (L($e) && !lu || L(Le) && !cu || Q($e) && !lu || Q(Le) && !cu || V($e) || V(Le)) && (de($e) || Rr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && Rr && Le.value === "-" && le($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
                      if (ge(Le)) {
                        if (Ve.type === "value-paren_group") {
                          Ge.push(_(h));
                          continue;
                        }
                        Ge.push(h);
                        continue;
                      }
                      if (me && (q($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {
                        Ge.push(" ");
                        continue;
                      }
                      if (O && O.name.toLowerCase() === "namespace") {
                        Ge.push(" ");
                        continue;
                      }
                      if (st) {
                        Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(h), rt = true) : Ge.push(" ");
                        continue;
                      }
                      if (ou) {
                        Ge.push(" ");
                        continue;
                      }
                      if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
                        if (pe(Le) && le($e) && Ee(Le) === Ae($e.open)) {
                          Ge.push(g);
                          continue;
                        }
                        if (Le.value === "with" && le($e)) {
                          Ge.push(" ");
                          continue;
                        }
                        (tt = Le.value) !== null && tt !== void 0 && tt.endsWith("#") && $e.value === "{" && le($e.group) || Ge.push(y);
                      }
                    }
                  }
                  return _e && Ge.push(E), rt && Ge.unshift(h), me ? c(F(Ge)) : v(Te) ? c(f2(Ge)) : c(F(f2(Ge)));
                }
                case "value-paren_group": {
                  let Ve = Te.getParentNode();
                  if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:")))
                    return [ae.open ? Me("open") : "", p(",", Te.map(Me, "groups")), ae.close ? Me("close") : ""];
                  if (!ae.open) {
                    let it = Te.map(Me, "groups"), Qe = [];
                    for (let rt = 0; rt < it.length; rt++)
                      rt !== 0 && Qe.push([",", y]), Qe.push(it[rt]);
                    return c(F(f2(Qe)));
                  }
                  let We = fe(Te), Xe = t(ae.groups), st = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me = X(ae, Ve), _e = me || We && !O, He = me || O, Ge = c([ae.open ? Me("open") : "", F([g, p([y], Te.map((it, Qe) => {
                    let rt = it.getValue(), at = Qe === ae.groups.length - 1, Ze = [Me(), at ? "" : ","];
                    if (ue(rt) && rt.type === "value-comma_group" && rt.groups && rt.groups[0].type !== "value-paren_group" && rt.groups[2] && rt.groups[2].type === "value-paren_group") {
                      let Le = x(Ze[0].contents.contents);
                      Le[1] = c(Le[1]), Ze = [c(_(Ze))];
                    }
                    if (!at && rt.type === "value-comma_group" && l(rt.groups)) {
                      let Le = t(rt.groups);
                      !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(h);
                    }
                    return Ze;
                  }, "groups"))]), w(!st && A2(je.parser, je.originalText) && We && re(je) ? "," : ""), g, ae.close ? Me("close") : ""], { shouldBreak: _e });
                  return He ? _(Ge) : Ge;
                }
                case "value-func":
                  return [ae.value, d(Te, "supports") && Pe(ae) ? " " : "", Me("group")];
                case "value-paren":
                  return ae.value;
                case "value-number":
                  return [Je(ae.value), G(ae.unit)];
                case "value-operator":
                  return ae.value;
                case "value-word":
                  return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
                case "value-colon": {
                  let Ve = Te.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
                  return [ae.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(Te, "url") ? "" : y];
                }
                case "value-comma":
                  return [ae.value, " "];
                case "value-string":
                  return a2(ae.raws.quote + ae.value + ae.raws.quote, je);
                case "value-atword":
                  return ["@", ae.value];
                case "value-unicode-range":
                  return ae.value;
                case "value-unknown":
                  return ae.value;
                default:
                  throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
              }
            }
            function Ce(Te, je, Me) {
              let ae = [];
              return Te.each((nt, tt, Ve) => {
                let We = Ve[tt - 1];
                if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
                  let Xe = nt.getValue();
                  ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
                } else
                  ae.push(Me());
                tt !== Ve.length - 1 && (Ve[tt + 1].type === "css-comment" && !n(je.originalText, Ae(Ve[tt + 1]), { backwards: true }) && !u(Ve[tt]) || Ve[tt + 1].type === "css-atrule" && Ve[tt + 1].name === "else" && Ve[tt].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? y : h), i(je.originalText, nt.getValue(), Ee) && !u(Ve[tt]) && ae.push(h)));
              }, "nodes"), ae;
            }
            var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, be = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${be.source})?(${ve.source})(${ze.source})?`, "g");
            function Se(Te, je) {
              return Te.replace(Be, (Me) => a2(Me, je));
            }
            function Ie(Te, je) {
              let Me = je.singleQuote ? "'" : '"';
              return Te.includes('"') || Te.includes("'") ? Te : Me + Te + Me;
            }
            function Oe(Te) {
              return Te.replace(Ye, (je, Me, ae, nt, tt) => !ae && nt ? Je(nt) + m(tt || "") : je);
            }
            function Je(Te) {
              return s(Te).replace(/\.0(?=$|e)/, "");
            }
            r.exports = { print: ye, embed: P, insertPragma: $, massageAstNode: I };
          } }), Rd = te({ "src/language-css/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { singleQuote: t.singleQuote };
          } }), $d = te({ "src/language-css/parsers.js"() {
            ne();
          } }), Vd = te({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
            r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
          } }), Wd = te({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
            r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
          } }), Hd = te({ "node_modules/linguist-languages/data/Less.json"(e, r) {
            r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
          } }), Gd = te({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
            r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
          } }), Ud = te({ "src/language-css/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Md(), a2 = Rd(), n = $d(), u = [t(Vd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(Wd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Hd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Gd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
            r.exports = { languages: u, options: a2, printers: i, parsers: n };
          } }), Jd = te({ "src/language-handlebars/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a2) {
              return a2.loc.start.offset;
            }
            function s(a2) {
              return a2.loc.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), zd = te({ "src/language-handlebars/clean.js"(e, r) {
            "use strict";
            ne();
            function t(s, a2) {
              if (s.type === "TextNode") {
                let n = s.chars.trim();
                if (!n)
                  return null;
                a2.chars = n.replace(/[\t\n\f\r ]+/g, " ");
              }
              s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a2.value;
            }
            t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
          } }), Xd = te({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
            r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
          } }), Kd = te({ "src/language-handlebars/utils.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), s = Xd();
            function a2(x) {
              let I = x.getValue(), P = x.getParentNode(0);
              return !!(g(x, ["ElementNode"]) && t(P.children) === I || g(x, ["Block"]) && t(P.body) === I);
            }
            function n(x) {
              return x.toUpperCase() === x;
            }
            function u(x) {
              return h(x, ["ElementNode"]) && typeof x.tag == "string" && !x.tag.startsWith(":") && (n(x.tag[0]) || x.tag.includes("."));
            }
            var i = new Set(s);
            function l(x) {
              return i.has(x.toLowerCase()) && !n(x[0]);
            }
            function p(x) {
              return x.selfClosing === true || l(x.tag) || u(x) && x.children.every((I) => y(I));
            }
            function y(x) {
              return h(x, ["TextNode"]) && !/\S/.test(x.chars);
            }
            function h(x, I) {
              return x && I.includes(x.type);
            }
            function g(x, I) {
              let P = x.getParentNode(0);
              return h(P, I);
            }
            function c(x, I) {
              let P = _(x);
              return h(P, I);
            }
            function f2(x, I) {
              let P = w(x);
              return h(P, I);
            }
            function F(x, I) {
              var P, $, D, T;
              let m = x.getValue(), C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($ = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $ !== void 0 ? $ : [], d = o.indexOf(m);
              return d !== -1 && o[d + I];
            }
            function _(x) {
              let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              return F(x, -I);
            }
            function w(x) {
              return F(x, 1);
            }
            function E(x) {
              return h(x, ["MustacheCommentStatement"]) && typeof x.value == "string" && x.value.trim() === "prettier-ignore";
            }
            function N(x) {
              let I = x.getValue(), P = _(x, 2);
              return E(I) || E(P);
            }
            r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N, isLastNodeOfSiblings: a2, isNextNodeOfSomeType: f2, isNodeOfSomeType: h, isParentOfSomeType: g, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: y };
          } }), Yd = te({ "src/language-handlebars/printer-glimmer.js"(e, r) {
            "use strict";
            ne();
            var { builders: { dedent: t, fill: s, group: a2, hardline: n, ifBreak: u, indent: i, join: l, line: p, softline: y }, utils: { getDocParts: h, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: c, isNonEmptyArray: f2 } = Ue(), { locStart: F, locEnd: _ } = Jd(), w = zd(), { getNextNode: E, getPreviousNode: N, hasPrettierIgnore: x, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = Kd(), o = 2;
            function d(H, pe, X) {
              let le = H.getValue();
              if (!le)
                return "";
              if (x(H))
                return pe.originalText.slice(F(le), _(le));
              let Ae = pe.singleQuote ? "'" : '"';
              switch (le.type) {
                case "Block":
                case "Program":
                case "Template":
                  return a2(H.map(X, "body"));
                case "ElementNode": {
                  let Ee = a2(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? y : "";
                  if (m(le))
                    return [Ee, De];
                  let A2 = ["</", le.tag, ">"];
                  return le.children.length === 0 ? [Ee, i(A2), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n, i(A2), De] : [Ee, i(a2(b(H, pe, X))), i(A2), De];
                }
                case "BlockStatement": {
                  let Ee = H.getParentNode(1);
                  return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a2([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
                }
                case "ElementModifierStatement":
                  return a2(["{{", Re(H, X), "}}"]);
                case "MustacheStatement":
                  return a2([k(le), Re(H, X), M(le)]);
                case "SubExpression":
                  return a2(["(", ke(H, X), y, ")"]);
                case "AttrNode": {
                  let Ee = le.value.type === "TextNode";
                  if (Ee && le.value.chars === "" && F(le.value) === _(le.value))
                    return le.name;
                  let A2 = Ee ? c(le.value.chars, Ae).quote : le.value.type === "ConcatStatement" ? c(le.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae).quote : "", G = X("value");
                  return [le.name, "=", A2, le.name === "class" && A2 ? a2(i(G)) : G, A2];
                }
                case "ConcatStatement":
                  return H.map(X, "parts");
                case "Hash":
                  return l(p, H.map(X, "pairs"));
                case "HashPair":
                  return [le.key, "=", X("value")];
                case "TextNode": {
                  let Ee = le.chars.replace(/{{/g, "\\{{"), De = U(H);
                  if (De) {
                    if (De === "class") {
                      let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
                      return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p : "", Ye, Ie ? p : ""];
                    }
                    return g(Ee);
                  }
                  let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N(H), ye = !E(H);
                  if (pe.htmlWhitespaceSensitivity !== "ignore") {
                    let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye && D(H, ["Template"]), Oe = re && D(H, ["Template"]);
                    if (G) {
                      if (Oe || Ie)
                        return "";
                      let ae = [p], nt = Z(Ee);
                      return nt && (ae = ge(nt)), I(H) && (ae = ae.map((tt) => t(tt))), ae;
                    }
                    let [Je] = Ee.match(Ye), [Te] = Ee.match(Se), je = [];
                    if (Je) {
                      je = [p];
                      let ae = Z(Je);
                      ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
                    }
                    let Me = [];
                    if (Te) {
                      if (!Ie) {
                        Me = [p];
                        let ae = Z(Te);
                        ae && (Me = ge(ae)), I(H) && (Me = Me.map((nt) => t(nt)));
                      }
                      Ee = Ee.replace(Se, "");
                    }
                    return [...je, s(Fe(Ee)), ...Me];
                  }
                  let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
                  if ((re || ye) && G && D(H, ["Block", "ElementNode", "Template"]))
                    return "";
                  G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                  let ze = "", be = "";
                  return ve === 0 && P(H, ["MustacheStatement"]) && (be = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye && (ve = 0, be = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, be), [...ge(Be), s(Fe(Ee)), ...ge(ve)];
                }
                case "MustacheCommentStatement": {
                  let Ee = F(le), De = _(le), A2 = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re = le.value.includes("}}") ? "--" : "";
                  return ["{{", A2 ? "~" : "", "!", re, le.value, re, G ? "~" : "", "}}"];
                }
                case "PathExpression":
                  return le.original;
                case "BooleanLiteral":
                  return String(le.value);
                case "CommentStatement":
                  return ["<!--", le.value, "-->"];
                case "StringLiteral": {
                  if (we(H)) {
                    let Ee = pe.singleQuote ? '"' : "'";
                    return he(le.value, Ee);
                  }
                  return he(le.value, Ae);
                }
                case "NumberLiteral":
                  return String(le.value);
                case "UndefinedLiteral":
                  return "undefined";
                case "NullLiteral":
                  return "null";
                default:
                  throw new Error("unknown glimmer type: " + JSON.stringify(le.type));
              }
            }
            function v(H, pe) {
              return F(H) - F(pe);
            }
            function S(H, pe) {
              let X = H.getValue(), le = ["attributes", "modifiers", "comments"].filter((Ee) => f2(X[Ee])), Ae = le.flatMap((Ee) => X[Ee]).sort(v);
              for (let Ee of le)
                H.each((De) => {
                  let A2 = Ae.indexOf(De.getValue());
                  Ae.splice(A2, 1, [p, pe()]);
                }, Ee);
              return f2(X.blockParams) && Ae.push(p, oe(X)), ["<", X.tag, i(Ae), B(X)];
            }
            function b(H, pe, X) {
              let Ae = H.getValue().children.every((Ee) => C(Ee));
              return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
                let A2 = X();
                return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [y, A2] : A2;
              }, "children");
            }
            function B(H) {
              return m(H) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
            }
            function k(H) {
              let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
              return [pe, X];
            }
            function M(H) {
              let pe = H.escaped === false ? "}}}" : "}}";
              return [H.strip && H.strip.close ? "~" : "", pe];
            }
            function R(H) {
              let pe = k(H), X = H.openStrip.open ? "~" : "";
              return [pe, X, "#"];
            }
            function q(H) {
              let pe = M(H);
              return [H.openStrip.close ? "~" : "", pe];
            }
            function J(H) {
              let pe = k(H), X = H.closeStrip.open ? "~" : "";
              return [pe, X, "/"];
            }
            function L(H) {
              let pe = M(H);
              return [H.closeStrip.close ? "~" : "", pe];
            }
            function Q(H) {
              let pe = k(H), X = H.inverseStrip.open ? "~" : "";
              return [pe, X];
            }
            function V(H) {
              let pe = M(H);
              return [H.inverseStrip.close ? "~" : "", pe];
            }
            function j(H, pe) {
              let X = H.getValue(), le = [], Ae = Pe(H, pe);
              return Ae && le.push(a2(Ae)), f2(X.program.blockParams) && le.push(oe(X.program)), a2([R(X), Ne(H, pe), le.length > 0 ? i([p, l(p, le)]) : "", y, q(X)]);
            }
            function Y(H, pe) {
              return [pe.htmlWhitespaceSensitivity === "ignore" ? n : "", Q(H), "else", V(H)];
            }
            function ie(H, pe, X) {
              let le = H.getValue(), Ae = H.getParentNode(1);
              return a2([Q(Ae), ["else", " ", X], i([p, a2(Pe(H, pe)), ...f2(le.program.blockParams) ? [p, oe(le.program)] : []]), y, V(Ae)]);
            }
            function ee(H, pe, X) {
              let le = H.getValue();
              return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le) ? y : n, J(le), pe("path"), L(le)] : [J(le), pe("path"), L(le)];
            }
            function ce(H) {
              return $(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
            }
            function W(H) {
              return K(H) && H.inverse.body.length === 1 && $(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
            }
            function K(H) {
              return $(H, ["BlockStatement"]) && H.inverse;
            }
            function de(H, pe, X) {
              let le = H.getValue();
              if (ce(le))
                return "";
              let Ae = pe("program");
              return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae]) : i(Ae);
            }
            function ue(H, pe, X) {
              let le = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae] : Ae;
              return W(le) ? Ee : K(le) ? [Y(le, X), i(Ee)] : "";
            }
            function Fe(H) {
              return h(l(p, z(H)));
            }
            function z(H) {
              return H.split(/[\t\n\f\r ]+/);
            }
            function U(H) {
              for (let pe = 0; pe < 2; pe++) {
                let X = H.getParentNode(pe);
                if (X && X.type === "AttrNode")
                  return X.name.toLowerCase();
              }
            }
            function Z(H) {
              return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
            }
            function se(H) {
              H = typeof H == "string" ? H : "";
              let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
              return Z(pe);
            }
            function fe(H) {
              H = typeof H == "string" ? H : "";
              let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
              return Z(pe);
            }
            function ge() {
              let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return Array.from({ length: Math.min(H, o) }).fill(n);
            }
            function he(H, pe) {
              let { quote: X, regex: le } = c(H, pe);
              return [X, H.replace(le, `\\${X}`), X];
            }
            function we(H) {
              let pe = 0, X = H.getParentNode(pe);
              for (; X && $(X, ["SubExpression"]); )
                pe++, X = H.getParentNode(pe);
              return !!(X && $(H.getParentNode(pe + 1), ["ConcatStatement"]) && $(H.getParentNode(pe + 2), ["AttrNode"]));
            }
            function ke(H, pe) {
              let X = Ne(H, pe), le = Pe(H, pe);
              return le ? i([X, p, a2(le)]) : X;
            }
            function Re(H, pe) {
              let X = Ne(H, pe), le = Pe(H, pe);
              return le ? [i([X, p, le]), y] : X;
            }
            function Ne(H, pe) {
              return pe("path");
            }
            function Pe(H, pe) {
              let X = H.getValue(), le = [];
              if (X.params.length > 0) {
                let Ae = H.map(pe, "params");
                le.push(...Ae);
              }
              if (X.hash && X.hash.pairs.length > 0) {
                let Ae = pe("hash");
                le.push(Ae);
              }
              return le.length === 0 ? "" : l(p, le);
            }
            function oe(H) {
              return ["as |", H.blockParams.join(" "), "|"];
            }
            r.exports = { print: d, massageAstNode: w };
          } }), Qd = te({ "src/language-handlebars/parsers.js"() {
            ne();
          } }), Zd = te({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
            r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
          } }), eg = te({ "src/language-handlebars/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Yd(), a2 = Qd(), n = [t(Zd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
            r.exports = { languages: n, printers: u, parsers: a2 };
          } }), tg = te({ "src/language-graphql/pragma.js"(e, r) {
            "use strict";
            ne();
            function t(a2) {
              return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a2);
            }
            function s(a2) {
              return `# @format

` + a2;
            }
            r.exports = { hasPragma: t, insertPragma: s };
          } }), rg = te({ "src/language-graphql/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a2) {
              return typeof a2.start == "number" ? a2.start : a2.loc && a2.loc.start;
            }
            function s(a2) {
              return typeof a2.end == "number" ? a2.end : a2.loc && a2.loc.end;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), ng = te({ "src/language-graphql/printer-graphql.js"(e, r) {
            "use strict";
            ne();
            var { builders: { join: t, hardline: s, line: a2, softline: n, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: y } = Ue(), { insertPragma: h } = tg(), { locStart: g, locEnd: c } = rg();
            function f2(P, $, D) {
              let T = P.getValue();
              if (!T)
                return "";
              if (typeof T == "string")
                return T;
              switch (T.kind) {
                case "Document": {
                  let m = [];
                  return P.each((C, o, d) => {
                    m.push(D()), o !== d.length - 1 && (m.push(s), p($.originalText, C.getValue(), c) && m.push(s));
                  }, "definitions"), [...m, s];
                }
                case "OperationDefinition": {
                  let m = $.originalText[g(T)] !== "{", C = Boolean(T.name);
                  return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && y(T.variableDefinitions) ? " " : "", y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
                }
                case "FragmentDefinition":
                  return ["fragment ", D("name"), y(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), F(P, D, T), " ", D("selectionSet")];
                case "SelectionSet":
                  return ["{", i([s, t(s, _(P, $, D, "selections"))]), s, "}"];
                case "Field":
                  return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", F(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
                case "Name":
                  return T.value;
                case "StringValue": {
                  if (T.block) {
                    let m = T.value.replace(/"""/g, "\\$&").split(`
`);
                    return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
                  }
                  return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
                }
                case "IntValue":
                case "FloatValue":
                case "EnumValue":
                  return T.value;
                case "BooleanValue":
                  return T.value ? "true" : "false";
                case "NullValue":
                  return "null";
                case "Variable":
                  return ["$", D("name")];
                case "ListValue":
                  return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
                case "ObjectValue":
                  return u(["{", $.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
                case "ObjectField":
                case "Argument":
                  return [D("name"), ": ", D("value")];
                case "Directive":
                  return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : ""];
                case "NamedType":
                  return D("name");
                case "VariableDefinition":
                  return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
                case "ObjectTypeExtension":
                case "ObjectTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "FieldDefinition":
                  return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), F(P, D, T)];
                case "DirectiveDefinition":
                  return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
                case "EnumTypeExtension":
                case "EnumTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), F(P, D, T), T.values.length > 0 ? [" {", i([s, t(s, _(P, $, D, "values"))]), s, "}"] : ""];
                case "EnumValueDefinition":
                  return [D("description"), T.description ? s : "", D("name"), F(P, D, T)];
                case "InputValueDefinition":
                  return [D("description"), T.description ? T.description.block ? s : a2 : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", F(P, D, T)];
                case "InputObjectTypeExtension":
                case "InputObjectTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "SchemaExtension":
                  return ["extend schema", F(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t(s, _(P, $, D, "operationTypes"))]), s, "}"] : []];
                case "SchemaDefinition":
                  return [D("description"), T.description ? s : "", "schema", F(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t(s, _(P, $, D, "operationTypes"))]) : "", s, "}"];
                case "OperationTypeDefinition":
                  return [D("operation"), ": ", D("type")];
                case "InterfaceTypeExtension":
                case "InterfaceTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $, D)] : "", F(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $, D, "fields"))]), s, "}"] : ""];
                case "FragmentSpread":
                  return ["...", D("name"), F(P, D, T)];
                case "InlineFragment":
                  return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", F(P, D, T), " ", D("selectionSet")];
                case "UnionTypeExtension":
                case "UnionTypeDefinition":
                  return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), F(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a2, "  "]), t([a2, "| "], P.map(D, "types"))])] : ""])]);
                case "ScalarTypeExtension":
                case "ScalarTypeDefinition":
                  return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), F(P, D, T)];
                case "NonNullType":
                  return [D("type"), "!"];
                case "ListType":
                  return ["[", D("type"), "]"];
                default:
                  throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
              }
            }
            function F(P, $, D) {
              if (D.directives.length === 0)
                return "";
              let T = t(a2, P.map($, "directives"));
              return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a2, T]) : [" ", u(i([n, T]))];
            }
            function _(P, $, D, T) {
              return P.map((m, C, o) => {
                let d = D();
                return C < o.length - 1 && p($.originalText, m.getValue(), c) ? [d, s] : d;
              }, T);
            }
            function w(P) {
              return P.kind && P.kind !== "Comment";
            }
            function E(P) {
              let $ = P.getValue();
              if ($.kind === "Comment")
                return "#" + $.value.trimEnd();
              throw new Error("Not a comment: " + JSON.stringify($));
            }
            function N(P, $, D) {
              let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((d) => D(d), "interfaces");
              for (let d = 0; d < C.length; d++) {
                let v = C[d];
                m.push(o[d]);
                let S = C[d + 1];
                if (S) {
                  let b = $.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                  m.push(k === "," ? "," : " &", B ? a2 : " ");
                }
              }
              return m;
            }
            function x(P, $) {
              P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($.value = $.value.trim());
            }
            x.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
            function I(P) {
              var $;
              let D = P.getValue();
              return D == null || ($ = D.comments) === null || $ === void 0 ? void 0 : $.some((T) => T.value.trim() === "prettier-ignore");
            }
            r.exports = { print: f2, massageAstNode: x, hasPrettierIgnore: I, insertPragma: h, printComment: E, canAttachComment: w };
          } }), ug = te({ "src/language-graphql/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { bracketSpacing: t.bracketSpacing };
          } }), sg = te({ "src/language-graphql/parsers.js"() {
            ne();
          } }), ig = te({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
            r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
          } }), ag = te({ "src/language-graphql/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = ng(), a2 = ug(), n = sg(), u = [t(ig(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
            r.exports = { languages: u, options: a2, printers: i, parsers: n };
          } }), Po = te({ "node_modules/collapse-white-space/index.js"(e, r) {
            "use strict";
            ne(), r.exports = t;
            function t(s) {
              return String(s).replace(/\s+/g, " ");
            }
          } }), Io = te({ "src/language-markdown/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a2) {
              return a2.position.start.offset;
            }
            function s(a2) {
              return a2.position.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), og = te({ "src/language-markdown/constants.evaluate.js"(e, r) {
            r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
          } }), iu = te({ "src/language-markdown/utils.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t } = Ue(), { locStart: s, locEnd: a2 } = Io(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = og(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h = new RegExp(i);
            function g(E, N) {
              let x = "non-cjk", I = "cj-letter", P = "k-letter", $ = "cjk-punctuation", D = [], T = (N.proseWrap === "preserve" ? E : E.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
              for (let [C, o] of T.entries()) {
                if (C % 2 === 1) {
                  D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                  continue;
                }
                if ((C === 0 || C === T.length - 1) && o === "")
                  continue;
                let d = o.split(new RegExp(`(${n})`));
                for (let [v, S] of d.entries())
                  if (!((v === 0 || v === d.length - 1) && S === "")) {
                    if (v % 2 === 0) {
                      S !== "" && m({ type: "word", value: S, kind: x, hasLeadingPunctuation: h.test(S[0]), hasTrailingPunctuation: h.test(t(S)) });
                      continue;
                    }
                    m(h.test(S) ? { type: "word", value: S, kind: $, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: y.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                  }
              }
              return D;
              function m(C) {
                let o = t(D);
                o && o.type === "word" && (o.kind === x && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !d(x, $) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
                function d(v, S) {
                  return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
                }
              }
            }
            function c(E, N) {
              let [, x, I, P] = N.slice(E.position.start.offset, E.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
              return { numberText: x, marker: I, leadingSpaces: P };
            }
            function f2(E, N) {
              if (!E.ordered || E.children.length < 2)
                return false;
              let x = Number(c(E.children[0], N.originalText).numberText), I = Number(c(E.children[1], N.originalText).numberText);
              if (x === 0 && E.children.length > 2) {
                let P = Number(c(E.children[2], N.originalText).numberText);
                return I === 1 && P === 1;
              }
              return I === 1;
            }
            function F(E, N) {
              let { value: x } = E;
              return E.position.end.offset === N.length && x.endsWith(`
`) && N.endsWith(`
`) ? x.slice(0, -1) : x;
            }
            function _(E, N) {
              return function x(I, P, $) {
                let D = Object.assign({}, N(I, P, $));
                return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$]))), D;
              }(E, null, []);
            }
            function w(E) {
              if ((E == null ? void 0 : E.type) !== "link" || E.children.length !== 1)
                return false;
              let [N] = E.children;
              return s(E) === s(N) && a2(E) === a2(N);
            }
            r.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: F, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f2, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
          } }), lg = te({ "src/language-markdown/embed.js"(e, r) {
            "use strict";
            ne();
            var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a2, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe(), i = su(), { getFencedCodeBlockValue: l } = iu();
            function p(y, h, g, c) {
              let f2 = y.getValue();
              if (f2.type === "code" && f2.lang !== null) {
                let F = t(f2.lang, c);
                if (F) {
                  let _ = c.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f2.value, _) + 1)), E = { parser: F };
                  f2.lang === "tsx" && (E.filepath = "dummy.tsx");
                  let N = g(l(f2, c.originalText), E, { stripTrailingHardline: true });
                  return n([w, f2.lang, f2.meta ? " " + f2.meta : "", a2, u(N), a2, w]);
                }
              }
              switch (f2.type) {
                case "front-matter":
                  return i(f2, g);
                case "importExport":
                  return [g(f2.value, { parser: "babel" }, { stripTrailingHardline: true }), a2];
                case "jsx":
                  return g(`<$>${f2.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
              }
              return null;
            }
            r.exports = p;
          } }), ko = te({ "src/language-markdown/pragma.js"(e, r) {
            "use strict";
            ne();
            var t = _o(), s = ["format", "prettier"];
            function a2(n) {
              let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
              return (l == null ? void 0 : l.index) === 0;
            }
            r.exports = { startWithPragma: a2, hasPragma: (n) => a2(t(n).content.trimStart()), insertPragma: (n) => {
              let u = t(n), i = `<!-- @${s[0]} -->`;
              return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
            } };
          } }), cg = te({ "src/language-markdown/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var t = lt(), { getOrderedListItemInfo: s, mapAst: a2, splitText: n } = iu(), u = /^.$/su;
            function i(w, E) {
              return w = y(w, E), w = c(w), w = p(w, E), w = F(w, E), w = _(w, E), w = f2(w, E), w = l(w), w = h(w), w;
            }
            function l(w) {
              return a2(w, (E) => E.type !== "import" && E.type !== "export" ? E : Object.assign(Object.assign({}, E), {}, { type: "importExport" }));
            }
            function p(w, E) {
              return a2(w, (N) => N.type !== "inlineCode" || E.proseWrap === "preserve" ? N : Object.assign(Object.assign({}, N), {}, { value: N.value.replace(/\s+/g, " ") }));
            }
            function y(w, E) {
              return a2(w, (N) => N.type !== "text" || N.value === "*" || N.value === "_" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, { value: E.originalText.slice(N.position.start.offset, N.position.end.offset) }));
            }
            function h(w) {
              return g(w, (E, N) => E.type === "importExport" && N.type === "importExport", (E, N) => ({ type: "importExport", value: E.value + `

` + N.value, position: { start: E.position.start, end: N.position.end } }));
            }
            function g(w, E, N) {
              return a2(w, (x) => {
                if (!x.children)
                  return x;
                let I = x.children.reduce((P, $) => {
                  let D = t(P);
                  return D && E(D, $) ? P.splice(-1, 1, N(D, $)) : P.push($), P;
                }, []);
                return Object.assign(Object.assign({}, x), {}, { children: I });
              });
            }
            function c(w) {
              return g(w, (E, N) => E.type === "text" && N.type === "text", (E, N) => ({ type: "text", value: E.value + N.value, position: { start: E.position.start, end: N.position.end } }));
            }
            function f2(w, E) {
              return a2(w, (N, x, I) => {
                let [P] = I;
                if (N.type !== "text")
                  return N;
                let { value: $ } = N;
                return P.type === "paragraph" && (x === 0 && ($ = $.trimStart()), x === P.children.length - 1 && ($ = $.trimEnd())), { type: "sentence", position: N.position, children: n($, E) };
              });
            }
            function F(w, E) {
              return a2(w, (N, x, I) => {
                if (N.type === "code") {
                  let P = /^\n?(?: {4,}|\t)/.test(E.originalText.slice(N.position.start.offset, N.position.end.offset));
                  if (N.isIndented = P, P)
                    for (let $ = 0; $ < I.length; $++) {
                      let D = I[$];
                      if (D.hasIndentedCodeblock)
                        break;
                      D.type === "list" && (D.hasIndentedCodeblock = true);
                    }
                }
                return N;
              });
            }
            function _(w, E) {
              return a2(w, (I, P, $) => {
                if (I.type === "list" && I.children.length > 0) {
                  for (let D = 0; D < $.length; D++) {
                    let T = $[D];
                    if (T.type === "list" && !T.isAligned)
                      return I.isAligned = false, I;
                  }
                  I.isAligned = x(I);
                }
                return I;
              });
              function N(I) {
                return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
              }
              function x(I) {
                if (!I.ordered)
                  return true;
                let [P, $] = I.children;
                if (s(P, E.originalText).leadingSpaces.length > 1)
                  return true;
                let T = N(P);
                if (T === -1)
                  return false;
                if (I.children.length === 1)
                  return T % E.tabWidth === 0;
                let m = N($);
                return T !== m ? false : T % E.tabWidth === 0 ? true : s($, E.originalText).leadingSpaces.length > 1;
              }
            }
            r.exports = i;
          } }), pg = te({ "src/language-markdown/clean.js"(e, r) {
            "use strict";
            ne();
            var t = Po(), { isFrontMatterNode: s } = Ue(), { startWithPragma: a2 } = ko(), n = /* @__PURE__ */ new Set(["position", "raw"]);
            function u(i, l, p) {
              if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a2(i.value)))
                return null;
            }
            u.ignoredProperties = n, r.exports = u;
          } }), fg = te({ "src/language-markdown/printer-markdown.js"(e, r) {
            "use strict";
            ne();
            var t = Po(), { getLast: s, getMinNotPresentContinuousCount: a2, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue(), { builders: { breakParent: l, join: p, line: y, literalline: h, markAsRoot: g, hardline: c, softline: f2, ifBreak: F, fill: _, align: w, indent: E, group: N, hardlineWithoutBreakParent: x }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $ } } = qe(), D = lg(), { insertPragma: T } = ko(), { locStart: m, locEnd: C } = Io(), o = cg(), d = pg(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = iu(), q = /* @__PURE__ */ new Set(["importExport"]), J = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
            function Q(oe, H, pe) {
              let X = oe.getValue();
              if (ge(oe))
                return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le) => le.type === "word" ? le.value : le.value === "" ? "" : W(oe, le.value, H));
              switch (X.type) {
                case "front-matter":
                  return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                case "root":
                  return X.children.length === 0 ? "" : [I(de(oe, H, pe)), q.has(z(X).type) ? "" : c];
                case "paragraph":
                  return ue(oe, H, pe, { postprocessor: _ });
                case "sentence":
                  return ue(oe, H, pe);
                case "word": {
                  let le = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A2, G, re, ye) => (G ? `${A2}${G}` : `${re}${ye}`).replace(/_/g, "\\_")), Ae = (De, A2, G) => De.type === "sentence" && G === 0, Ee = (De, A2, G) => R(De.children[G - 1]);
                  return le !== X.value && (oe.match(void 0, Ae, Ee) || oe.match(void 0, Ae, (De, A2, G) => De.type === "emphasis" && G === 0, Ee)) && (le = le.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le;
                }
                case "whitespace": {
                  let le = oe.getParentNode(), Ae = le.children.indexOf(X), Ee = le.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
                  return W(oe, X.value, { proseWrap: De });
                }
                case "emphasis": {
                  let le;
                  if (R(X.children[0]))
                    le = H.originalText[X.position.start.offset];
                  else {
                    let Ae = oe.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A2 = Ae.children[Ee + 1];
                    le = De && De.type === "sentence" && De.children.length > 0 && s(De.children).type === "word" && !s(De.children).hasTrailingPunctuation || A2 && A2.type === "sentence" && A2.children.length > 0 && A2.children[0].type === "word" && !A2.children[0].hasLeadingPunctuation || ce(oe, "emphasis") ? "*" : "_";
                  }
                  return [le, ue(oe, H, pe), le];
                }
                case "strong":
                  return ["**", ue(oe, H, pe), "**"];
                case "delete":
                  return ["~~", ue(oe, H, pe), "~~"];
                case "inlineCode": {
                  let le = a2(X.value, "`"), Ae = "`".repeat(le || 1), Ee = le && !/^\s/.test(X.value) ? " " : "";
                  return [Ae, Ee, X.value, Ee, Ae];
                }
                case "wikiLink": {
                  let le = "";
                  return H.proseWrap === "preserve" ? le = X.value : le = X.value.replace(/[\t\n]+/g, " "), ["[[", le, "]]"];
                }
                case "link":
                  switch (H.originalText[X.position.start.offset]) {
                    case "<": {
                      let le = "mailto:";
                      return ["<", X.url.startsWith(le) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le.length) !== le ? X.url.slice(le.length) : X.url, ">"];
                    }
                    case "[":
                      return ["[", ue(oe, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
                    default:
                      return H.originalText.slice(X.position.start.offset, X.position.end.offset);
                  }
                case "image":
                  return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
                case "blockquote":
                  return ["> ", w("> ", ue(oe, H, pe))];
                case "heading":
                  return ["#".repeat(X.depth) + " ", ue(oe, H, pe)];
                case "code": {
                  if (X.isIndented) {
                    let Ee = " ".repeat(4);
                    return w(Ee, [Ee, ...P(X.value, c)]);
                  }
                  let le = H.__inJsTemplate ? "~" : "`", Ae = le.repeat(Math.max(3, n(X.value, le) + 1));
                  return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c, ...P(v(X, H.originalText), c), c, Ae];
                }
                case "html": {
                  let le = oe.getParentNode(), Ae = le.type === "root" && s(le.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
                  return P(Ae, Ee ? c : g(h));
                }
                case "list": {
                  let le = Y(X, oe.getParentNode()), Ae = S(X, H);
                  return ue(oe, H, pe, { processor: (Ee, De) => {
                    let A2 = re(), G = Ee.getValue();
                    if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column)
                      return [A2, V(Ee, H, pe, A2)];
                    return [A2, w(" ".repeat(A2.length), V(Ee, H, pe, A2))];
                    function re() {
                      let ye = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le % 2 === 0 ? ". " : ") ") : le % 2 === 0 ? "- " : "* ";
                      return X.isAligned || X.hasIndentedCodeblock ? j(ye, H) : ye;
                    }
                  } });
                }
                case "thematicBreak": {
                  let le = ee(oe, "list");
                  return le === -1 ? "---" : Y(oe.getParentNode(le), oe.getParentNode(le + 1)) % 2 === 0 ? "***" : "---";
                }
                case "linkReference":
                  return ["[", ue(oe, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
                case "imageReference":
                  switch (X.referenceType) {
                    case "full":
                      return ["![", X.alt || "", "]", Ne(X)];
                    default:
                      return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
                  }
                case "definition": {
                  let le = H.proseWrap === "always" ? y : " ";
                  return N([Ne(X), ":", E([le, he(X.url), X.title === null ? "" : [le, we(X.title, H, false)]])]);
                }
                case "footnote":
                  return ["[^", ue(oe, H, pe), "]"];
                case "footnoteReference":
                  return Pe(X);
                case "footnoteDefinition": {
                  let le = oe.getParentNode().children[oe.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
                  return [Pe(X), ": ", Ae ? ue(oe, H, pe) : N([w(" ".repeat(4), ue(oe, H, pe, { processor: (Ee, De) => De === 0 ? N([f2, pe()]) : pe() })), le && le.type === "footnoteDefinition" ? f2 : ""])];
                }
                case "table":
                  return K(oe, H, pe);
                case "tableCell":
                  return ue(oe, H, pe);
                case "break":
                  return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(h)] : ["\\", c];
                case "liquidNode":
                  return P(X.value, c);
                case "importExport":
                  return [X.value, c];
                case "esComment":
                  return ["{/* ", X.value, " */}"];
                case "jsx":
                  return X.value;
                case "math":
                  return ["$$", c, X.value ? [...P(X.value, c), c] : "", "$$"];
                case "inlineMath":
                  return H.originalText.slice(m(X), C(X));
                case "tableRow":
                case "listItem":
                default:
                  throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
              }
            }
            function V(oe, H, pe, X) {
              let le = oe.getValue(), Ae = le.checked === null ? "" : le.checked ? "[x] " : "[ ] ";
              return [Ae, ue(oe, H, pe, { processor: (Ee, De) => {
                if (De === 0 && Ee.getValue().type !== "list")
                  return w(" ".repeat(Ae.length), pe());
                let A2 = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
                return [A2, w(A2, pe())];
              } })];
            }
            function j(oe, H) {
              let pe = X();
              return oe + " ".repeat(pe >= 4 ? 0 : pe);
              function X() {
                let le = oe.length % H.tabWidth;
                return le === 0 ? 0 : H.tabWidth - le;
              }
            }
            function Y(oe, H) {
              return ie(oe, H, (pe) => pe.ordered === oe.ordered);
            }
            function ie(oe, H, pe) {
              let X = -1;
              for (let le of H.children)
                if (le.type === oe.type && pe(le) ? X++ : X = -1, le === oe)
                  return X;
            }
            function ee(oe, H) {
              let pe = Array.isArray(H) ? H : [H], X = -1, le;
              for (; le = oe.getParentNode(++X); )
                if (pe.includes(le.type))
                  return X;
              return -1;
            }
            function ce(oe, H) {
              let pe = ee(oe, H);
              return pe === -1 ? null : oe.getParentNode(pe);
            }
            function W(oe, H, pe) {
              if (pe.proseWrap === "preserve" && H === `
`)
                return c;
              let X = pe.proseWrap === "always" && !ce(oe, J);
              return H !== "" ? X ? y : " " : X ? f2 : "";
            }
            function K(oe, H, pe) {
              let X = oe.getValue(), le = [], Ae = oe.map((ye) => ye.map((Ce, Be) => {
                let ve = $(pe(), H).formatted, ze = u(ve);
                return le[Be] = Math.max(le[Be] || 3, ze), { text: ve, width: ze };
              }, "children"), "children"), Ee = A2(false);
              if (H.proseWrap !== "never")
                return [l, Ee];
              let De = A2(true);
              return [l, N(F(De, Ee))];
              function A2(ye) {
                let Ce = [re(Ae[0], ye), G(ye)];
                return Ae.length > 1 && Ce.push(p(x, Ae.slice(1).map((Be) => re(Be, ye)))), p(x, Ce);
              }
              function G(ye) {
                return `| ${le.map((Be, ve) => {
                  let ze = X.align[ve], be = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye ? "-" : "-".repeat(Be - 2);
                  return `${be}${Se}${Ye}`;
                }).join(" | ")} |`;
              }
              function re(ye, Ce) {
                return `| ${ye.map((ve, ze) => {
                  let { text: be, width: Ye } = ve;
                  if (Ce)
                    return be;
                  let Se = le[ze] - Ye, Ie = X.align[ze], Oe = 0;
                  Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
                  let Je = Se - Oe;
                  return `${" ".repeat(Oe)}${be}${" ".repeat(Je)}`;
                }).join(" | ")} |`;
              }
            }
            function de(oe, H, pe) {
              let X = [], le = null, { children: Ae } = oe.getValue();
              for (let [Ee, De] of Ae.entries())
                switch (U(De)) {
                  case "start":
                    le === null && (le = { index: Ee, offset: De.position.end.offset });
                    break;
                  case "end":
                    le !== null && (X.push({ start: le, end: { index: Ee, offset: De.position.start.offset } }), le = null);
                    break;
                  default:
                    break;
                }
              return ue(oe, H, pe, { processor: (Ee, De) => {
                if (X.length > 0) {
                  let A2 = X[0];
                  if (De === A2.start.index)
                    return [Fe(Ae[A2.start.index]), H.originalText.slice(A2.start.offset, A2.end.offset), Fe(Ae[A2.end.index])];
                  if (A2.start.index < De && De < A2.end.index)
                    return false;
                  if (De === A2.end.index)
                    return X.shift(), false;
                }
                return pe();
              } });
            }
            function ue(oe, H, pe) {
              let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le } = X, Ae = X.processor || (() => pe()), Ee = oe.getValue(), De = [], A2;
              return oe.each((G, re) => {
                let ye = G.getValue(), Ce = Ae(G, re);
                if (Ce !== false) {
                  let Be = { parts: De, prevNode: A2, parentNode: Ee, options: H };
                  Z(ye, Be) && (De.push(c), A2 && q.has(A2.type) || (se(ye, Be) || fe(ye, Be)) && De.push(c), fe(ye, Be) && De.push(c)), De.push(Ce), A2 = ye;
                }
              }, "children"), le ? le(De) : De;
            }
            function Fe(oe) {
              if (oe.type === "html")
                return oe.value;
              if (oe.type === "paragraph" && Array.isArray(oe.children) && oe.children.length === 1 && oe.children[0].type === "esComment")
                return ["{/* ", oe.children[0].value, " */}"];
            }
            function z(oe) {
              let H = oe;
              for (; i(H.children); )
                H = s(H.children);
              return H;
            }
            function U(oe) {
              let H;
              if (oe.type === "html")
                H = oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
              else {
                let pe;
                oe.type === "esComment" ? pe = oe : oe.type === "paragraph" && oe.children.length === 1 && oe.children[0].type === "esComment" && (pe = oe.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
              }
              return H ? H[1] || "next" : false;
            }
            function Z(oe, H) {
              let pe = H.parts.length === 0, X = k.includes(oe.type), le = oe.type === "html" && M.includes(H.parentNode.type);
              return !pe && !X && !le;
            }
            function se(oe, H) {
              var pe, X, le;
              let Ee = (H.prevNode && H.prevNode.type) === oe.type && L.has(oe.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A2 = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U(H.prevNode) === "next", re = oe.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe.position.start.line, ye = oe.type === "html" && H.parentNode.type === "listItem" && ((le = H.prevNode) === null || le === void 0 ? void 0 : le.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe.position.start.line;
              return A2 || !(Ee || De || G || re || ye);
            }
            function fe(oe, H) {
              let pe = H.prevNode && H.prevNode.type === "list", X = oe.type === "code" && oe.isIndented;
              return pe && X;
            }
            function ge(oe) {
              let H = ce(oe, ["linkReference", "imageReference"]);
              return H && (H.type !== "linkReference" || H.referenceType !== "full");
            }
            function he(oe) {
              let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
              return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe) ? `<${oe}>` : oe;
            }
            function we(oe, H) {
              let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              if (!oe)
                return "";
              if (pe)
                return " " + we(oe, H, false);
              if (oe = oe.replace(/\\(["')])/g, "$1"), oe.includes('"') && oe.includes("'") && !oe.includes(")"))
                return `(${oe})`;
              let X = oe.split("'").length - 1, le = oe.split('"').length - 1, Ae = X > le ? '"' : le > X || H.singleQuote ? "'" : '"';
              return oe = oe.replace(/\\/, "\\\\"), oe = oe.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe}${Ae}`;
            }
            function ke(oe, H, pe) {
              return oe < H ? H : oe > pe ? pe : oe;
            }
            function Re(oe) {
              let H = Number(oe.getName());
              if (H === 0)
                return false;
              let pe = oe.getParentNode().children[H - 1];
              return U(pe) === "next";
            }
            function Ne(oe) {
              return `[${t(oe.label)}]`;
            }
            function Pe(oe) {
              return `[^${oe.label}]`;
            }
            r.exports = { preprocess: o, print: Q, embed: D, massageAstNode: d, hasPrettierIgnore: Re, insertPragma: T };
          } }), Dg = te({ "src/language-markdown/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
          } }), mg = te({ "src/language-markdown/parsers.js"() {
            ne();
          } }), _a3 = te({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
            r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
          } }), dg = te({ "src/language-markdown/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = fg(), a2 = Dg(), n = mg(), u = [t(_a3(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t(_a3(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
            r.exports = { languages: u, options: a2, printers: i, parsers: n };
          } }), gg = te({ "src/language-html/clean.js"(e, r) {
            "use strict";
            ne();
            var { isFrontMatterNode: t } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
            function a2(n, u) {
              if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml")
                return null;
              n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
            }
            a2.ignoredProperties = s, r.exports = a2;
          } }), yg = te({ "src/language-html/constants.evaluate.js"(e, r) {
            r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
          } }), hg = te({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
            "use strict";
            ne();
            function t(s) {
              return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
            }
            r.exports = t;
          } }), Rt = te({ "src/language-html/utils/index.js"(e, r) {
            "use strict";
            ne();
            var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue(), { builders: { line: a2, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: g } = yg(), c = hg(), f2 = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), F = (A2) => A2.replace(/^[\t\n\f\r ]+/, ""), _ = (A2) => A2.replace(/[\t\n\f\r ]+$/, ""), w = (A2) => F(_(A2)), E = (A2) => A2.replace(/^[\t\f\r ]*\n/g, ""), N = (A2) => E(_(A2)), x = (A2) => A2.split(/[\t\n\f\r ]+/), I = (A2) => A2.match(/^[\t\n\f\r ]*/)[0], P = (A2) => {
              let [, G, re, ye] = A2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
              return { leadingWhitespace: G, trailingWhitespace: ye, text: re };
            }, $ = (A2) => /[\t\n\f\r ]/.test(A2);
            function D(A2, G) {
              return !!(A2.type === "ieConditionalComment" && A2.lastChild && !A2.lastChild.isSelfClosing && !A2.lastChild.endSourceSpan || A2.type === "ieConditionalComment" && !A2.complete || se(A2) && A2.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A2, G) && !o(A2) && A2.type !== "interpolation");
            }
            function T(A2) {
              return A2.type === "attribute" || !A2.parent || !A2.prev ? false : m(A2.prev);
            }
            function m(A2) {
              return A2.type === "comment" && A2.value.trim() === "prettier-ignore";
            }
            function C(A2) {
              return A2.type === "text" || A2.type === "comment";
            }
            function o(A2) {
              return A2.type === "element" && (A2.fullName === "script" || A2.fullName === "style" || A2.fullName === "svg:style" || c(A2) && (A2.name === "script" || A2.name === "style"));
            }
            function d(A2) {
              return A2.children && !o(A2);
            }
            function v(A2) {
              return o(A2) || A2.type === "interpolation" || S(A2);
            }
            function S(A2) {
              return we(A2).startsWith("pre");
            }
            function b(A2, G) {
              let re = ye();
              if (re && !A2.prev && A2.parent && A2.parent.tagDefinition && A2.parent.tagDefinition.ignoreFirstLf)
                return A2.type === "interpolation";
              return re;
              function ye() {
                return s(A2) ? false : (A2.type === "text" || A2.type === "interpolation") && A2.prev && (A2.prev.type === "text" || A2.prev.type === "interpolation") ? true : !A2.parent || A2.parent.cssDisplay === "none" ? false : se(A2.parent) ? true : !(!A2.prev && (A2.parent.type === "root" || se(A2) && A2.parent || o(A2.parent) || H(A2.parent, G) || !ue(A2.parent.cssDisplay)) || A2.prev && !U(A2.prev.cssDisplay));
              }
            }
            function B(A2, G) {
              return s(A2) ? false : (A2.type === "text" || A2.type === "interpolation") && A2.next && (A2.next.type === "text" || A2.next.type === "interpolation") ? true : !A2.parent || A2.parent.cssDisplay === "none" ? false : se(A2.parent) ? true : !(!A2.next && (A2.parent.type === "root" || se(A2) && A2.parent || o(A2.parent) || H(A2.parent, G) || !Fe(A2.parent.cssDisplay)) || A2.next && !z(A2.next.cssDisplay));
            }
            function k(A2) {
              return Z(A2.cssDisplay) && !o(A2);
            }
            function M(A2) {
              return s(A2) || A2.next && A2.sourceSpan.end && A2.sourceSpan.end.line + 1 < A2.next.sourceSpan.start.line;
            }
            function R(A2) {
              return q(A2) || A2.type === "element" && A2.children.length > 0 && (["body", "script", "style"].includes(A2.name) || A2.children.some((G) => ee(G))) || A2.firstChild && A2.firstChild === A2.lastChild && A2.firstChild.type !== "text" && V(A2.firstChild) && (!A2.lastChild.isTrailingSpaceSensitive || j(A2.lastChild));
            }
            function q(A2) {
              return A2.type === "element" && A2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A2.name) || A2.cssDisplay.startsWith("table") && A2.cssDisplay !== "table-cell");
            }
            function J(A2) {
              return Y(A2) || A2.prev && L(A2.prev) || Q(A2);
            }
            function L(A2) {
              return Y(A2) || A2.type === "element" && A2.fullName === "br" || Q(A2);
            }
            function Q(A2) {
              return V(A2) && j(A2);
            }
            function V(A2) {
              return A2.hasLeadingSpaces && (A2.prev ? A2.prev.sourceSpan.end.line < A2.sourceSpan.start.line : A2.parent.type === "root" || A2.parent.startSourceSpan.end.line < A2.sourceSpan.start.line);
            }
            function j(A2) {
              return A2.hasTrailingSpaces && (A2.next ? A2.next.sourceSpan.start.line > A2.sourceSpan.end.line : A2.parent.type === "root" || A2.parent.endSourceSpan && A2.parent.endSourceSpan.start.line > A2.sourceSpan.end.line);
            }
            function Y(A2) {
              switch (A2.type) {
                case "ieConditionalComment":
                case "comment":
                case "directive":
                  return true;
                case "element":
                  return ["script", "select"].includes(A2.name);
              }
              return false;
            }
            function ie(A2) {
              return A2.lastChild ? ie(A2.lastChild) : A2;
            }
            function ee(A2) {
              return A2.children && A2.children.some((G) => G.type !== "text");
            }
            function ce(A2) {
              let { type: G, lang: re } = A2.attrMap;
              if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx")
                return "babel";
              if (G === "application/x-typescript" || re === "ts" || re === "tsx")
                return "typescript";
              if (G === "text/markdown")
                return "markdown";
              if (G === "text/html")
                return "html";
              if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
                return "json";
              if (G === "text/x-handlebars-template")
                return "glimmer";
            }
            function W(A2, G) {
              let { lang: re } = A2.attrMap;
              if (!re || re === "postcss" || re === "css")
                return "css";
              if (re === "scss")
                return "scss";
              if (re === "less")
                return "less";
              if (re === "stylus")
                return t("stylus", G);
            }
            function K(A2, G) {
              if (A2.name === "script" && !A2.attrMap.src)
                return !A2.attrMap.lang && !A2.attrMap.type ? "babel" : ce(A2);
              if (A2.name === "style")
                return W(A2, G);
              if (G && X(A2, G))
                return ce(A2) || !("src" in A2.attrMap) && t(A2.attrMap.lang, G);
            }
            function de(A2) {
              return A2 === "block" || A2 === "list-item" || A2.startsWith("table");
            }
            function ue(A2) {
              return !de(A2) && A2 !== "inline-block";
            }
            function Fe(A2) {
              return !de(A2) && A2 !== "inline-block";
            }
            function z(A2) {
              return !de(A2);
            }
            function U(A2) {
              return !de(A2);
            }
            function Z(A2) {
              return !de(A2) && A2 !== "inline-block";
            }
            function se(A2) {
              return we(A2).startsWith("pre");
            }
            function fe(A2, G) {
              let re = 0;
              for (let ye = A2.stack.length - 1; ye >= 0; ye--) {
                let Ce = A2.stack[ye];
                Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re++;
              }
              return re;
            }
            function ge(A2, G) {
              let re = A2;
              for (; re; ) {
                if (G(re))
                  return true;
                re = re.parent;
              }
              return false;
            }
            function he(A2, G) {
              if (A2.prev && A2.prev.type === "comment") {
                let ye = A2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                if (ye)
                  return ye[1];
              }
              let re = false;
              if (A2.type === "element" && A2.namespace === "svg")
                if (ge(A2, (ye) => ye.fullName === "svg:foreignObject"))
                  re = true;
                else
                  return A2.name === "svg" ? "inline-block" : "block";
              switch (G.htmlWhitespaceSensitivity) {
                case "strict":
                  return "inline";
                case "ignore":
                  return "block";
                default:
                  return G.parser === "vue" && A2.parent && A2.parent.type === "root" ? "block" : A2.type === "element" && (!A2.namespace || re || c(A2)) && p[A2.name] || y;
              }
            }
            function we(A2) {
              return A2.type === "element" && (!A2.namespace || c(A2)) && h[A2.name] || g;
            }
            function ke(A2) {
              let G = Number.POSITIVE_INFINITY;
              for (let re of A2.split(`
`)) {
                if (re.length === 0)
                  continue;
                if (!f2.has(re[0]))
                  return 0;
                let ye = I(re).length;
                re.length !== ye && ye < G && (G = ye);
              }
              return G === Number.POSITIVE_INFINITY ? 0 : G;
            }
            function Re(A2) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A2);
              return G === 0 ? A2 : A2.split(`
`).map((re) => re.slice(G)).join(`
`);
            }
            function Ne(A2, G) {
              let re = 0;
              for (let ye = 0; ye < A2.length; ye++)
                A2[ye] === G && re++;
              return re;
            }
            function Pe(A2) {
              return A2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            }
            var oe = /* @__PURE__ */ new Set(["template", "style", "script"]);
            function H(A2, G) {
              return pe(A2, G) && !oe.has(A2.fullName);
            }
            function pe(A2, G) {
              return G.parser === "vue" && A2.type === "element" && A2.parent.type === "root" && A2.fullName.toLowerCase() !== "html";
            }
            function X(A2, G) {
              return pe(A2, G) && (H(A2, G) || A2.attrMap.lang && A2.attrMap.lang !== "html");
            }
            function le(A2) {
              let G = A2.fullName;
              return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
            }
            function Ae(A2, G) {
              let re = A2.parent;
              if (!pe(re, G))
                return false;
              let ye = re.fullName, Ce = A2.fullName;
              return ye === "script" && Ce === "setup" || ye === "style" && Ce === "vars";
            }
            function Ee(A2) {
              let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A2.value;
              return A2.parent.isWhitespaceSensitive ? A2.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n) : i(u(a2, x(G)));
            }
            function De(A2, G) {
              return pe(A2, G) && A2.name === "script";
            }
            r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N, hasHtmlWhitespace: $, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe, getTextValueParts: Ee };
          } }), vg = te({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
            function r(i) {
              return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
            }
            e.isWhitespace = r;
            function t(i) {
              return e.$0 <= i && i <= e.$9;
            }
            e.isDigit = t;
            function s(i) {
              return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
            }
            e.isAsciiLetter = s;
            function a2(i) {
              return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
            }
            e.isAsciiHexDigit = a2;
            function n(i) {
              return i === e.$LF || i === e.$CR;
            }
            e.isNewLine = n;
            function u(i) {
              return e.$0 <= i && i <= e.$7;
            }
            e.isOctalDigit = u;
          } }), Cg = te({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = class {
              constructor(s, a2, n) {
                this.filePath = s, this.name = a2, this.members = n;
              }
              assertNoMembers() {
                if (this.members.length)
                  throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
              }
            };
            e.StaticSymbol = r;
            var t = class {
              constructor() {
                this.cache = /* @__PURE__ */ new Map();
              }
              get(s, a2, n) {
                n = n || [];
                let u = n.length ? `.${n.join(".")}` : "", i = `"${s}".${a2}${u}`, l = this.cache.get(i);
                return l || (l = new r(s, a2, n), this.cache.set(i, l)), l;
              }
            };
            e.StaticSymbolCache = t;
          } }), Eg = te({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = /-+([a-z0-9])/g;
            function t(o) {
              return o.replace(r, function() {
                for (var d = arguments.length, v = new Array(d), S = 0; S < d; S++)
                  v[S] = arguments[S];
                return v[1].toUpperCase();
              });
            }
            e.dashCaseToCamelCase = t;
            function s(o, d) {
              return n(o, ":", d);
            }
            e.splitAtColon = s;
            function a2(o, d) {
              return n(o, ".", d);
            }
            e.splitAtPeriod = a2;
            function n(o, d, v) {
              let S = o.indexOf(d);
              return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
            }
            function u(o, d, v) {
              return Array.isArray(o) ? d.visitArray(o, v) : E(o) ? d.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, v) : d.visitOther(o, v);
            }
            e.visitValue = u;
            function i(o) {
              return o != null;
            }
            e.isDefined = i;
            function l(o) {
              return o === void 0 ? null : o;
            }
            e.noUndefined = l;
            var p = class {
              visitArray(o, d) {
                return o.map((v) => u(v, this, d));
              }
              visitStringMap(o, d) {
                let v = {};
                return Object.keys(o).forEach((S) => {
                  v[S] = u(o[S], this, d);
                }), v;
              }
              visitPrimitive(o, d) {
                return o;
              }
              visitOther(o, d) {
                return o;
              }
            };
            e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
              if (P(o))
                throw new Error("Illegal state: value cannot be a promise");
              return o;
            }, then: (o, d) => P(o) ? o.then(d) : d(o), all: (o) => o.some(P) ? Promise.all(o) : o };
            function y(o) {
              throw new Error(`Internal Error: ${o}`);
            }
            e.error = y;
            function h(o, d) {
              let v = Error(o);
              return v[g] = true, d && (v[c] = d), v;
            }
            e.syntaxError = h;
            var g = "ngSyntaxError", c = "ngParseErrors";
            function f2(o) {
              return o[g];
            }
            e.isSyntaxError = f2;
            function F(o) {
              return o[c] || [];
            }
            e.getParseErrors = F;
            function _(o) {
              return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
            }
            e.escapeRegExp = _;
            var w = Object.getPrototypeOf({});
            function E(o) {
              return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
            }
            function N(o) {
              let d = "";
              for (let v = 0; v < o.length; v++) {
                let S = o.charCodeAt(v);
                if (S >= 55296 && S <= 56319 && o.length > v + 1) {
                  let b = o.charCodeAt(v + 1);
                  b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
                }
                S <= 127 ? d += String.fromCharCode(S) : S <= 2047 ? d += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? d += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (d += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
              }
              return d;
            }
            e.utf8Encode = N;
            function x(o) {
              if (typeof o == "string")
                return o;
              if (o instanceof Array)
                return "[" + o.map(x).join(", ") + "]";
              if (o == null)
                return "" + o;
              if (o.overriddenName)
                return `${o.overriddenName}`;
              if (o.name)
                return `${o.name}`;
              if (!o.toString)
                return "object";
              let d = o.toString();
              if (d == null)
                return "" + d;
              let v = d.indexOf(`
`);
              return v === -1 ? d : d.substring(0, v);
            }
            e.stringify = x;
            function I(o) {
              return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
            }
            e.resolveForwardRef = I;
            function P(o) {
              return !!o && typeof o.then == "function";
            }
            e.isPromise = P;
            var $ = class {
              constructor(o) {
                this.full = o;
                let d = o.split(".");
                this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
              }
            };
            e.Version = $;
            var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
            e.global = C;
          } }), Fg = te({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = Cg(), t = Eg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
            function a2(v) {
              return v.replace(/\W/g, "_");
            }
            e.sanitizeIdentifier = a2;
            var n = 0;
            function u(v) {
              if (!v || !v.reference)
                return null;
              let S = v.reference;
              if (S instanceof r.StaticSymbol)
                return S.name;
              if (S.__anonymousType)
                return S.__anonymousType;
              let b = t.stringify(S);
              return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a2(b), b;
            }
            e.identifierName = u;
            function i(v) {
              let S = v.reference;
              return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
            }
            e.identifierModuleUrl = i;
            function l(v, S) {
              return `View_${u({ reference: v })}_${S}`;
            }
            e.viewClassName = l;
            function p(v) {
              return `RenderType_${u({ reference: v })}`;
            }
            e.rendererTypeName = p;
            function y(v) {
              return `HostView_${u({ reference: v })}`;
            }
            e.hostViewClassName = y;
            function h(v) {
              return `${u({ reference: v })}NgFactory`;
            }
            e.componentFactoryName = h;
            var g;
            (function(v) {
              v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
            })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
            function c(v) {
              return v.value != null ? a2(v.value) : u(v.identifier);
            }
            e.tokenName = c;
            function f2(v) {
              return v.identifier != null ? v.identifier.reference : v.value;
            }
            e.tokenReference = f2;
            var F = class {
              constructor() {
                let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
              }
            };
            e.CompileStylesheetMetadata = F;
            var _ = class {
              constructor(v) {
                let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Q, isInline: V, preserveWhitespaces: j } = v;
                if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q), this.animations = J ? D(J) : [], this.ngContentSelectors = L || [], Q && Q.length != 2)
                  throw new Error("'interpolation' should have a start and an end symbol.");
                this.interpolation = Q, this.isInline = V, this.preserveWhitespaces = j;
              }
              toSummary() {
                return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
              }
            };
            e.CompileTemplateMetadata = _;
            var w = class {
              static create(v) {
                let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, host: L, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
                L != null && Object.keys(L).forEach((se) => {
                  let fe = L[se], ge = se.match(s);
                  ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
                });
                let U = {};
                q != null && q.forEach((se) => {
                  let fe = t.splitAtColon(se, [se, se]);
                  U[fe[0]] = fe[1];
                });
                let Z = {};
                return J != null && J.forEach((se) => {
                  let fe = t.splitAtColon(se, [se, se]);
                  Z[fe[0]] = fe[1];
                }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
              }
              constructor(v) {
                let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J, hostListeners: L, hostProperties: Q, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
                this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Q, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
              }
              toSummary() {
                return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
              }
            };
            e.CompileDirectiveMetadata = w;
            var E = class {
              constructor(v) {
                let { type: S, name: b, pure: B } = v;
                this.type = S, this.name = b, this.pure = !!B;
              }
              toSummary() {
                return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
              }
            };
            e.CompilePipeMetadata = E;
            var N = class {
            };
            e.CompileShallowModuleMetadata = N;
            var x = class {
              constructor(v) {
                let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Q, schemas: V, transitiveModule: j, id: Y } = v;
                this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Q), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
              }
              toSummary() {
                let v = this.transitiveModule;
                return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
              }
            };
            e.CompileNgModuleMetadata = x;
            var I = class {
              constructor() {
                this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
              }
              addProvider(v, S) {
                this.providers.push({ provider: v, module: S });
              }
              addDirective(v) {
                this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
              }
              addExportedDirective(v) {
                this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
              }
              addPipe(v) {
                this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
              }
              addExportedPipe(v) {
                this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
              }
              addModule(v) {
                this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
              }
              addEntryComponent(v) {
                this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
              }
            };
            e.TransitiveCompileNgModuleMetadata = I;
            function P(v) {
              return v || [];
            }
            var $ = class {
              constructor(v, S) {
                let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q } = S;
                this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q;
              }
            };
            e.ProviderMeta = $;
            function D(v) {
              return v.reduce((S, b) => {
                let B = Array.isArray(b) ? D(b) : b;
                return S.concat(B);
              }, []);
            }
            e.flatten = D;
            function T(v) {
              return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
            }
            function m(v, S, b) {
              let B;
              return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
            }
            e.templateSourceUrl = m;
            function C(v, S) {
              let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
              return T(`css/${S}${B}.ngstyle.js`);
            }
            e.sharedStylesheetJitUrl = C;
            function o(v) {
              return T(`${u(v.type)}/module.ngfactory.js`);
            }
            e.ngModuleJitUrl = o;
            function d(v, S) {
              return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
            }
            e.templateJitUrl = d;
          } }), Ag = te({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
            "use strict";
            ne(), Object.defineProperty(e, "__esModule", { value: true });
            var r = vg(), t = Fg(), s = class {
              constructor(y, h, g, c) {
                this.file = y, this.offset = h, this.line = g, this.col = c;
              }
              toString() {
                return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
              }
              moveBy(y) {
                let h = this.file.content, g = h.length, c = this.offset, f2 = this.line, F = this.col;
                for (; c > 0 && y < 0; )
                  if (c--, y++, h.charCodeAt(c) == r.$LF) {
                    f2--;
                    let w = h.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
                    F = w > 0 ? c - w : c;
                  } else
                    F--;
                for (; c < g && y > 0; ) {
                  let _ = h.charCodeAt(c);
                  c++, y--, _ == r.$LF ? (f2++, F = 0) : F++;
                }
                return new s(this.file, c, f2, F);
              }
              getContext(y, h) {
                let g = this.file.content, c = this.offset;
                if (c != null) {
                  c > g.length - 1 && (c = g.length - 1);
                  let f2 = c, F = 0, _ = 0;
                  for (; F < y && c > 0 && (c--, F++, !(g[c] == `
` && ++_ == h)); )
                    ;
                  for (F = 0, _ = 0; F < y && f2 < g.length - 1 && (f2++, F++, !(g[f2] == `
` && ++_ == h)); )
                    ;
                  return { before: g.substring(c, this.offset), after: g.substring(this.offset, f2 + 1) };
                }
                return null;
              }
            };
            e.ParseLocation = s;
            var a2 = class {
              constructor(y, h) {
                this.content = y, this.url = h;
              }
            };
            e.ParseSourceFile = a2;
            var n = class {
              constructor(y, h) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
                this.start = y, this.end = h, this.details = g;
              }
              toString() {
                return this.start.file.content.substring(this.start.offset, this.end.offset);
              }
            };
            e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a2("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
            var u;
            (function(y) {
              y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
            })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
            var i = class {
              constructor(y, h) {
                let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
                this.span = y, this.msg = h, this.level = g;
              }
              contextualMessage() {
                let y = this.span.start.getContext(100, 3);
                return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
              }
              toString() {
                let y = this.span.details ? `, ${this.span.details}` : "";
                return `${this.contextualMessage()}: ${this.span.start}${y}`;
              }
            };
            e.ParseError = i;
            function l(y, h) {
              let g = t.identifierModuleUrl(h), c = g != null ? `in ${y} ${t.identifierName(h)} in ${g}` : `in ${y} ${t.identifierName(h)}`, f2 = new a2("", c);
              return new n(new s(f2, -1, -1, -1), new s(f2, -1, -1, -1));
            }
            e.typeSourceSpan = l;
            function p(y, h, g) {
              let c = `in ${y} ${h} in ${g}`, f2 = new a2("", c);
              return new n(new s(f2, -1, -1, -1), new s(f2, -1, -1, -1));
            }
            e.r3JitTypeSourceSpan = p;
          } }), Sg = te({ "src/language-html/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var { ParseSourceSpan: t } = Ag(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a2, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: g, isVueScriptTag: c } = Rt(), f2 = [_, w, N, I, P, T, $, D, m, x, C];
            function F(o, d) {
              for (let v of f2)
                v(o, d);
              return o;
            }
            function _(o) {
              o.walk((d) => {
                if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                  let v = d.children[0];
                  v.value.length === 1 ? d.removeChild(v) : v.value = v.value.slice(1);
                }
              });
            }
            function w(o) {
              let d = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
              o.walk((v) => {
                if (v.children)
                  for (let S = 0; S < v.children.length; S++) {
                    let b = v.children[S];
                    if (!d(b))
                      continue;
                    let B = b.prev, k = b.firstChild;
                    v.removeChild(B), S--;
                    let M = new t(B.sourceSpan.start, k.sourceSpan.end), R = new t(M.start, b.sourceSpan.end);
                    b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
                  }
              });
            }
            function E(o, d, v) {
              o.walk((S) => {
                if (S.children)
                  for (let b = 0; b < S.children.length; b++) {
                    let B = S.children[b];
                    if (B.type !== "text" && !d(B))
                      continue;
                    B.type !== "text" && (B.type = "text", B.value = v(B));
                    let k = B.prev;
                    !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
                  }
              });
            }
            function N(o) {
              return E(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
            }
            function x(o) {
              let d = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
              o.walk((v) => {
                if (v.children)
                  for (let S = 0; S < v.children.length; S++) {
                    let b = v.children[S];
                    if (!d(b))
                      continue;
                    let B = b.prev, k = b.next;
                    B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
                  }
              });
            }
            function I(o, d) {
              if (d.parser === "html")
                return;
              let v = /{{(.+?)}}/s;
              o.walk((S) => {
                if (u(S))
                  for (let b of S.children) {
                    if (b.type !== "text")
                      continue;
                    let B = b.sourceSpan.start, k = null, M = b.value.split(v);
                    for (let R = 0; R < M.length; R++, B = k) {
                      let q = M[R];
                      if (R % 2 === 0) {
                        k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(B, k) });
                        continue;
                      }
                      k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
                    }
                    S.removeChild(b);
                  }
              });
            }
            function P(o) {
              o.walk((d) => {
                if (!d.children)
                  return;
                if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s(d.children[0].value).length === 0) {
                  d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                  return;
                }
                let v = g(d), S = p(d);
                if (!v)
                  for (let b = 0; b < d.children.length; b++) {
                    let B = d.children[b];
                    if (B.type !== "text")
                      continue;
                    let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a2(B.value), q = B.prev, J = B.next;
                    M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(B), b--, (k || R) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                  }
                d.isWhitespaceSensitive = v, d.isIndentationSensitive = S;
              });
            }
            function $(o) {
              o.walk((d) => {
                d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
              });
            }
            function D(o, d) {
              o.walk((v) => {
                v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
              });
            }
            function T(o, d) {
              o.walk((v) => {
                v.cssDisplay = i(v, d);
              });
            }
            function m(o, d) {
              o.walk((v) => {
                let { children: S } = v;
                if (S) {
                  if (S.length === 0) {
                    v.isDanglingSpaceSensitive = l(v);
                    return;
                  }
                  for (let b of S)
                    b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h(b, d);
                  for (let b = 0; b < S.length; b++) {
                    let B = S[b];
                    B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
                  }
                }
              });
            }
            function C(o, d) {
              if (d.parser === "vue") {
                let v = o.children.find((b) => c(b, d));
                if (!v)
                  return;
                let { lang: S } = v.attrMap;
                (S === "ts" || S === "typescript") && (d.__should_parse_vue_template_with_ts = true);
              }
            }
            r.exports = F;
          } }), xg = te({ "src/language-html/pragma.js"(e, r) {
            "use strict";
            ne();
            function t(a2) {
              return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a2);
            }
            function s(a2) {
              return `<!-- @format -->

` + a2.replace(/^\s*\n/, "");
            }
            r.exports = { hasPragma: t, insertPragma: s };
          } }), au = te({ "src/language-html/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a2) {
              return a2.sourceSpan.start.offset;
            }
            function s(a2) {
              return a2.sourceSpan.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), ur = te({ "src/language-html/print/tag.js"(e, r) {
            "use strict";
            ne();
            var t = Zt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a2, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: y, locEnd: h } = au(), { isTextLikeNode: g, getLastDescendant: c, isPreLikeNode: f2, hasPrettierIgnore: F, shouldPreserveContent: _, isVueSfcBlock: w } = Rt();
            function E(L, Q) {
              return [L.isSelfClosing ? "" : N(L, Q), x(L, Q)];
            }
            function N(L, Q) {
              return L.lastChild && o(L.lastChild) ? "" : [I(L, Q), $(L, Q)];
            }
            function x(L, Q) {
              return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q), P(L, Q)];
            }
            function I(L, Q) {
              return C(L) ? D(L.lastChild, Q) : "";
            }
            function P(L, Q) {
              return o(L) ? $(L.parent, Q) : d(L) ? q(L.next) : "";
            }
            function $(L, Q) {
              if (t(!L.isSelfClosing), T(L, Q))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                  return "<!";
                case "element":
                  if (L.hasHtmComponentClosingTag)
                    return "<//";
                default:
                  return `</${L.rawName}`;
              }
            }
            function D(L, Q) {
              if (T(L, Q))
                return "";
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalEndComment":
                  return "[endif]-->";
                case "ieConditionalStartComment":
                  return "]><!-->";
                case "interpolation":
                  return "}}";
                case "element":
                  if (L.isSelfClosing)
                    return "/>";
                default:
                  return ">";
              }
            }
            function T(L, Q) {
              return !L.isSelfClosing && !L.endSourceSpan && (F(L) || _(L.parent, Q));
            }
            function m(L) {
              return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function C(L) {
              return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c(L.lastChild)) && !f2(L);
            }
            function o(L) {
              return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c(L));
            }
            function d(L) {
              return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
            }
            function v(L) {
              let Q = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
              return Q ? Q[1] ? Q[1].split(/\s+/) : true : false;
            }
            function S(L) {
              return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
            }
            function b(L, Q, V) {
              let j = L.getValue();
              if (!s(j.attrs))
                return j.isSelfClosing ? " " : "";
              let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
                let Fe = ue.getValue();
                return ie(Fe) ? p(Q.originalText.slice(y(Fe), h(Fe))) : V();
              }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q) ? l : u, de = [a2([ce ? " " : u, n(K, ee)])];
              return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
            }
            function B(L) {
              return L.firstChild && S(L.firstChild) ? "" : J(L);
            }
            function k(L, Q, V) {
              let j = L.getValue();
              return [M(j, Q), b(L, Q, V), j.isSelfClosing ? "" : B(j)];
            }
            function M(L, Q) {
              return L.prev && d(L.prev) ? "" : [R(L, Q), q(L)];
            }
            function R(L, Q) {
              return S(L) ? J(L.parent) : m(L) ? D(L.prev, Q) : "";
            }
            function q(L) {
              switch (L.type) {
                case "ieConditionalComment":
                case "ieConditionalStartComment":
                  return `<!--[if ${L.condition}`;
                case "ieConditionalEndComment":
                  return "<!--<!";
                case "interpolation":
                  return "{{";
                case "docType":
                  return "<!DOCTYPE";
                case "element":
                  if (L.condition)
                    return `<!--[if ${L.condition}]><!--><${L.rawName}`;
                default:
                  return `<${L.rawName}`;
              }
            }
            function J(L) {
              switch (t(!L.isSelfClosing), L.type) {
                case "ieConditionalComment":
                  return "]>";
                case "element":
                  if (L.condition)
                    return "><!--<![endif]-->";
                default:
                  return ">";
              }
            }
            r.exports = { printClosingTag: E, printClosingTagStart: N, printClosingTagStartMarker: $, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: S };
          } }), bg = te({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
            ne(), function(t, s) {
              typeof define == "function" && define.amd ? define([], s) : typeof r == "object" && r.exports ? r.exports = s() : t.parseSrcset = s();
            }(e, function() {
              return function(t, s) {
                var a2 = s && s.logger || console;
                function n($) {
                  return $ === " " || $ === "	" || $ === `
` || $ === "\f" || $ === "\r";
                }
                function u($) {
                  var D, T = $.exec(t.substring(N));
                  if (T)
                    return D = T[0], N += D.length, D;
                }
                for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, g = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f2, F, _, w, E, N = 0, x = []; ; ) {
                  if (u(p), N >= i)
                    return x;
                  f2 = u(y), F = [], f2.slice(-1) === "," ? (f2 = f2.replace(h, ""), P()) : I();
                }
                function I() {
                  for (u(l), _ = "", w = "in descriptor"; ; ) {
                    if (E = t.charAt(N), w === "in descriptor")
                      if (n(E))
                        _ && (F.push(_), _ = "", w = "after descriptor");
                      else if (E === ",") {
                        N += 1, _ && F.push(_), P();
                        return;
                      } else if (E === "(")
                        _ = _ + E, w = "in parens";
                      else if (E === "") {
                        _ && F.push(_), P();
                        return;
                      } else
                        _ = _ + E;
                    else if (w === "in parens")
                      if (E === ")")
                        _ = _ + E, w = "in descriptor";
                      else if (E === "") {
                        F.push(_), P();
                        return;
                      } else
                        _ = _ + E;
                    else if (w === "after descriptor" && !n(E))
                      if (E === "") {
                        P();
                        return;
                      } else
                        w = "in descriptor", N -= 1;
                    N += 1;
                  }
                }
                function P() {
                  var $ = false, D, T, m, C, o = {}, d, v, S, b, B;
                  for (C = 0; C < F.length; C++)
                    d = F[C], v = d[d.length - 1], S = d.substring(0, d.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($ = true), b === 0 ? $ = true : D = b) : c.test(S) && v === "x" ? ((D || T || m) && ($ = true), B < 0 ? $ = true : T = B) : g.test(S) && v === "h" ? ((m || T) && ($ = true), b === 0 ? $ = true : m = b) : $ = true;
                  $ ? a2 && a2.error && a2.error("Invalid srcset descriptor found in '" + t + "' at '" + d + "'.") : (o.url = f2, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));
                }
              };
            });
          } }), Tg = te({ "src/language-html/syntax-attribute.js"(e, r) {
            "use strict";
            ne();
            var t = bg(), { builders: { ifBreak: s, join: a2, line: n } } = qe();
            function u(l) {
              let p = t(l, { logger: { error(I) {
                throw new Error(I);
              } } }), y = p.some((I) => {
                let { w: P } = I;
                return P;
              }), h = p.some((I) => {
                let { h: P } = I;
                return P;
              }), g = p.some((I) => {
                let { d: P } = I;
                return P;
              });
              if (y + h + g > 1)
                throw new Error("Mixed descriptor in srcset is not supported");
              let c = y ? "w" : h ? "h" : "d", f2 = y ? "w" : h ? "h" : "x", F = (I) => Math.max(...I), _ = p.map((I) => I.url), w = F(_.map((I) => I.length)), E = p.map((I) => I[c]).map((I) => I ? I.toString() : ""), N = E.map((I) => {
                let P = I.indexOf(".");
                return P === -1 ? I.length : P;
              }), x = F(N);
              return a2([",", n], _.map((I, P) => {
                let $ = [I], D = E[P];
                if (D) {
                  let T = w - I.length + 1, m = x - N[P], C = " ".repeat(T + m);
                  $.push(s(C, " "), D + f2);
                }
                return $;
              }));
            }
            function i(l) {
              return l.trim().split(/\s+/).join(" ");
            }
            r.exports = { printImgSrcset: u, printClassNames: i };
          } }), Bg = te({ "src/language-html/syntax-vue.js"(e, r) {
            "use strict";
            ne();
            var { builders: { group: t } } = qe();
            function s(i, l) {
              let { left: p, operator: y, right: h } = a2(i);
              return [t(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
            }
            function a2(i) {
              let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h = i.match(l);
              if (!h)
                return;
              let g = {};
              if (g.for = h[3].trim(), !g.for)
                return;
              let c = h[1].trim().replace(y, ""), f2 = c.match(p);
              f2 ? (g.alias = c.replace(p, ""), g.iterator1 = f2[1].trim(), f2[2] && (g.iterator2 = f2[2].trim())) : g.alias = c;
              let F = [g.alias, g.iterator1, g.iterator2];
              if (!F.some((_, w) => !_ && (w === 0 || F.slice(w + 1).some(Boolean))))
                return { left: F.filter(Boolean).join(","), operator: h[2], right: g.for };
            }
            function n(i, l) {
              return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
            }
            function u(i) {
              let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
              return l.test(y) || p.test(y);
            }
            r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n };
          } }), Lo = te({ "src/language-html/get-node-content.js"(e, r) {
            "use strict";
            ne();
            var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a2, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = ur();
            function l(p, y) {
              let h = p.startSourceSpan.end.offset;
              p.firstChild && u(p.firstChild) && (h -= i(p).length);
              let g = p.endSourceSpan.start.offset;
              return p.lastChild && t(p.lastChild) ? g += s(p, y).length : a2(p) && (g -= n(p.lastChild, y).length), y.originalText.slice(h, g);
            }
            r.exports = l;
          } }), Ng = te({ "src/language-html/embed.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, group: s, hardline: a2, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: y } } = qe(), h = su(), { printClosingTag: g, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f2, printOpeningTagPrefix: F, printOpeningTag: _ } = ur(), { printImgSrcset: w, printClassNames: E } = Tg(), { printVueFor: N, printVueBindings: x, isVueEventBindingExpression: I } = Bg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: v } = Rt(), S = Lo();
            function b(k, M, R) {
              let q = (ee) => new RegExp(ee.join("|")).test(k.fullName), J = () => C(k.value), L = false, Q = (ee, ce) => {
                let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
                W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
              }, V = (ee) => s(ee), j = function(ee) {
                let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                return s([n([l, ee]), ce ? l : ""]);
              }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q, __embeddedInHtml: true }, ce));
              if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
                return j(w(J()));
              if (k.fullName === "class" && !R.parentParser) {
                let ee = J();
                if (!ee.includes("{{"))
                  return E(ee);
              }
              if (k.fullName === "style" && !R.parentParser) {
                let ee = J();
                if (!ee.includes("{{"))
                  return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
              }
              if (R.parser === "vue") {
                if (k.fullName === "v-for")
                  return N(J(), ie);
                if (o(k) || d(k, R))
                  return x(J(), ie);
                let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
                if (q(ee)) {
                  let K = J(), de = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                  return Y(ie(K, { parser: de }));
                }
                if (q(ce))
                  return Y(ie(J(), { parser: "__vue_expression" }));
                if (q(W))
                  return Y(ie(J(), { parser: "__js_expression" }));
              }
              if (R.parser === "angular") {
                let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
                if (q(W))
                  return Y(ee(J(), { parser: "__ng_action" }));
                if (q(K))
                  return Y(ee(J(), { parser: "__ng_binding" }));
                if (q(de)) {
                  let z = J().trim();
                  return j(i(v(k, z)), !z.includes("@@"));
                }
                if (q(ce))
                  return Y(ee(J(), { parser: "__ng_directive" }));
                let ue = /{{(.+?)}}/s, Fe = J();
                if (ue.test(Fe)) {
                  let z = [];
                  for (let [U, Z] of Fe.split(ue).entries())
                    if (U % 2 === 0)
                      z.push(y(Z));
                    else
                      try {
                        z.push(s(["{{", n([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                      } catch {
                        z.push("{{", y(Z), "}}");
                      }
                  return s(z);
                }
              }
              return null;
            }
            function B(k, M, R, q) {
              let J = k.getValue();
              switch (J.type) {
                case "element": {
                  if (P(J) || J.type === "interpolation")
                    return;
                  if (!J.isSelfClosing && $(J, q)) {
                    let L = D(J, q);
                    if (!L)
                      return;
                    let Q = S(J, q), V = /^\s*$/.test(Q), j = "";
                    return V || (j = R(T(Q), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [F(J, q), s(_(k, q, M)), V ? "" : a2, j, V ? "" : a2, g(J, q), c(J, q)];
                  }
                  break;
                }
                case "text": {
                  if (P(J.parent)) {
                    let L = D(J.parent, q);
                    if (L) {
                      let Q = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                      if (q.parser === "html" && L === "babel") {
                        let j = "script", { attrMap: Y } = J.parent;
                        Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
                      }
                      return [t, F(J, q), R(Q, V, { stripTrailingHardline: true }), c(J, q)];
                    }
                  } else if (J.parent.type === "interpolation") {
                    let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                    return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R(J.value, L, { stripTrailingHardline: true })]), J.parent.next && f2(J.parent.next) ? " " : u];
                  }
                  break;
                }
                case "attribute": {
                  if (!J.value)
                    break;
                  if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                    return [J.rawName, "=", J.value];
                  let L = b(J, (Q, V) => R(Q, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                  if (L)
                    return [J.rawName, '="', s(p(L, (Q) => typeof Q == "string" ? Q.replace(/"/g, "&quot;") : Q)), '"'];
                  break;
                }
                case "front-matter":
                  return h(J, R);
              }
            }
            r.exports = B;
          } }), Oo = te({ "src/language-html/print/children.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, group: s, ifBreak: a2, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: y } = au(), { forceBreakChildren: h, forceNextEmptyLine: g, isTextLikeNode: c, hasPrettierIgnore: f2, preferHardlineAsLeadingSpaces: F } = Rt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: E, needsToBorrowPrevClosingTagEndMarker: N, printClosingTagEndMarker: x, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = ur();
            function $(m, C, o) {
              let d = m.getValue();
              return f2(d) ? [_(d, C), ...l(C.originalText.slice(p(d) + (d.prev && w(d.prev) ? E(d).length : 0), y(d) - (d.next && N(d.next) ? x(d, C).length : 0))), I(d, C)] : o();
            }
            function D(m, C) {
              return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? F(C) ? i : n : "" : F(C) ? i : u : w(m) && (f2(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N(C) ? "" : !C.isLeadingSpaceSensitive || F(C) || N(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
            }
            function T(m, C, o) {
              let d = m.getValue();
              if (h(d))
                return [t, ...m.map((S) => {
                  let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
                  return [B ? [B, g(b.prev) ? i : ""] : "", $(S, C, o)];
                }, "children")];
              let v = d.children.map(() => Symbol(""));
              return m.map((S, b) => {
                let B = S.getValue();
                if (c(B)) {
                  if (B.prev && c(B.prev)) {
                    let Q = D(B.prev, B);
                    if (Q)
                      return g(B.prev) ? [i, i, $(S, C, o)] : [Q, $(S, C, o)];
                  }
                  return $(S, C, o);
                }
                let k = [], M = [], R = [], q = [], J = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
                return J && (g(B.prev) ? k.push(i, i) : J === i ? k.push(i) : c(B.prev) ? M.push(J) : M.push(a2("", u, { groupId: v[b - 1] }))), L && (g(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R.push(L)), [...k, s([...M, s([$(S, C, o), ...R], { id: v[b] })]), ...q];
              }, "children");
            }
            r.exports = { printChildren: T };
          } }), wg = te({ "src/language-html/print/element.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, dedentToRoot: s, group: a2, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: y } } = qe(), h = Lo(), { shouldPreserveContent: g, isScriptLikeTag: c, isVueCustomBlock: f2, countParents: F, forceBreakContent: _ } = Rt(), { printOpeningTagPrefix: w, printOpeningTag: E, printClosingTagSuffix: N, printClosingTag: x, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = ur(), { printChildren: $ } = Oo();
            function D(T, m, C) {
              let o = T.getValue();
              if (g(o, m))
                return [w(o, m), a2(E(T, m, C)), ...y(h(o, m)), ...x(o, m), N(o, m)];
              let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a2([a2(E(T, m, C), { id: v }), M, x(o, m)]), b = (M) => d ? u(M, { groupId: v }) : (c(o) || f2(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M : i(M), B = () => d ? n(p, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? n(p, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * F(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
              return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $(T, m, C)]), k()]);
            }
            r.exports = { printElement: D };
          } }), _g = te({ "src/language-html/printer-html.js"(e, r) {
            "use strict";
            ne();
            var { builders: { fill: t, group: s, hardline: a2, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe(), y = gg(), { countChars: h, unescapeQuoteEntities: g, getTextValueParts: c } = Rt(), f2 = Sg(), { insertPragma: F } = xg(), { locStart: _, locEnd: w } = au(), E = Ng(), { printClosingTagSuffix: N, printClosingTagEnd: x, printOpeningTagPrefix: I, printOpeningTagStart: P } = ur(), { printElement: $ } = wg(), { printChildren: D } = Oo();
            function T(m, C, o) {
              let d = m.getValue();
              switch (d.type) {
                case "front-matter":
                  return p(d.raw);
                case "root":
                  return C.__onHtmlRoot && C.__onHtmlRoot(d), [s(D(m, C, o)), a2];
                case "element":
                case "ieConditionalComment":
                  return $(m, C, o);
                case "ieConditionalStartComment":
                case "ieConditionalEndComment":
                  return [P(d), x(d)];
                case "interpolation":
                  return [P(d, C), ...m.map(o, "children"), x(d, C)];
                case "text": {
                  if (d.parent.type === "interpolation") {
                    let S = /\n[^\S\n]*$/, b = S.test(d.value), B = b ? d.value.replace(S, "") : d.value;
                    return [...p(B), b ? a2 : ""];
                  }
                  let v = u([I(d, C), ...c(d), N(d, C)]);
                  return l(v) || v.type === "fill" ? t(i(v)) : v;
                }
                case "docType":
                  return [s([P(d, C), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x(d, C)];
                case "comment":
                  return [I(d, C), ...p(C.originalText.slice(_(d), w(d)), n), N(d, C)];
                case "attribute": {
                  if (d.value === null)
                    return d.rawName;
                  let v = g(d.value), S = h(v, "'"), b = h(v, '"'), B = S < b ? "'" : '"';
                  return [d.rawName, "=", B, ...p(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
                }
                default:
                  throw new Error(`Unexpected node type ${d.type}`);
              }
            }
            r.exports = { preprocess: f2, print: T, insertPragma: F, massageAstNode: y, embed: E };
          } }), Pg = te({ "src/language-html/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt(), s = "HTML";
            r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
          } }), Ig = te({ "src/language-html/parsers.js"() {
            ne();
          } }), On = te({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
            r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
          } }), kg = te({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
            r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
          } }), Lg = te({ "src/language-html/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = _g(), a2 = Pg(), n = Ig(), u = [t(On(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(On(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(On(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(kg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
            r.exports = { languages: u, printers: i, options: a2, parsers: n };
          } }), Og = te({ "src/language-yaml/pragma.js"(e, r) {
            "use strict";
            ne();
            function t(n) {
              return /^\s*@(?:prettier|format)\s*$/.test(n);
            }
            function s(n) {
              return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
            }
            function a2(n) {
              return `# @format

${n}`;
            }
            r.exports = { isPragma: t, hasPragma: s, insertPragma: a2 };
          } }), jg = te({ "src/language-yaml/loc.js"(e, r) {
            "use strict";
            ne();
            function t(a2) {
              return a2.position.start.offset;
            }
            function s(a2) {
              return a2.position.end.offset;
            }
            r.exports = { locStart: t, locEnd: s };
          } }), qg = te({ "src/language-yaml/embed.js"(e, r) {
            "use strict";
            ne();
            function t(s, a2, n, u) {
              if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
                return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
            }
            r.exports = t;
          } }), $t = te({ "src/language-yaml/utils.js"(e, r) {
            "use strict";
            ne();
            var { getLast: t, isNonEmptyArray: s } = Ue();
            function a2(D, T) {
              let m = 0, C = D.stack.length - 1;
              for (let o = 0; o < C; o++) {
                let d = D.stack[o];
                n(d) && T(d) && m++;
              }
              return m;
            }
            function n(D, T) {
              return D && typeof D.type == "string" && (!T || T.includes(D.type));
            }
            function u(D, T, m) {
              return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
            }
            function i(D, T, m) {
              Object.defineProperty(D, T, { get: m, enumerable: false });
            }
            function l(D, T) {
              let m = 0, C = T.length;
              for (let o = D.position.end.offset - 1; o < C; o++) {
                let d = T[o];
                if (d === `
` && m++, m === 1 && /\S/.test(d))
                  return false;
                if (m === 2)
                  return true;
              }
              return false;
            }
            function p(D) {
              switch (D.getValue().type) {
                case "tag":
                case "anchor":
                case "comment":
                  return false;
              }
              let m = D.stack.length;
              for (let C = 1; C < m; C++) {
                let o = D.stack[C], d = D.stack[C - 1];
                if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1)
                  return false;
              }
              return true;
            }
            function y(D) {
              return s(D.children) ? y(t(D.children)) : D;
            }
            function h(D) {
              return D.value.trim() === "prettier-ignore";
            }
            function g(D) {
              let T = D.getValue();
              if (T.type === "documentBody") {
                let m = D.getParentNode();
                return N(m.head) && h(t(m.head.endComments));
              }
              return F(T) && h(t(T.leadingComments));
            }
            function c(D) {
              return !s(D.children) && !f2(D);
            }
            function f2(D) {
              return F(D) || _(D) || w(D) || E(D) || N(D);
            }
            function F(D) {
              return s(D == null ? void 0 : D.leadingComments);
            }
            function _(D) {
              return s(D == null ? void 0 : D.middleComments);
            }
            function w(D) {
              return D == null ? void 0 : D.indicatorComment;
            }
            function E(D) {
              return D == null ? void 0 : D.trailingComment;
            }
            function N(D) {
              return s(D == null ? void 0 : D.endComments);
            }
            function x(D) {
              let T = [], m;
              for (let C of D.split(/( +)/))
                C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
              return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
            }
            function I(D, T, m) {
              let C = T.split(`
`).map((o, d, v) => d === 0 && d === v.length - 1 ? o : d !== 0 && d !== v.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
              return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x(o)).reduce((o, d, v) => v !== 0 && C[v - 1].length > 0 && d.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
            }
            function P(D, T) {
              let { parentIndent: m, isLastDescendant: C, options: o } = T, d = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
              if (D.indent === null) {
                let B = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
                v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
              } else
                v = D.indent - 1 + m;
              let S = d.split(`
`).map((B) => B.slice(v));
              if (o.proseWrap === "preserve" || D.type === "blockLiteral")
                return b(S.map((B) => B.length === 0 ? [] : [B]));
              return b(S.map((B) => B.length === 0 ? [] : x(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
              function b(B) {
                if (D.chomping === "keep")
                  return t(B).length === 0 ? B.slice(0, -1) : B;
                let k = 0;
                for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--)
                  k++;
                return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
              }
            }
            function $(D) {
              if (!D)
                return true;
              switch (D.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = { getLast: t, getAncestorCount: a2, isNode: n, isEmptyNode: c, isInlineNode: $, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: F, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: E, hasEndComments: N };
          } }), Mg = te({ "src/language-yaml/print-preprocess.js"(e, r) {
            "use strict";
            ne();
            var { defineShortcut: t, mapNode: s } = $t();
            function a2(u) {
              return s(u, n);
            }
            function n(u) {
              switch (u.type) {
                case "document":
                  t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                  break;
                case "documentBody":
                case "sequenceItem":
                case "flowSequenceItem":
                case "mappingKey":
                case "mappingValue":
                  t(u, "content", () => u.children[0]);
                  break;
                case "mappingItem":
                case "flowMappingItem":
                  t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                  break;
              }
              return u;
            }
            r.exports = a2;
          } }), Mr = te({ "src/language-yaml/print/misc.js"(e, r) {
            "use strict";
            ne();
            var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a2, isNextLineEmpty: n, isNode: u } = $t(), i = /* @__PURE__ */ new WeakMap();
            function l(h, g) {
              let c = h.getValue(), f2 = h.stack[0], F;
              return i.has(f2) ? F = i.get(f2) : (F = /* @__PURE__ */ new Set(), i.set(f2, F)), !F.has(c.position.end.line) && (F.add(c.position.end.line), n(c, g) && !p(h.getParentNode())) ? t : "";
            }
            function p(h) {
              return a2(h) && !u(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
            }
            function y(h, g) {
              return s(" ".repeat(h), g);
            }
            r.exports = { alignWithSpaces: y, shouldPrintEndComments: p, printNextEmptyLine: l };
          } }), Rg = te({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
            "use strict";
            ne();
            var { builders: { ifBreak: t, line: s, softline: a2, hardline: n, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p } = $t(), { printNextEmptyLine: y, alignWithSpaces: h } = Mr();
            function g(f2, F, _) {
              let w = f2.getValue(), E = w.type === "flowMapping", N = E ? "{" : "[", x = E ? "}" : "]", I = a2;
              E && w.children.length > 0 && _.bracketSpacing && (I = s);
              let P = l(w.children), $ = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
              return [N, h(_.tabWidth, [I, c(f2, F, _), _.trailingComma === "none" ? "" : t(","), p(w) ? [n, u(n, f2.map(F, "endComments"))] : ""]), $ ? "" : I, x];
            }
            function c(f2, F, _) {
              let w = f2.getValue();
              return f2.map((N, x) => [F(), x === w.children.length - 1 ? "" : [",", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? y(N, _.originalText) : ""]], "children");
            }
            r.exports = { printFlowMapping: g, printFlowSequence: g };
          } }), $g = te({ "src/language-yaml/print/mapping-item.js"(e, r) {
            "use strict";
            ne();
            var { builders: { conditionalGroup: t, group: s, hardline: a2, ifBreak: n, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: y, hasEndComments: h, isNode: g, isEmptyNode: c, isInlineNode: f2 } = $t(), { alignWithSpaces: F } = Mr();
            function _(x, I, P, $, D) {
              let { key: T, value: m } = x, C = c(T), o = c(m);
              if (C && o)
                return ": ";
              let d = $("key"), v = E(x) ? " " : "";
              if (o)
                return x.type === "flowMappingItem" && I.type === "flowMapping" ? d : x.type === "mappingItem" && w(T.content, D) && !y(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, v, ":"] : ["? ", F(2, d)];
              let S = $("value");
              if (C)
                return [": ", F(2, S)];
              if (l(m) || !f2(T.content))
                return ["? ", F(2, d), a2, u("", P.map($, "value", "leadingComments").map((q) => [q, a2])), ": ", F(2, S)];
              if (N(T.content) && !l(T.content) && !p(T.content) && !y(T.content) && !h(T) && !l(m.content) && !p(m.content) && !h(m) && w(m.content, D))
                return [d, v, ": ", S];
              let b = Symbol("mappingKey"), B = s([n("? "), s(F(2, d), { id: b })]), k = [a2, ": ", F(2, S)], M = [v, ":"];
              l(m.content) || h(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(T.content) && f2(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M.push(a2) : m.content && M.push(i), M.push(S);
              let R = F(D.tabWidth, M);
              return w(T.content, D) && !l(T.content) && !p(T.content) && !h(T) ? t([[d, R]]) : t([[B, n(k, R, { groupId: b })]]);
            }
            function w(x, I) {
              if (!x)
                return true;
              switch (x.type) {
                case "plain":
                case "quoteSingle":
                case "quoteDouble":
                  break;
                case "alias":
                  return true;
                default:
                  return false;
              }
              if (I.proseWrap === "preserve")
                return x.position.start.line === x.position.end.line;
              if (/\\$/m.test(I.originalText.slice(x.position.start.offset, x.position.end.offset)))
                return false;
              switch (I.proseWrap) {
                case "never":
                  return !x.value.includes(`
`);
                case "always":
                  return !/[\n ]/.test(x.value);
                default:
                  return false;
              }
            }
            function E(x) {
              return x.key.content && x.key.content.type === "alias";
            }
            function N(x) {
              if (!x)
                return true;
              switch (x.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                  return x.position.start.line === x.position.end.line;
                case "alias":
                  return true;
                default:
                  return false;
              }
            }
            r.exports = _;
          } }), Vg = te({ "src/language-yaml/print/block.js"(e, r) {
            "use strict";
            ne();
            var { builders: { dedent: t, dedentToRoot: s, fill: a2, hardline: n, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h, getBlockValueLineContents: g, hasIndicatorComment: c, isLastDescendantNode: f2, isNode: F } = $t(), { alignWithSpaces: _ } = Mr();
            function w(E, N, x) {
              let I = E.getValue(), P = h(E, (C) => F(C, ["sequence", "mapping"])), $ = f2(E), D = [I.type === "blockFolded" ? ">" : "|"];
              I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c(I) && D.push(" ", N("indicatorComment"));
              let T = g(I, { parentIndent: P, isLastDescendant: $, options: x }), m = [];
              for (let [C, o] of T.entries())
                C === 0 && m.push(n), m.push(a2(y(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I.chomping === "keep" && $ && m.push(s(o.length === 0 ? n : l));
              return I.indent === null ? D.push(t(_(x.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;
            }
            r.exports = w;
          } }), Wg = te({ "src/language-yaml/printer-yaml.js"(e, r) {
            "use strict";
            ne();
            var { builders: { breakParent: t, fill: s, group: a2, hardline: n, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: y, replaceTextEndOfLine: h } } = qe(), { isPreviousLineEmpty: g } = Ue(), { insertPragma: c, isPragma: f2 } = Og(), { locStart: F } = jg(), _ = qg(), { getFlowScalarLineContents: w, getLastDescendantNode: E, hasLeadingComments: N, hasMiddleComments: x, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $, isLastDescendantNode: D, isNode: T, isInlineNode: m } = $t(), C = Mg(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: v } = Mr(), { printFlowMapping: S, printFlowSequence: b } = Rg(), B = $g(), k = Vg();
            function M(j, Y, ie) {
              let ee = j.getValue(), ce = [];
              ee.type !== "mappingValue" && N(ee) && ce.push([u(n, j.map(ie, "leadingComments")), n]);
              let { tag: W, anchor: K } = ee;
              W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
              let de = "";
              T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = d(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x(ee) ? ce.push(n) : ce.push(" ")), x(ee) && ce.push([ee.middleComments.length === 1 ? "" : n, u(n, j.map(ie, "middleComments")), n]);
              let ue = j.getParentNode();
              return $(j) ? ce.push(h(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p)) : ce.push(a2(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee) ? "" : t, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe) => [g(Y.originalText, Fe.getValue(), F) ? n : "", ie()], "endComments"))])), ce.push(de), ce;
            }
            function R(j, Y, ie, ee, ce) {
              switch (j.type) {
                case "root": {
                  let { children: W } = j, K = [];
                  ie.each((ue, Fe) => {
                    let z = W[Fe], U = W[Fe + 1];
                    Fe !== 0 && K.push(n), K.push(ce()), J(z, U) ? (K.push(n, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U && !I(U.head) && K.push(n, "---");
                  }, "children");
                  let de = E(j);
                  return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n), K;
                }
                case "document": {
                  let W = Y.children[ie.getName() + 1], K = [];
                  return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q(j) && K.push(ce("body")), u(n, K);
                }
                case "documentHead":
                  return u(n, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
                case "documentBody": {
                  let { children: W, endComments: K } = j, de = "";
                  if (W.length > 0 && K.length > 0) {
                    let ue = E(j);
                    T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n, n]) : de = n;
                  }
                  return [u(n, ie.map(ce, "children")), de, u(n, ie.map(ce, "endComments"))];
                }
                case "directive":
                  return ["%", u(" ", [j.name, ...j.parameters])];
                case "comment":
                  return ["#", j.value];
                case "alias":
                  return ["*", j.value];
                case "tag":
                  return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
                case "anchor":
                  return ["&", j.value];
                case "plain":
                  return Q(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
                case "quoteDouble":
                case "quoteSingle": {
                  let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
                  if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
                    let Fe = j.type === "quoteDouble" ? K : W;
                    return [Fe, Q(j.type, de, ee), Fe];
                  }
                  if (de.includes(K))
                    return [W, Q(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
                  if (de.includes(W))
                    return [K, Q(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
                  let ue = ee.singleQuote ? W : K;
                  return [ue, Q(j.type, de, ee), ue];
                }
                case "blockFolded":
                case "blockLiteral":
                  return k(ie, ce, ee);
                case "mapping":
                case "sequence":
                  return u(n, ie.map(ce, "children"));
                case "sequenceItem":
                  return ["- ", o(2, j.content ? ce("content") : "")];
                case "mappingKey":
                case "mappingValue":
                  return j.content ? ce("content") : "";
                case "mappingItem":
                case "flowMappingItem":
                  return B(j, Y, ie, ce, ee);
                case "flowMapping":
                  return S(ie, ce, ee);
                case "flowSequence":
                  return b(ie, ce, ee);
                case "flowSequenceItem":
                  return ce("content");
                default:
                  throw new Error(`Unexpected node type ${j.type}`);
              }
            }
            function q(j) {
              return j.body.children.length > 0 || P(j.body);
            }
            function J(j, Y) {
              return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
            }
            function L(j, Y, ie, ee) {
              return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(F(j), F(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J(j, Y) ? false : Y ? "root" : false;
            }
            function Q(j, Y, ie) {
              let ee = w(j, Y, ie);
              return u(n, ee.map((ce) => s(y(u(i, ce)))));
            }
            function V(j, Y) {
              if (T(Y))
                switch (delete Y.position, Y.type) {
                  case "comment":
                    if (f2(Y.value))
                      return null;
                    break;
                  case "quoteDouble":
                  case "quoteSingle":
                    Y.type = "quote";
                    break;
                }
            }
            r.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c };
          } }), Hg = te({ "src/language-yaml/options.js"(e, r) {
            "use strict";
            ne();
            var t = Mt();
            r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
          } }), Gg = te({ "src/language-yaml/parsers.js"() {
            ne();
          } }), Ug = te({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
            r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
          } }), Jg = te({ "src/language-yaml/index.js"(e, r) {
            "use strict";
            ne();
            var t = _t(), s = Wg(), a2 = Hg(), n = Gg(), u = [t(Ug(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
            r.exports = { languages: u, printers: { yaml: s }, options: a2, parsers: n };
          } }), zg = te({ "src/languages.js"(e, r) {
            "use strict";
            ne(), r.exports = [Bd(), Ud(), eg(), ag(), dg(), Lg(), Jg()];
          } });
          ne();
          var { version: Xg } = Ia(), Ot = Gm(), { getSupportInfo: Kg } = Xn(), Yg = Um(), Qg = zg(), Zg = qe();
          function Nt(e) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return function() {
              for (var t = arguments.length, s = new Array(t), a2 = 0; a2 < t; a2++)
                s[a2] = arguments[a2];
              let n = s[r] || {}, u = n.plugins || [];
              return s[r] = Object.assign(Object.assign({}, n), {}, { plugins: [...Qg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
            };
          }
          var jn = Nt(Ot.formatWithCursor);
          jo.exports = { formatWithCursor: jn, format(e, r) {
            return jn(e, r).formatted;
          }, check(e, r) {
            let { formatted: t } = jn(e, r);
            return t === e;
          }, doc: Zg, getSupportInfo: Nt(Kg, 0), version: Xg, util: Yg, __debug: { parse: Nt(Ot.parse), formatAST: Nt(Ot.formatAST), formatDoc: Nt(Ot.formatDoc), printToDoc: Nt(Ot.printToDoc), printDocToString: Nt(Ot.printDocToString) } };
        });
        return e0();
      });
    }
  });

  // node_modules/prettier/parser-yaml.js
  var require_parser_yaml = __commonJS({
    "node_modules/prettier/parser-yaml.js"(exports, module) {
      (function(e) {
        if (typeof exports == "object" && typeof module == "object")
          module.exports = e();
        else if (typeof define == "function" && define.amd)
          define(e);
        else {
          var i = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
          i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.yaml = e();
        }
      })(function() {
        "use strict";
        var yt = (n, e) => () => (e || n((e = { exports: {} }).exports, e), e.exports);
        var ln = yt((un, at) => {
          var Ye = Object.defineProperty, bt = Object.getOwnPropertyDescriptor, De = Object.getOwnPropertyNames, wt = Object.prototype.hasOwnProperty, Ke = (n, e) => function() {
            return n && (e = (0, n[De(n)[0]])(n = 0)), e;
          }, D = (n, e) => function() {
            return e || (0, n[De(n)[0]])((e = { exports: {} }).exports, e), e.exports;
          }, St = (n, e) => {
            for (var r in e)
              Ye(n, r, { get: e[r], enumerable: true });
          }, Et = (n, e, r, c) => {
            if (e && typeof e == "object" || typeof e == "function")
              for (let h of De(e))
                !wt.call(n, h) && h !== r && Ye(n, h, { get: () => e[h], enumerable: !(c = bt(e, h)) || c.enumerable });
            return n;
          }, se = (n) => Et(Ye({}, "__esModule", { value: true }), n), Te, Y = Ke({ "<define:process>"() {
            Te = { env: {}, argv: [] };
          } }), Mt = D({ "src/common/parser-create-error.js"(n, e) {
            "use strict";
            Y();
            function r(c, h) {
              let d = new SyntaxError(c + " (" + h.start.line + ":" + h.start.column + ")");
              return d.loc = h, d;
            }
            e.exports = r;
          } }), Ot = D({ "src/language-yaml/pragma.js"(n, e) {
            "use strict";
            Y();
            function r(d) {
              return /^\s*@(?:prettier|format)\s*$/.test(d);
            }
            function c(d) {
              return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(d);
            }
            function h(d) {
              return `# @format

${d}`;
            }
            e.exports = { isPragma: r, hasPragma: c, insertPragma: h };
          } }), Lt = D({ "src/language-yaml/loc.js"(n, e) {
            "use strict";
            Y();
            function r(h) {
              return h.position.start.offset;
            }
            function c(h) {
              return h.position.end.offset;
            }
            e.exports = { locStart: r, locEnd: c };
          } }), te = {};
          St(te, { __assign: () => qe, __asyncDelegator: () => Yt, __asyncGenerator: () => jt, __asyncValues: () => Dt, __await: () => Ce, __awaiter: () => Pt, __classPrivateFieldGet: () => Qt, __classPrivateFieldSet: () => Ut, __createBinding: () => Rt, __decorate: () => Tt, __exportStar: () => qt, __extends: () => At, __generator: () => It, __importDefault: () => Vt, __importStar: () => Wt, __makeTemplateObject: () => Ft, __metadata: () => kt, __param: () => Ct, __read: () => Je, __rest: () => Nt, __spread: () => $t, __spreadArrays: () => Bt, __values: () => je });
          function At(n, e) {
            Re(n, e);
            function r() {
              this.constructor = n;
            }
            n.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
          }
          function Nt(n, e) {
            var r = {};
            for (var c in n)
              Object.prototype.hasOwnProperty.call(n, c) && e.indexOf(c) < 0 && (r[c] = n[c]);
            if (n != null && typeof Object.getOwnPropertySymbols == "function")
              for (var h = 0, c = Object.getOwnPropertySymbols(n); h < c.length; h++)
                e.indexOf(c[h]) < 0 && Object.prototype.propertyIsEnumerable.call(n, c[h]) && (r[c[h]] = n[c[h]]);
            return r;
          }
          function Tt(n, e, r, c) {
            var h = arguments.length, d = h < 3 ? e : c === null ? c = Object.getOwnPropertyDescriptor(e, r) : c, y;
            if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
              d = Reflect.decorate(n, e, r, c);
            else
              for (var E = n.length - 1; E >= 0; E--)
                (y = n[E]) && (d = (h < 3 ? y(d) : h > 3 ? y(e, r, d) : y(e, r)) || d);
            return h > 3 && d && Object.defineProperty(e, r, d), d;
          }
          function Ct(n, e) {
            return function(r, c) {
              e(r, c, n);
            };
          }
          function kt(n, e) {
            if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
              return Reflect.metadata(n, e);
          }
          function Pt(n, e, r, c) {
            function h(d) {
              return d instanceof r ? d : new r(function(y) {
                y(d);
              });
            }
            return new (r || (r = Promise))(function(d, y) {
              function E(M) {
                try {
                  S(c.next(M));
                } catch (T) {
                  y(T);
                }
              }
              function I(M) {
                try {
                  S(c.throw(M));
                } catch (T) {
                  y(T);
                }
              }
              function S(M) {
                M.done ? d(M.value) : h(M.value).then(E, I);
              }
              S((c = c.apply(n, e || [])).next());
            });
          }
          function It(n, e) {
            var r = { label: 0, sent: function() {
              if (d[0] & 1)
                throw d[1];
              return d[1];
            }, trys: [], ops: [] }, c, h, d, y;
            return y = { next: E(0), throw: E(1), return: E(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
              return this;
            }), y;
            function E(S) {
              return function(M) {
                return I([S, M]);
              };
            }
            function I(S) {
              if (c)
                throw new TypeError("Generator is already executing.");
              for (; r; )
                try {
                  if (c = 1, h && (d = S[0] & 2 ? h.return : S[0] ? h.throw || ((d = h.return) && d.call(h), 0) : h.next) && !(d = d.call(h, S[1])).done)
                    return d;
                  switch (h = 0, d && (S = [S[0] & 2, d.value]), S[0]) {
                    case 0:
                    case 1:
                      d = S;
                      break;
                    case 4:
                      return r.label++, { value: S[1], done: false };
                    case 5:
                      r.label++, h = S[1], S = [0];
                      continue;
                    case 7:
                      S = r.ops.pop(), r.trys.pop();
                      continue;
                    default:
                      if (d = r.trys, !(d = d.length > 0 && d[d.length - 1]) && (S[0] === 6 || S[0] === 2)) {
                        r = 0;
                        continue;
                      }
                      if (S[0] === 3 && (!d || S[1] > d[0] && S[1] < d[3])) {
                        r.label = S[1];
                        break;
                      }
                      if (S[0] === 6 && r.label < d[1]) {
                        r.label = d[1], d = S;
                        break;
                      }
                      if (d && r.label < d[2]) {
                        r.label = d[2], r.ops.push(S);
                        break;
                      }
                      d[2] && r.ops.pop(), r.trys.pop();
                      continue;
                  }
                  S = e.call(n, r);
                } catch (M) {
                  S = [6, M], h = 0;
                } finally {
                  c = d = 0;
                }
              if (S[0] & 5)
                throw S[1];
              return { value: S[0] ? S[1] : void 0, done: true };
            }
          }
          function Rt(n, e, r, c) {
            c === void 0 && (c = r), n[c] = e[r];
          }
          function qt(n, e) {
            for (var r in n)
              r !== "default" && !e.hasOwnProperty(r) && (e[r] = n[r]);
          }
          function je(n) {
            var e = typeof Symbol == "function" && Symbol.iterator, r = e && n[e], c = 0;
            if (r)
              return r.call(n);
            if (n && typeof n.length == "number")
              return { next: function() {
                return n && c >= n.length && (n = void 0), { value: n && n[c++], done: !n };
              } };
            throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }
          function Je(n, e) {
            var r = typeof Symbol == "function" && n[Symbol.iterator];
            if (!r)
              return n;
            var c = r.call(n), h, d = [], y;
            try {
              for (; (e === void 0 || e-- > 0) && !(h = c.next()).done; )
                d.push(h.value);
            } catch (E) {
              y = { error: E };
            } finally {
              try {
                h && !h.done && (r = c.return) && r.call(c);
              } finally {
                if (y)
                  throw y.error;
              }
            }
            return d;
          }
          function $t() {
            for (var n = [], e = 0; e < arguments.length; e++)
              n = n.concat(Je(arguments[e]));
            return n;
          }
          function Bt() {
            for (var n = 0, e = 0, r = arguments.length; e < r; e++)
              n += arguments[e].length;
            for (var c = Array(n), h = 0, e = 0; e < r; e++)
              for (var d = arguments[e], y = 0, E = d.length; y < E; y++, h++)
                c[h] = d[y];
            return c;
          }
          function Ce(n) {
            return this instanceof Ce ? (this.v = n, this) : new Ce(n);
          }
          function jt(n, e, r) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var c = r.apply(n, e || []), h, d = [];
            return h = {}, y("next"), y("throw"), y("return"), h[Symbol.asyncIterator] = function() {
              return this;
            }, h;
            function y(P) {
              c[P] && (h[P] = function(C) {
                return new Promise(function(q, R) {
                  d.push([P, C, q, R]) > 1 || E(P, C);
                });
              });
            }
            function E(P, C) {
              try {
                I(c[P](C));
              } catch (q) {
                T(d[0][3], q);
              }
            }
            function I(P) {
              P.value instanceof Ce ? Promise.resolve(P.value.v).then(S, M) : T(d[0][2], P);
            }
            function S(P) {
              E("next", P);
            }
            function M(P) {
              E("throw", P);
            }
            function T(P, C) {
              P(C), d.shift(), d.length && E(d[0][0], d[0][1]);
            }
          }
          function Yt(n) {
            var e, r;
            return e = {}, c("next"), c("throw", function(h) {
              throw h;
            }), c("return"), e[Symbol.iterator] = function() {
              return this;
            }, e;
            function c(h, d) {
              e[h] = n[h] ? function(y) {
                return (r = !r) ? { value: Ce(n[h](y)), done: h === "return" } : d ? d(y) : y;
              } : d;
            }
          }
          function Dt(n) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var e = n[Symbol.asyncIterator], r;
            return e ? e.call(n) : (n = typeof je == "function" ? je(n) : n[Symbol.iterator](), r = {}, c("next"), c("throw"), c("return"), r[Symbol.asyncIterator] = function() {
              return this;
            }, r);
            function c(d) {
              r[d] = n[d] && function(y) {
                return new Promise(function(E, I) {
                  y = n[d](y), h(E, I, y.done, y.value);
                });
              };
            }
            function h(d, y, E, I) {
              Promise.resolve(I).then(function(S) {
                d({ value: S, done: E });
              }, y);
            }
          }
          function Ft(n, e) {
            return Object.defineProperty ? Object.defineProperty(n, "raw", { value: e }) : n.raw = e, n;
          }
          function Wt(n) {
            if (n && n.__esModule)
              return n;
            var e = {};
            if (n != null)
              for (var r in n)
                Object.hasOwnProperty.call(n, r) && (e[r] = n[r]);
            return e.default = n, e;
          }
          function Vt(n) {
            return n && n.__esModule ? n : { default: n };
          }
          function Qt(n, e) {
            if (!e.has(n))
              throw new TypeError("attempted to get private field on non-instance");
            return e.get(n);
          }
          function Ut(n, e, r) {
            if (!e.has(n))
              throw new TypeError("attempted to set private field on non-instance");
            return e.set(n, r), r;
          }
          var Re, qe, ie = Ke({ "node_modules/tslib/tslib.es6.js"() {
            Y(), Re = function(n, e) {
              return Re = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, c) {
                r.__proto__ = c;
              } || function(r, c) {
                for (var h in c)
                  c.hasOwnProperty(h) && (r[h] = c[h]);
              }, Re(n, e);
            }, qe = function() {
              return qe = Object.assign || function(e) {
                for (var r, c = 1, h = arguments.length; c < h; c++) {
                  r = arguments[c];
                  for (var d in r)
                    Object.prototype.hasOwnProperty.call(r, d) && (e[d] = r[d]);
                }
                return e;
              }, qe.apply(this, arguments);
            };
          } }), Kt = D({ "node_modules/yaml-unist-parser/node_modules/lines-and-columns/build/index.js"(n) {
            "use strict";
            Y(), n.__esModule = true, n.LinesAndColumns = void 0;
            var e = `
`, r = "\r", c = function() {
              function h(d) {
                this.string = d;
                for (var y = [0], E = 0; E < d.length; )
                  switch (d[E]) {
                    case e:
                      E += e.length, y.push(E);
                      break;
                    case r:
                      E += r.length, d[E] === e && (E += e.length), y.push(E);
                      break;
                    default:
                      E++;
                      break;
                  }
                this.offsets = y;
              }
              return h.prototype.locationForIndex = function(d) {
                if (d < 0 || d > this.string.length)
                  return null;
                for (var y = 0, E = this.offsets; E[y + 1] <= d; )
                  y++;
                var I = d - E[y];
                return { line: y, column: I };
              }, h.prototype.indexForLocation = function(d) {
                var y = d.line, E = d.column;
                return y < 0 || y >= this.offsets.length || E < 0 || E > this.lengthOfLine(y) ? null : this.offsets[y] + E;
              }, h.prototype.lengthOfLine = function(d) {
                var y = this.offsets[d], E = d === this.offsets.length - 1 ? this.string.length : this.offsets[d + 1];
                return E - y;
              }, h;
            }();
            n.LinesAndColumns = c, n.default = c;
          } }), Jt = D({ "node_modules/yaml-unist-parser/lib/utils/define-parents.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c) {
              c === void 0 && (c = null), "children" in r && r.children.forEach(function(h) {
                return e(h, r);
              }), "anchor" in r && r.anchor && e(r.anchor, r), "tag" in r && r.tag && e(r.tag, r), "leadingComments" in r && r.leadingComments.forEach(function(h) {
                return e(h, r);
              }), "middleComments" in r && r.middleComments.forEach(function(h) {
                return e(h, r);
              }), "indicatorComment" in r && r.indicatorComment && e(r.indicatorComment, r), "trailingComment" in r && r.trailingComment && e(r.trailingComment, r), "endComments" in r && r.endComments.forEach(function(h) {
                return e(h, r);
              }), Object.defineProperty(r, "_parent", { value: c, enumerable: false });
            }
            n.defineParents = e;
          } }), Fe = D({ "node_modules/yaml-unist-parser/lib/utils/get-point-text.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r) {
              return r.line + ":" + r.column;
            }
            n.getPointText = e;
          } }), xt = D({ "node_modules/yaml-unist-parser/lib/attach.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Jt(), r = Fe();
            function c(S) {
              e.defineParents(S);
              var M = h(S), T = S.children.slice();
              S.comments.sort(function(P, C) {
                return P.position.start.offset - C.position.end.offset;
              }).filter(function(P) {
                return !P._parent;
              }).forEach(function(P) {
                for (; T.length > 1 && P.position.start.line > T[0].position.end.line; )
                  T.shift();
                y(P, M, T[0]);
              });
            }
            n.attachComments = c;
            function h(S) {
              for (var M = Array.from(new Array(S.position.end.line), function() {
                return {};
              }), T = 0, P = S.comments; T < P.length; T++) {
                var C = P[T];
                M[C.position.start.line - 1].comment = C;
              }
              return d(M, S), M;
            }
            function d(S, M) {
              if (M.position.start.offset !== M.position.end.offset) {
                if ("leadingComments" in M) {
                  var T = M.position.start, P = S[T.line - 1].leadingAttachableNode;
                  (!P || T.column < P.position.start.column) && (S[T.line - 1].leadingAttachableNode = M);
                }
                if ("trailingComment" in M && M.position.end.column > 1 && M.type !== "document" && M.type !== "documentHead") {
                  var C = M.position.end, q = S[C.line - 1].trailingAttachableNode;
                  (!q || C.column >= q.position.end.column) && (S[C.line - 1].trailingAttachableNode = M);
                }
                if (M.type !== "root" && M.type !== "document" && M.type !== "documentHead" && M.type !== "documentBody")
                  for (var R = M.position, T = R.start, C = R.end, B = [C.line].concat(T.line === C.line ? [] : T.line), U = 0, f2 = B; U < f2.length; U++) {
                    var i = f2[U], t = S[i - 1].trailingNode;
                    (!t || C.column >= t.position.end.column) && (S[i - 1].trailingNode = M);
                  }
                "children" in M && M.children.forEach(function(s) {
                  d(S, s);
                });
              }
            }
            function y(S, M, T) {
              var P = S.position.start.line, C = M[P - 1].trailingAttachableNode;
              if (C) {
                if (C.trailingComment)
                  throw new Error("Unexpected multiple trailing comment at " + r.getPointText(S.position.start));
                e.defineParents(S, C), C.trailingComment = S;
                return;
              }
              for (var q = P; q >= T.position.start.line; q--) {
                var R = M[q - 1].trailingNode, B = void 0;
                if (R)
                  B = R;
                else if (q !== P && M[q - 1].comment)
                  B = M[q - 1].comment._parent;
                else
                  continue;
                if ((B.type === "sequence" || B.type === "mapping") && (B = B.children[0]), B.type === "mappingItem") {
                  var U = B.children, f2 = U[0], i = U[1];
                  B = I(f2) ? f2 : i;
                }
                for (; ; ) {
                  if (E(B, S)) {
                    e.defineParents(S, B), B.endComments.push(S);
                    return;
                  }
                  if (!B._parent)
                    break;
                  B = B._parent;
                }
                break;
              }
              for (var q = P + 1; q <= T.position.end.line; q++) {
                var t = M[q - 1].leadingAttachableNode;
                if (t) {
                  e.defineParents(S, t), t.leadingComments.push(S);
                  return;
                }
              }
              var s = T.children[1];
              e.defineParents(S, s), s.endComments.push(S);
            }
            function E(S, M) {
              if (S.position.start.offset < M.position.start.offset && S.position.end.offset > M.position.end.offset)
                switch (S.type) {
                  case "flowMapping":
                  case "flowSequence":
                    return S.children.length === 0 || M.position.start.line > S.children[S.children.length - 1].position.end.line;
                }
              if (M.position.end.offset < S.position.end.offset)
                return false;
              switch (S.type) {
                case "sequenceItem":
                  return M.position.start.column > S.position.start.column;
                case "mappingKey":
                case "mappingValue":
                  return M.position.start.column > S._parent.position.start.column && (S.children.length === 0 || S.children.length === 1 && S.children[0].type !== "blockFolded" && S.children[0].type !== "blockLiteral") && (S.type === "mappingValue" || I(S));
                default:
                  return false;
              }
            }
            function I(S) {
              return S.position.start !== S.position.end && (S.children.length === 0 || S.position.start.offset !== S.children[0].position.start.offset);
            }
          } }), me = D({ "node_modules/yaml-unist-parser/lib/factories/node.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c) {
              return { type: r, position: c };
            }
            n.createNode = e;
          } }), Ht = D({ "node_modules/yaml-unist-parser/lib/factories/root.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = me();
            function c(h, d, y) {
              return e.__assign(e.__assign({}, r.createNode("root", h)), { children: d, comments: y });
            }
            n.createRoot = c;
          } }), Gt = D({ "node_modules/yaml-unist-parser/lib/preprocess.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r) {
              switch (r.type) {
                case "DOCUMENT":
                  for (var c = r.contents.length - 1; c >= 0; c--)
                    r.contents[c].type === "BLANK_LINE" ? r.contents.splice(c, 1) : e(r.contents[c]);
                  for (var c = r.directives.length - 1; c >= 0; c--)
                    r.directives[c].type === "BLANK_LINE" && r.directives.splice(c, 1);
                  break;
                case "FLOW_MAP":
                case "FLOW_SEQ":
                case "MAP":
                case "SEQ":
                  for (var c = r.items.length - 1; c >= 0; c--) {
                    var h = r.items[c];
                    "char" in h || (h.type === "BLANK_LINE" ? r.items.splice(c, 1) : e(h));
                  }
                  break;
                case "MAP_KEY":
                case "MAP_VALUE":
                case "SEQ_ITEM":
                  r.node && e(r.node);
                  break;
                case "ALIAS":
                case "BLANK_LINE":
                case "BLOCK_FOLDED":
                case "BLOCK_LITERAL":
                case "COMMENT":
                case "DIRECTIVE":
                case "PLAIN":
                case "QUOTE_DOUBLE":
                case "QUOTE_SINGLE":
                  break;
                default:
                  throw new Error("Unexpected node type " + JSON.stringify(r.type));
              }
            }
            n.removeCstBlankLine = e;
          } }), Oe = D({ "node_modules/yaml-unist-parser/lib/factories/leading-comment-attachable.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e() {
              return { leadingComments: [] };
            }
            n.createLeadingCommentAttachable = e;
          } }), $e = D({ "node_modules/yaml-unist-parser/lib/factories/trailing-comment-attachable.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r) {
              return r === void 0 && (r = null), { trailingComment: r };
            }
            n.createTrailingCommentAttachable = e;
          } }), Se = D({ "node_modules/yaml-unist-parser/lib/factories/comment-attachable.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Oe(), c = $e();
            function h() {
              return e.__assign(e.__assign({}, r.createLeadingCommentAttachable()), c.createTrailingCommentAttachable());
            }
            n.createCommentAttachable = h;
          } }), zt = D({ "node_modules/yaml-unist-parser/lib/factories/alias.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Se(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, c.createNode("alias", d)), r.createCommentAttachable()), y), { value: E });
            }
            n.createAlias = h;
          } }), Zt = D({ "node_modules/yaml-unist-parser/lib/transforms/alias.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = zt();
            function r(c, h) {
              var d = c.cstNode;
              return e.createAlias(h.transformRange({ origStart: d.valueRange.origStart - 1, origEnd: d.valueRange.origEnd }), h.transformContent(c), d.rawValue);
            }
            n.transformAlias = r;
          } }), Xt = D({ "node_modules/yaml-unist-parser/lib/factories/block-folded.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te));
            function r(c) {
              return e.__assign(e.__assign({}, c), { type: "blockFolded" });
            }
            n.createBlockFolded = r;
          } }), er = D({ "node_modules/yaml-unist-parser/lib/factories/block-value.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Oe(), c = me();
            function h(d, y, E, I, S, M) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, c.createNode("blockValue", d)), r.createLeadingCommentAttachable()), y), { chomping: E, indent: I, value: S, indicatorComment: M });
            }
            n.createBlockValue = h;
          } }), xe = D({ "node_modules/yaml-unist-parser/lib/constants.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e;
            (function(r) {
              r.Tag = "!", r.Anchor = "&", r.Comment = "#";
            })(e = n.PropLeadingCharacter || (n.PropLeadingCharacter = {}));
          } }), tr = D({ "node_modules/yaml-unist-parser/lib/factories/anchor.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = me();
            function c(h, d) {
              return e.__assign(e.__assign({}, r.createNode("anchor", h)), { value: d });
            }
            n.createAnchor = c;
          } }), We = D({ "node_modules/yaml-unist-parser/lib/factories/comment.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = me();
            function c(h, d) {
              return e.__assign(e.__assign({}, r.createNode("comment", h)), { value: d });
            }
            n.createComment = c;
          } }), rr = D({ "node_modules/yaml-unist-parser/lib/factories/content.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c, h) {
              return { anchor: c, tag: r, middleComments: h };
            }
            n.createContent = e;
          } }), nr = D({ "node_modules/yaml-unist-parser/lib/factories/tag.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = me();
            function c(h, d) {
              return e.__assign(e.__assign({}, r.createNode("tag", h)), { value: d });
            }
            n.createTag = c;
          } }), He = D({ "node_modules/yaml-unist-parser/lib/transforms/content.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = xe(), r = tr(), c = We(), h = rr(), d = nr();
            function y(E, I, S) {
              S === void 0 && (S = function() {
                return false;
              });
              for (var M = E.cstNode, T = [], P = null, C = null, q = null, R = 0, B = M.props; R < B.length; R++) {
                var U = B[R], f2 = I.text[U.origStart];
                switch (f2) {
                  case e.PropLeadingCharacter.Tag:
                    P = P || U, C = d.createTag(I.transformRange(U), E.tag);
                    break;
                  case e.PropLeadingCharacter.Anchor:
                    P = P || U, q = r.createAnchor(I.transformRange(U), M.anchor);
                    break;
                  case e.PropLeadingCharacter.Comment: {
                    var i = c.createComment(I.transformRange(U), I.text.slice(U.origStart + 1, U.origEnd));
                    I.comments.push(i), !S(i) && P && P.origEnd <= U.origStart && U.origEnd <= M.valueRange.origStart && T.push(i);
                    break;
                  }
                  default:
                    throw new Error("Unexpected leading character " + JSON.stringify(f2));
                }
              }
              return h.createContent(C, q, T);
            }
            n.transformContent = y;
          } }), Ge = D({ "node_modules/yaml-unist-parser/lib/transforms/block-value.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = er(), r = Fe(), c = He(), h;
            (function(y) {
              y.CLIP = "clip", y.STRIP = "strip", y.KEEP = "keep";
            })(h || (h = {}));
            function d(y, E) {
              var I = y.cstNode, S = 1, M = I.chomping === "CLIP" ? 0 : 1, T = I.header.origEnd - I.header.origStart, P = T - S - M !== 0, C = E.transformRange({ origStart: I.header.origStart, origEnd: I.valueRange.origEnd }), q = null, R = c.transformContent(y, E, function(B) {
                var U = C.start.offset < B.position.start.offset && B.position.end.offset < C.end.offset;
                if (!U)
                  return false;
                if (q)
                  throw new Error("Unexpected multiple indicator comments at " + r.getPointText(B.position.start));
                return q = B, true;
              });
              return e.createBlockValue(C, R, h[I.chomping], P ? I.blockIndent : null, I.strValue, q);
            }
            n.transformAstBlockValue = d;
          } }), sr = D({ "node_modules/yaml-unist-parser/lib/transforms/block-folded.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Xt(), r = Ge();
            function c(h, d) {
              return e.createBlockFolded(r.transformAstBlockValue(h, d));
            }
            n.transformBlockFolded = c;
          } }), ir = D({ "node_modules/yaml-unist-parser/lib/factories/block-literal.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te));
            function r(c) {
              return e.__assign(e.__assign({}, c), { type: "blockLiteral" });
            }
            n.createBlockLiteral = r;
          } }), ar = D({ "node_modules/yaml-unist-parser/lib/transforms/block-literal.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = ir(), r = Ge();
            function c(h, d) {
              return e.createBlockLiteral(r.transformAstBlockValue(h, d));
            }
            n.transformBlockLiteral = c;
          } }), or = D({ "node_modules/yaml-unist-parser/lib/transforms/comment.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = We();
            function r(c, h) {
              return e.createComment(h.transformRange(c.range), c.comment);
            }
            n.transformComment = r;
          } }), lr = D({ "node_modules/yaml-unist-parser/lib/factories/directive.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Se(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign({}, c.createNode("directive", d)), r.createCommentAttachable()), { name: y, parameters: E });
            }
            n.createDirective = h;
          } }), Ve = D({ "node_modules/yaml-unist-parser/lib/utils/extract-prop-comments.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = xe(), r = We();
            function c(h, d) {
              for (var y = 0, E = h.props; y < E.length; y++) {
                var I = E[y], S = d.text[I.origStart];
                switch (S) {
                  case e.PropLeadingCharacter.Comment:
                    d.comments.push(r.createComment(d.transformRange(I), d.text.slice(I.origStart + 1, I.origEnd)));
                    break;
                  default:
                    throw new Error("Unexpected leading character " + JSON.stringify(S));
                }
              }
            }
            n.extractPropComments = c;
          } }), cr = D({ "node_modules/yaml-unist-parser/lib/transforms/directive.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = lr(), r = Ve();
            function c(h, d) {
              return r.extractPropComments(h, d), e.createDirective(d.transformRange(h.range), h.name, h.parameters);
            }
            n.transformDirective = c;
          } }), ur = D({ "node_modules/yaml-unist-parser/lib/factories/document.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = me(), c = $e();
            function h(d, y, E, I) {
              return e.__assign(e.__assign(e.__assign({}, r.createNode("document", d)), c.createTrailingCommentAttachable(I)), { children: [y, E] });
            }
            n.createDocument = h;
          } }), Le = D({ "node_modules/yaml-unist-parser/lib/factories/position.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(c, h) {
              return { start: c, end: h };
            }
            n.createPosition = e;
            function r(c) {
              return { start: c, end: c };
            }
            n.createEmptyPosition = r;
          } }), Ee = D({ "node_modules/yaml-unist-parser/lib/factories/end-comment-attachable.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r) {
              return r === void 0 && (r = []), { endComments: r };
            }
            n.createEndCommentAttachable = e;
          } }), fr = D({ "node_modules/yaml-unist-parser/lib/factories/document-body.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Ee(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign({}, c.createNode("documentBody", d)), r.createEndCommentAttachable(E)), { children: y ? [y] : [] });
            }
            n.createDocumentBody = h;
          } }), Ae = D({ "node_modules/yaml-unist-parser/lib/utils/get-last.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r) {
              return r[r.length - 1];
            }
            n.getLast = e;
          } }), ze = D({ "node_modules/yaml-unist-parser/lib/utils/get-match-index.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c) {
              var h = r.match(c);
              return h ? h.index : -1;
            }
            n.getMatchIndex = e;
          } }), mr = D({ "node_modules/yaml-unist-parser/lib/transforms/document-body.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = fr(), c = Ae(), h = ze(), d = Fe();
            function y(S, M, T) {
              var P, C = S.cstNode, q = E(C, M, T), R = q.comments, B = q.endComments, U = q.documentTrailingComment, f2 = q.documentHeadTrailingComment, i = M.transformNode(S.contents), t = I(C, i, M), s = t.position, a2 = t.documentEndPoint;
              return (P = M.comments).push.apply(P, e.__spreadArrays(R, B)), { documentBody: r.createDocumentBody(s, i, B), documentEndPoint: a2, documentTrailingComment: U, documentHeadTrailingComment: f2 };
            }
            n.transformDocumentBody = y;
            function E(S, M, T) {
              for (var P = [], C = [], q = [], R = [], B = false, U = S.contents.length - 1; U >= 0; U--) {
                var f2 = S.contents[U];
                if (f2.type === "COMMENT") {
                  var i = M.transformNode(f2);
                  T && T.line === i.position.start.line ? R.unshift(i) : B ? P.unshift(i) : i.position.start.offset >= S.valueRange.origEnd ? q.unshift(i) : P.unshift(i);
                } else
                  B = true;
              }
              if (q.length > 1)
                throw new Error("Unexpected multiple document trailing comments at " + d.getPointText(q[1].position.start));
              if (R.length > 1)
                throw new Error("Unexpected multiple documentHead trailing comments at " + d.getPointText(R[1].position.start));
              return { comments: P, endComments: C, documentTrailingComment: c.getLast(q) || null, documentHeadTrailingComment: c.getLast(R) || null };
            }
            function I(S, M, T) {
              var P = h.getMatchIndex(T.text.slice(S.valueRange.origEnd), /^\.\.\./), C = P === -1 ? S.valueRange.origEnd : Math.max(0, S.valueRange.origEnd - 1);
              T.text[C - 1] === "\r" && C--;
              var q = T.transformRange({ origStart: M !== null ? M.position.start.offset : C, origEnd: C }), R = P === -1 ? q.end : T.transformOffset(S.valueRange.origEnd + 3);
              return { position: q, documentEndPoint: R };
            }
          } }), dr = D({ "node_modules/yaml-unist-parser/lib/factories/document-head.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Ee(), c = me(), h = $e();
            function d(y, E, I, S) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, c.createNode("documentHead", y)), r.createEndCommentAttachable(I)), h.createTrailingCommentAttachable(S)), { children: E });
            }
            n.createDocumentHead = d;
          } }), hr = D({ "node_modules/yaml-unist-parser/lib/transforms/document-head.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = dr(), c = ze();
            function h(E, I) {
              var S, M = E.cstNode, T = d(M, I), P = T.directives, C = T.comments, q = T.endComments, R = y(M, P, I), B = R.position, U = R.endMarkerPoint;
              (S = I.comments).push.apply(S, e.__spreadArrays(C, q));
              var f2 = function(i) {
                return i && I.comments.push(i), r.createDocumentHead(B, P, q, i);
              };
              return { createDocumentHeadWithTrailingComment: f2, documentHeadEndMarkerPoint: U };
            }
            n.transformDocumentHead = h;
            function d(E, I) {
              for (var S = [], M = [], T = [], P = false, C = E.directives.length - 1; C >= 0; C--) {
                var q = I.transformNode(E.directives[C]);
                q.type === "comment" ? P ? M.unshift(q) : T.unshift(q) : (P = true, S.unshift(q));
              }
              return { directives: S, comments: M, endComments: T };
            }
            function y(E, I, S) {
              var M = c.getMatchIndex(S.text.slice(0, E.valueRange.origStart), /---\s*$/);
              M > 0 && !/[\r\n]/.test(S.text[M - 1]) && (M = -1);
              var T = M === -1 ? { origStart: E.valueRange.origStart, origEnd: E.valueRange.origStart } : { origStart: M, origEnd: M + 3 };
              return I.length !== 0 && (T.origStart = I[0].position.start.offset), { position: S.transformRange(T), endMarkerPoint: M === -1 ? null : S.transformOffset(M) };
            }
          } }), gr = D({ "node_modules/yaml-unist-parser/lib/transforms/document.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = ur(), r = Le(), c = mr(), h = hr();
            function d(y, E) {
              var I = h.transformDocumentHead(y, E), S = I.createDocumentHeadWithTrailingComment, M = I.documentHeadEndMarkerPoint, T = c.transformDocumentBody(y, E, M), P = T.documentBody, C = T.documentEndPoint, q = T.documentTrailingComment, R = T.documentHeadTrailingComment, B = S(R);
              return q && E.comments.push(q), e.createDocument(r.createPosition(B.position.start, C), B, P, q);
            }
            n.transformDocument = d;
          } }), Ze = D({ "node_modules/yaml-unist-parser/lib/factories/flow-collection.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Se(), c = Ee(), h = me();
            function d(y, E, I) {
              return e.__assign(e.__assign(e.__assign(e.__assign(e.__assign({}, h.createNode("flowCollection", y)), r.createCommentAttachable()), c.createEndCommentAttachable()), E), { children: I });
            }
            n.createFlowCollection = d;
          } }), pr = D({ "node_modules/yaml-unist-parser/lib/factories/flow-mapping.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Ze();
            function c(h, d, y) {
              return e.__assign(e.__assign({}, r.createFlowCollection(h, d, y)), { type: "flowMapping" });
            }
            n.createFlowMapping = c;
          } }), Xe = D({ "node_modules/yaml-unist-parser/lib/factories/flow-mapping-item.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Oe(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign({}, c.createNode("flowMappingItem", d)), r.createLeadingCommentAttachable()), { children: [y, E] });
            }
            n.createFlowMappingItem = h;
          } }), Be = D({ "node_modules/yaml-unist-parser/lib/utils/extract-comments.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c) {
              for (var h = [], d = 0, y = r; d < y.length; d++) {
                var E = y[d];
                E && "type" in E && E.type === "COMMENT" ? c.comments.push(c.transformNode(E)) : h.push(E);
              }
              return h;
            }
            n.extractComments = e;
          } }), et = D({ "node_modules/yaml-unist-parser/lib/utils/get-flow-map-item-additional-ranges.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r) {
              var c = ["?", ":"].map(function(y) {
                var E = r.find(function(I) {
                  return "char" in I && I.char === y;
                });
                return E ? { origStart: E.origOffset, origEnd: E.origOffset + 1 } : null;
              }), h = c[0], d = c[1];
              return { additionalKeyRange: h, additionalValueRange: d };
            }
            n.getFlowMapItemAdditionalRanges = e;
          } }), tt = D({ "node_modules/yaml-unist-parser/lib/utils/create-slicer.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c) {
              var h = c;
              return function(d) {
                return r.slice(h, h = d);
              };
            }
            n.createSlicer = e;
          } }), rt = D({ "node_modules/yaml-unist-parser/lib/utils/group-cst-flow-collection-items.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = tt();
            function r(c) {
              for (var h = [], d = e.createSlicer(c, 1), y = false, E = 1; E < c.length - 1; E++) {
                var I = c[E];
                if ("char" in I && I.char === ",") {
                  h.push(d(E)), d(E + 1), y = false;
                  continue;
                }
                y = true;
              }
              return y && h.push(d(c.length - 1)), h;
            }
            n.groupCstFlowCollectionItems = r;
          } }), _r = D({ "node_modules/yaml-unist-parser/lib/factories/mapping-key.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Ee(), c = me(), h = $e();
            function d(y, E) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, c.createNode("mappingKey", y)), h.createTrailingCommentAttachable()), r.createEndCommentAttachable()), { children: E ? [E] : [] });
            }
            n.createMappingKey = d;
          } }), vr = D({ "node_modules/yaml-unist-parser/lib/factories/mapping-value.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Se(), c = Ee(), h = me();
            function d(y, E) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, h.createNode("mappingValue", y)), r.createCommentAttachable()), c.createEndCommentAttachable()), { children: E ? [E] : [] });
            }
            n.createMappingValue = d;
          } }), Qe = D({ "node_modules/yaml-unist-parser/lib/transforms/pair.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = _r(), r = vr(), c = Le();
            function h(d, y, E, I, S) {
              var M = y.transformNode(d.key), T = y.transformNode(d.value), P = M || I ? e.createMappingKey(y.transformRange({ origStart: I ? I.origStart : M.position.start.offset, origEnd: M ? M.position.end.offset : I.origStart + 1 }), M) : null, C = T || S ? r.createMappingValue(y.transformRange({ origStart: S ? S.origStart : T.position.start.offset, origEnd: T ? T.position.end.offset : S.origStart + 1 }), T) : null;
              return E(c.createPosition(P ? P.position.start : C.position.start, C ? C.position.end : P.position.end), P || e.createMappingKey(c.createEmptyPosition(C.position.start), null), C || r.createMappingValue(c.createEmptyPosition(P.position.end), null));
            }
            n.transformAstPair = h;
          } }), yr = D({ "node_modules/yaml-unist-parser/lib/transforms/flow-map.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = pr(), r = Xe(), c = Be(), h = et(), d = Ae(), y = rt(), E = Qe();
            function I(S, M) {
              var T = c.extractComments(S.cstNode.items, M), P = y.groupCstFlowCollectionItems(T), C = S.items.map(function(B, U) {
                var f2 = P[U], i = h.getFlowMapItemAdditionalRanges(f2), t = i.additionalKeyRange, s = i.additionalValueRange;
                return E.transformAstPair(B, M, r.createFlowMappingItem, t, s);
              }), q = T[0], R = d.getLast(T);
              return e.createFlowMapping(M.transformRange({ origStart: q.origOffset, origEnd: R.origOffset + 1 }), M.transformContent(S), C);
            }
            n.transformFlowMap = I;
          } }), br = D({ "node_modules/yaml-unist-parser/lib/factories/flow-sequence.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Ze();
            function c(h, d, y) {
              return e.__assign(e.__assign({}, r.createFlowCollection(h, d, y)), { type: "flowSequence" });
            }
            n.createFlowSequence = c;
          } }), wr = D({ "node_modules/yaml-unist-parser/lib/factories/flow-sequence-item.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = me();
            function c(h, d) {
              return e.__assign(e.__assign({}, r.createNode("flowSequenceItem", h)), { children: [d] });
            }
            n.createFlowSequenceItem = c;
          } }), Sr = D({ "node_modules/yaml-unist-parser/lib/transforms/flow-seq.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Xe(), r = br(), c = wr(), h = Le(), d = Be(), y = et(), E = Ae(), I = rt(), S = Qe();
            function M(T, P) {
              var C = d.extractComments(T.cstNode.items, P), q = I.groupCstFlowCollectionItems(C), R = T.items.map(function(f2, i) {
                if (f2.type !== "PAIR") {
                  var t = P.transformNode(f2);
                  return c.createFlowSequenceItem(h.createPosition(t.position.start, t.position.end), t);
                } else {
                  var s = q[i], a2 = y.getFlowMapItemAdditionalRanges(s), m = a2.additionalKeyRange, g = a2.additionalValueRange;
                  return S.transformAstPair(f2, P, e.createFlowMappingItem, m, g);
                }
              }), B = C[0], U = E.getLast(C);
              return r.createFlowSequence(P.transformRange({ origStart: B.origOffset, origEnd: U.origOffset + 1 }), P.transformContent(T), R);
            }
            n.transformFlowSeq = M;
          } }), Er = D({ "node_modules/yaml-unist-parser/lib/factories/mapping.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Oe(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, c.createNode("mapping", d)), r.createLeadingCommentAttachable()), y), { children: E });
            }
            n.createMapping = h;
          } }), Mr = D({ "node_modules/yaml-unist-parser/lib/factories/mapping-item.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Oe(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign({}, c.createNode("mappingItem", d)), r.createLeadingCommentAttachable()), { children: [y, E] });
            }
            n.createMappingItem = h;
          } }), Or = D({ "node_modules/yaml-unist-parser/lib/transforms/map.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Er(), r = Mr(), c = Le(), h = tt(), d = Be(), y = Ve(), E = Ae(), I = Qe();
            function S(T, P) {
              var C = T.cstNode;
              C.items.filter(function(U) {
                return U.type === "MAP_KEY" || U.type === "MAP_VALUE";
              }).forEach(function(U) {
                return y.extractPropComments(U, P);
              });
              var q = d.extractComments(C.items, P), R = M(q), B = T.items.map(function(U, f2) {
                var i = R[f2], t = i[0].type === "MAP_VALUE" ? [null, i[0].range] : [i[0].range, i.length === 1 ? null : i[1].range], s = t[0], a2 = t[1];
                return I.transformAstPair(U, P, r.createMappingItem, s, a2);
              });
              return e.createMapping(c.createPosition(B[0].position.start, E.getLast(B).position.end), P.transformContent(T), B);
            }
            n.transformMap = S;
            function M(T) {
              for (var P = [], C = h.createSlicer(T, 0), q = false, R = 0; R < T.length; R++) {
                var B = T[R];
                if (B.type === "MAP_VALUE") {
                  P.push(C(R + 1)), q = false;
                  continue;
                }
                q && P.push(C(R)), q = true;
              }
              return q && P.push(C(1 / 0)), P;
            }
          } }), Lr = D({ "node_modules/yaml-unist-parser/lib/factories/plain.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Se(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, c.createNode("plain", d)), r.createCommentAttachable()), y), { value: E });
            }
            n.createPlain = h;
          } }), Ar = D({ "node_modules/yaml-unist-parser/lib/utils/find-last-char-index.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c, h) {
              for (var d = c; d >= 0; d--)
                if (h.test(r[d]))
                  return d;
              return -1;
            }
            n.findLastCharIndex = e;
          } }), Nr = D({ "node_modules/yaml-unist-parser/lib/transforms/plain.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Lr(), r = Ar();
            function c(h, d) {
              var y = h.cstNode;
              return e.createPlain(d.transformRange({ origStart: y.valueRange.origStart, origEnd: r.findLastCharIndex(d.text, y.valueRange.origEnd - 1, /\S/) + 1 }), d.transformContent(h), y.strValue);
            }
            n.transformPlain = c;
          } }), Tr = D({ "node_modules/yaml-unist-parser/lib/factories/quote-double.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te));
            function r(c) {
              return e.__assign(e.__assign({}, c), { type: "quoteDouble" });
            }
            n.createQuoteDouble = r;
          } }), Cr = D({ "node_modules/yaml-unist-parser/lib/factories/quote-value.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Se(), c = me();
            function h(d, y, E) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, c.createNode("quoteValue", d)), y), r.createCommentAttachable()), { value: E });
            }
            n.createQuoteValue = h;
          } }), nt = D({ "node_modules/yaml-unist-parser/lib/transforms/quote-value.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Cr();
            function r(c, h) {
              var d = c.cstNode;
              return e.createQuoteValue(h.transformRange(d.valueRange), h.transformContent(c), d.strValue);
            }
            n.transformAstQuoteValue = r;
          } }), kr = D({ "node_modules/yaml-unist-parser/lib/transforms/quote-double.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Tr(), r = nt();
            function c(h, d) {
              return e.createQuoteDouble(r.transformAstQuoteValue(h, d));
            }
            n.transformQuoteDouble = c;
          } }), Pr = D({ "node_modules/yaml-unist-parser/lib/factories/quote-single.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te));
            function r(c) {
              return e.__assign(e.__assign({}, c), { type: "quoteSingle" });
            }
            n.createQuoteSingle = r;
          } }), Ir = D({ "node_modules/yaml-unist-parser/lib/transforms/quote-single.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Pr(), r = nt();
            function c(h, d) {
              return e.createQuoteSingle(r.transformAstQuoteValue(h, d));
            }
            n.transformQuoteSingle = c;
          } }), Rr = D({ "node_modules/yaml-unist-parser/lib/factories/sequence.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Ee(), c = Oe(), h = me();
            function d(y, E, I) {
              return e.__assign(e.__assign(e.__assign(e.__assign(e.__assign({}, h.createNode("sequence", y)), c.createLeadingCommentAttachable()), r.createEndCommentAttachable()), E), { children: I });
            }
            n.createSequence = d;
          } }), qr = D({ "node_modules/yaml-unist-parser/lib/factories/sequence-item.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te)), r = Se(), c = Ee(), h = me();
            function d(y, E) {
              return e.__assign(e.__assign(e.__assign(e.__assign({}, h.createNode("sequenceItem", y)), r.createCommentAttachable()), c.createEndCommentAttachable()), { children: E ? [E] : [] });
            }
            n.createSequenceItem = d;
          } }), $r = D({ "node_modules/yaml-unist-parser/lib/transforms/seq.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Le(), r = Rr(), c = qr(), h = Be(), d = Ve(), y = Ae();
            function E(I, S) {
              var M = h.extractComments(I.cstNode.items, S), T = M.map(function(P, C) {
                d.extractPropComments(P, S);
                var q = S.transformNode(I.items[C]);
                return c.createSequenceItem(e.createPosition(S.transformOffset(P.valueRange.origStart), q === null ? S.transformOffset(P.valueRange.origStart + 1) : q.position.end), q);
              });
              return r.createSequence(e.createPosition(T[0].position.start, y.getLast(T).position.end), S.transformContent(I), T);
            }
            n.transformSeq = E;
          } }), Br = D({ "node_modules/yaml-unist-parser/lib/transform.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Zt(), r = sr(), c = ar(), h = or(), d = cr(), y = gr(), E = yr(), I = Sr(), S = Or(), M = Nr(), T = kr(), P = Ir(), C = $r();
            function q(R, B) {
              if (R === null || R.type === void 0 && R.value === null)
                return null;
              switch (R.type) {
                case "ALIAS":
                  return e.transformAlias(R, B);
                case "BLOCK_FOLDED":
                  return r.transformBlockFolded(R, B);
                case "BLOCK_LITERAL":
                  return c.transformBlockLiteral(R, B);
                case "COMMENT":
                  return h.transformComment(R, B);
                case "DIRECTIVE":
                  return d.transformDirective(R, B);
                case "DOCUMENT":
                  return y.transformDocument(R, B);
                case "FLOW_MAP":
                  return E.transformFlowMap(R, B);
                case "FLOW_SEQ":
                  return I.transformFlowSeq(R, B);
                case "MAP":
                  return S.transformMap(R, B);
                case "PLAIN":
                  return M.transformPlain(R, B);
                case "QUOTE_DOUBLE":
                  return T.transformQuoteDouble(R, B);
                case "QUOTE_SINGLE":
                  return P.transformQuoteSingle(R, B);
                case "SEQ":
                  return C.transformSeq(R, B);
                default:
                  throw new Error("Unexpected node type " + R.type);
              }
            }
            n.transformNode = q;
          } }), jr = D({ "node_modules/yaml-unist-parser/lib/factories/error.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c, h) {
              var d = new SyntaxError(r);
              return d.name = "YAMLSyntaxError", d.source = c, d.position = h, d;
            }
            n.createError = e;
          } }), Yr = D({ "node_modules/yaml-unist-parser/lib/transforms/error.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = jr();
            function r(c, h) {
              var d = c.source.range || c.source.valueRange;
              return e.createError(c.message, h.text, h.transformRange(d));
            }
            n.transformError = r;
          } }), Dr = D({ "node_modules/yaml-unist-parser/lib/factories/point.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c, h) {
              return { offset: r, line: c, column: h };
            }
            n.createPoint = e;
          } }), Fr = D({ "node_modules/yaml-unist-parser/lib/transforms/offset.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Dr();
            function r(c, h) {
              c < 0 ? c = 0 : c > h.text.length && (c = h.text.length);
              var d = h.locator.locationForIndex(c);
              return e.createPoint(c, d.line + 1, d.column + 1);
            }
            n.transformOffset = r;
          } }), Wr = D({ "node_modules/yaml-unist-parser/lib/transforms/range.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Le();
            function r(c, h) {
              return e.createPosition(h.transformOffset(c.origStart), h.transformOffset(c.origEnd));
            }
            n.transformRange = r;
          } }), Vr = D({ "node_modules/yaml-unist-parser/lib/utils/add-orig-range.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = true;
            function r(y) {
              if (!y.setOrigRanges()) {
                var E = function(I) {
                  if (h(I))
                    return I.origStart = I.start, I.origEnd = I.end, e;
                  if (d(I))
                    return I.origOffset = I.offset, e;
                };
                y.forEach(function(I) {
                  return c(I, E);
                });
              }
            }
            n.addOrigRange = r;
            function c(y, E) {
              if (!(!y || typeof y != "object") && E(y) !== e)
                for (var I = 0, S = Object.keys(y); I < S.length; I++) {
                  var M = S[I];
                  if (!(M === "context" || M === "error")) {
                    var T = y[M];
                    Array.isArray(T) ? T.forEach(function(P) {
                      return c(P, E);
                    }) : c(T, E);
                  }
                }
            }
            function h(y) {
              return typeof y.start == "number";
            }
            function d(y) {
              return typeof y.offset == "number";
            }
          } }), Qr = D({ "node_modules/yaml-unist-parser/lib/utils/remove-fake-nodes.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r) {
              if ("children" in r) {
                if (r.children.length === 1) {
                  var c = r.children[0];
                  if (c.type === "plain" && c.tag === null && c.anchor === null && c.value === "")
                    return r.children.splice(0, 1), r;
                }
                r.children.forEach(e);
              }
              return r;
            }
            n.removeFakeNodes = e;
          } }), Ur = D({ "node_modules/yaml-unist-parser/lib/utils/create-updater.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            function e(r, c, h, d) {
              var y = c(r);
              return function(E) {
                d(y, E) && h(r, y = E);
              };
            }
            n.createUpdater = e;
          } }), Kr = D({ "node_modules/yaml-unist-parser/lib/utils/update-positions.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Ur(), r = Ae();
            function c(M) {
              if (!(M === null || !("children" in M))) {
                var T = M.children;
                if (T.forEach(c), M.type === "document") {
                  var P = M.children, C = P[0], q = P[1];
                  C.position.start.offset === C.position.end.offset ? C.position.start = C.position.end = q.position.start : q.position.start.offset === q.position.end.offset && (q.position.start = q.position.end = C.position.end);
                }
                var R = e.createUpdater(M.position, h, d, I), B = e.createUpdater(M.position, y, E, S);
                "endComments" in M && M.endComments.length !== 0 && (R(M.endComments[0].position.start), B(r.getLast(M.endComments).position.end));
                var U = T.filter(function(t) {
                  return t !== null;
                });
                if (U.length !== 0) {
                  var f2 = U[0], i = r.getLast(U);
                  R(f2.position.start), B(i.position.end), "leadingComments" in f2 && f2.leadingComments.length !== 0 && R(f2.leadingComments[0].position.start), "tag" in f2 && f2.tag && R(f2.tag.position.start), "anchor" in f2 && f2.anchor && R(f2.anchor.position.start), "trailingComment" in i && i.trailingComment && B(i.trailingComment.position.end);
                }
              }
            }
            n.updatePositions = c;
            function h(M) {
              return M.start;
            }
            function d(M, T) {
              M.start = T;
            }
            function y(M) {
              return M.end;
            }
            function E(M, T) {
              M.end = T;
            }
            function I(M, T) {
              return T.offset < M.offset;
            }
            function S(M, T) {
              return T.offset > M.offset;
            }
          } }), Me = D({ "node_modules/yaml/dist/PlainValue-ec8e588e.js"(n) {
            "use strict";
            Y();
            var e = { ANCHOR: "&", COMMENT: "#", TAG: "!", DIRECTIVES_END: "-", DOCUMENT_END: "." }, r = { ALIAS: "ALIAS", BLANK_LINE: "BLANK_LINE", BLOCK_FOLDED: "BLOCK_FOLDED", BLOCK_LITERAL: "BLOCK_LITERAL", COMMENT: "COMMENT", DIRECTIVE: "DIRECTIVE", DOCUMENT: "DOCUMENT", FLOW_MAP: "FLOW_MAP", FLOW_SEQ: "FLOW_SEQ", MAP: "MAP", MAP_KEY: "MAP_KEY", MAP_VALUE: "MAP_VALUE", PLAIN: "PLAIN", QUOTE_DOUBLE: "QUOTE_DOUBLE", QUOTE_SINGLE: "QUOTE_SINGLE", SEQ: "SEQ", SEQ_ITEM: "SEQ_ITEM" }, c = "tag:yaml.org,2002:", h = { MAP: "tag:yaml.org,2002:map", SEQ: "tag:yaml.org,2002:seq", STR: "tag:yaml.org,2002:str" };
            function d(i) {
              let t = [0], s = i.indexOf(`
`);
              for (; s !== -1; )
                s += 1, t.push(s), s = i.indexOf(`
`, s);
              return t;
            }
            function y(i) {
              let t, s;
              return typeof i == "string" ? (t = d(i), s = i) : (Array.isArray(i) && (i = i[0]), i && i.context && (i.lineStarts || (i.lineStarts = d(i.context.src)), t = i.lineStarts, s = i.context.src)), { lineStarts: t, src: s };
            }
            function E(i, t) {
              if (typeof i != "number" || i < 0)
                return null;
              let { lineStarts: s, src: a2 } = y(t);
              if (!s || !a2 || i > a2.length)
                return null;
              for (let g = 0; g < s.length; ++g) {
                let u = s[g];
                if (i < u)
                  return { line: g, col: i - s[g - 1] + 1 };
                if (i === u)
                  return { line: g + 1, col: 1 };
              }
              let m = s.length;
              return { line: m, col: i - s[m - 1] + 1 };
            }
            function I(i, t) {
              let { lineStarts: s, src: a2 } = y(t);
              if (!s || !(i >= 1) || i > s.length)
                return null;
              let m = s[i - 1], g = s[i];
              for (; g && g > m && a2[g - 1] === `
`; )
                --g;
              return a2.slice(m, g);
            }
            function S(i, t) {
              let { start: s, end: a2 } = i, m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 80, g = I(s.line, t);
              if (!g)
                return null;
              let { col: u } = s;
              if (g.length > m)
                if (u <= m - 10)
                  g = g.substr(0, m - 1) + "\u2026";
                else {
                  let K = Math.round(m / 2);
                  g.length > u + K && (g = g.substr(0, u + K - 1) + "\u2026"), u -= g.length - m, g = "\u2026" + g.substr(1 - m);
                }
              let p = 1, L = "";
              a2 && (a2.line === s.line && u + (a2.col - s.col) <= m + 1 ? p = a2.col - s.col : (p = Math.min(g.length + 1, m) - u, L = "\u2026"));
              let k = u > 1 ? " ".repeat(u - 1) : "", $ = "^".repeat(p);
              return `${g}
${k}${$}${L}`;
            }
            var M = class {
              static copy(i) {
                return new M(i.start, i.end);
              }
              constructor(i, t) {
                this.start = i, this.end = t || i;
              }
              isEmpty() {
                return typeof this.start != "number" || !this.end || this.end <= this.start;
              }
              setOrigRange(i, t) {
                let { start: s, end: a2 } = this;
                if (i.length === 0 || a2 <= i[0])
                  return this.origStart = s, this.origEnd = a2, t;
                let m = t;
                for (; m < i.length && !(i[m] > s); )
                  ++m;
                this.origStart = s + m;
                let g = m;
                for (; m < i.length && !(i[m] >= a2); )
                  ++m;
                return this.origEnd = a2 + m, g;
              }
            }, T = class {
              static addStringTerminator(i, t, s) {
                if (s[s.length - 1] === `
`)
                  return s;
                let a2 = T.endOfWhiteSpace(i, t);
                return a2 >= i.length || i[a2] === `
` ? s + `
` : s;
              }
              static atDocumentBoundary(i, t, s) {
                let a2 = i[t];
                if (!a2)
                  return true;
                let m = i[t - 1];
                if (m && m !== `
`)
                  return false;
                if (s) {
                  if (a2 !== s)
                    return false;
                } else if (a2 !== e.DIRECTIVES_END && a2 !== e.DOCUMENT_END)
                  return false;
                let g = i[t + 1], u = i[t + 2];
                if (g !== a2 || u !== a2)
                  return false;
                let p = i[t + 3];
                return !p || p === `
` || p === "	" || p === " ";
              }
              static endOfIdentifier(i, t) {
                let s = i[t], a2 = s === "<", m = a2 ? [`
`, "	", " ", ">"] : [`
`, "	", " ", "[", "]", "{", "}", ","];
                for (; s && m.indexOf(s) === -1; )
                  s = i[t += 1];
                return a2 && s === ">" && (t += 1), t;
              }
              static endOfIndent(i, t) {
                let s = i[t];
                for (; s === " "; )
                  s = i[t += 1];
                return t;
              }
              static endOfLine(i, t) {
                let s = i[t];
                for (; s && s !== `
`; )
                  s = i[t += 1];
                return t;
              }
              static endOfWhiteSpace(i, t) {
                let s = i[t];
                for (; s === "	" || s === " "; )
                  s = i[t += 1];
                return t;
              }
              static startOfLine(i, t) {
                let s = i[t - 1];
                if (s === `
`)
                  return t;
                for (; s && s !== `
`; )
                  s = i[t -= 1];
                return t + 1;
              }
              static endOfBlockIndent(i, t, s) {
                let a2 = T.endOfIndent(i, s);
                if (a2 > s + t)
                  return a2;
                {
                  let m = T.endOfWhiteSpace(i, a2), g = i[m];
                  if (!g || g === `
`)
                    return m;
                }
                return null;
              }
              static atBlank(i, t, s) {
                let a2 = i[t];
                return a2 === `
` || a2 === "	" || a2 === " " || s && !a2;
              }
              static nextNodeIsIndented(i, t, s) {
                return !i || t < 0 ? false : t > 0 ? true : s && i === "-";
              }
              static normalizeOffset(i, t) {
                let s = i[t];
                return s ? s !== `
` && i[t - 1] === `
` ? t - 1 : T.endOfWhiteSpace(i, t) : t;
              }
              static foldNewline(i, t, s) {
                let a2 = 0, m = false, g = "", u = i[t + 1];
                for (; u === " " || u === "	" || u === `
`; ) {
                  switch (u) {
                    case `
`:
                      a2 = 0, t += 1, g += `
`;
                      break;
                    case "	":
                      a2 <= s && (m = true), t = T.endOfWhiteSpace(i, t + 2) - 1;
                      break;
                    case " ":
                      a2 += 1, t += 1;
                      break;
                  }
                  u = i[t + 1];
                }
                return g || (g = " "), u && a2 <= s && (m = true), { fold: g, offset: t, error: m };
              }
              constructor(i, t, s) {
                Object.defineProperty(this, "context", { value: s || null, writable: true }), this.error = null, this.range = null, this.valueRange = null, this.props = t || [], this.type = i, this.value = null;
              }
              getPropValue(i, t, s) {
                if (!this.context)
                  return null;
                let { src: a2 } = this.context, m = this.props[i];
                return m && a2[m.start] === t ? a2.slice(m.start + (s ? 1 : 0), m.end) : null;
              }
              get anchor() {
                for (let i = 0; i < this.props.length; ++i) {
                  let t = this.getPropValue(i, e.ANCHOR, true);
                  if (t != null)
                    return t;
                }
                return null;
              }
              get comment() {
                let i = [];
                for (let t = 0; t < this.props.length; ++t) {
                  let s = this.getPropValue(t, e.COMMENT, true);
                  s != null && i.push(s);
                }
                return i.length > 0 ? i.join(`
`) : null;
              }
              commentHasRequiredWhitespace(i) {
                let { src: t } = this.context;
                if (this.header && i === this.header.end || !this.valueRange)
                  return false;
                let { end: s } = this.valueRange;
                return i !== s || T.atBlank(t, s - 1);
              }
              get hasComment() {
                if (this.context) {
                  let { src: i } = this.context;
                  for (let t = 0; t < this.props.length; ++t)
                    if (i[this.props[t].start] === e.COMMENT)
                      return true;
                }
                return false;
              }
              get hasProps() {
                if (this.context) {
                  let { src: i } = this.context;
                  for (let t = 0; t < this.props.length; ++t)
                    if (i[this.props[t].start] !== e.COMMENT)
                      return true;
                }
                return false;
              }
              get includesTrailingLines() {
                return false;
              }
              get jsonLike() {
                return [r.FLOW_MAP, r.FLOW_SEQ, r.QUOTE_DOUBLE, r.QUOTE_SINGLE].indexOf(this.type) !== -1;
              }
              get rangeAsLinePos() {
                if (!this.range || !this.context)
                  return;
                let i = E(this.range.start, this.context.root);
                if (!i)
                  return;
                let t = E(this.range.end, this.context.root);
                return { start: i, end: t };
              }
              get rawValue() {
                if (!this.valueRange || !this.context)
                  return null;
                let { start: i, end: t } = this.valueRange;
                return this.context.src.slice(i, t);
              }
              get tag() {
                for (let i = 0; i < this.props.length; ++i) {
                  let t = this.getPropValue(i, e.TAG, false);
                  if (t != null) {
                    if (t[1] === "<")
                      return { verbatim: t.slice(2, -1) };
                    {
                      let [s, a2, m] = t.match(/^(.*!)([^!]*)$/);
                      return { handle: a2, suffix: m };
                    }
                  }
                }
                return null;
              }
              get valueRangeContainsNewline() {
                if (!this.valueRange || !this.context)
                  return false;
                let { start: i, end: t } = this.valueRange, { src: s } = this.context;
                for (let a2 = i; a2 < t; ++a2)
                  if (s[a2] === `
`)
                    return true;
                return false;
              }
              parseComment(i) {
                let { src: t } = this.context;
                if (t[i] === e.COMMENT) {
                  let s = T.endOfLine(t, i + 1), a2 = new M(i, s);
                  return this.props.push(a2), s;
                }
                return i;
              }
              setOrigRanges(i, t) {
                return this.range && (t = this.range.setOrigRange(i, t)), this.valueRange && this.valueRange.setOrigRange(i, t), this.props.forEach((s) => s.setOrigRange(i, t)), t;
              }
              toString() {
                let { context: { src: i }, range: t, value: s } = this;
                if (s != null)
                  return s;
                let a2 = i.slice(t.start, t.end);
                return T.addStringTerminator(i, t.end, a2);
              }
            }, P = class extends Error {
              constructor(i, t, s) {
                if (!s || !(t instanceof T))
                  throw new Error(`Invalid arguments for new ${i}`);
                super(), this.name = i, this.message = s, this.source = t;
              }
              makePretty() {
                if (!this.source)
                  return;
                this.nodeType = this.source.type;
                let i = this.source.context && this.source.context.root;
                if (typeof this.offset == "number") {
                  this.range = new M(this.offset, this.offset + 1);
                  let t = i && E(this.offset, i);
                  if (t) {
                    let s = { line: t.line, col: t.col + 1 };
                    this.linePos = { start: t, end: s };
                  }
                  delete this.offset;
                } else
                  this.range = this.source.range, this.linePos = this.source.rangeAsLinePos;
                if (this.linePos) {
                  let { line: t, col: s } = this.linePos.start;
                  this.message += ` at line ${t}, column ${s}`;
                  let a2 = i && S(this.linePos, i);
                  a2 && (this.message += `:

${a2}
`);
                }
                delete this.source;
              }
            }, C = class extends P {
              constructor(i, t) {
                super("YAMLReferenceError", i, t);
              }
            }, q = class extends P {
              constructor(i, t) {
                super("YAMLSemanticError", i, t);
              }
            }, R = class extends P {
              constructor(i, t) {
                super("YAMLSyntaxError", i, t);
              }
            }, B = class extends P {
              constructor(i, t) {
                super("YAMLWarning", i, t);
              }
            };
            function U(i, t, s) {
              return t in i ? Object.defineProperty(i, t, { value: s, enumerable: true, configurable: true, writable: true }) : i[t] = s, i;
            }
            var f2 = class extends T {
              static endOfLine(i, t, s) {
                let a2 = i[t], m = t;
                for (; a2 && a2 !== `
` && !(s && (a2 === "[" || a2 === "]" || a2 === "{" || a2 === "}" || a2 === ",")); ) {
                  let g = i[m + 1];
                  if (a2 === ":" && (!g || g === `
` || g === "	" || g === " " || s && g === ",") || (a2 === " " || a2 === "	") && g === "#")
                    break;
                  m += 1, a2 = g;
                }
                return m;
              }
              get strValue() {
                if (!this.valueRange || !this.context)
                  return null;
                let { start: i, end: t } = this.valueRange, { src: s } = this.context, a2 = s[t - 1];
                for (; i < t && (a2 === `
` || a2 === "	" || a2 === " "); )
                  a2 = s[--t - 1];
                let m = "";
                for (let u = i; u < t; ++u) {
                  let p = s[u];
                  if (p === `
`) {
                    let { fold: L, offset: k } = T.foldNewline(s, u, -1);
                    m += L, u = k;
                  } else if (p === " " || p === "	") {
                    let L = u, k = s[u + 1];
                    for (; u < t && (k === " " || k === "	"); )
                      u += 1, k = s[u + 1];
                    k !== `
` && (m += u > L ? s.slice(L, u + 1) : p);
                  } else
                    m += p;
                }
                let g = s[i];
                switch (g) {
                  case "	": {
                    let u = "Plain value cannot start with a tab character";
                    return { errors: [new q(this, u)], str: m };
                  }
                  case "@":
                  case "`": {
                    let u = `Plain value cannot start with reserved character ${g}`;
                    return { errors: [new q(this, u)], str: m };
                  }
                  default:
                    return m;
                }
              }
              parseBlockValue(i) {
                let { indent: t, inFlow: s, src: a2 } = this.context, m = i, g = i;
                for (let u = a2[m]; u === `
` && !T.atDocumentBoundary(a2, m + 1); u = a2[m]) {
                  let p = T.endOfBlockIndent(a2, t, m + 1);
                  if (p === null || a2[p] === "#")
                    break;
                  a2[p] === `
` ? m = p : (g = f2.endOfLine(a2, p, s), m = g);
                }
                return this.valueRange.isEmpty() && (this.valueRange.start = i), this.valueRange.end = g, g;
              }
              parse(i, t) {
                this.context = i;
                let { inFlow: s, src: a2 } = i, m = t, g = a2[m];
                return g && g !== "#" && g !== `
` && (m = f2.endOfLine(a2, t, s)), this.valueRange = new M(t, m), m = T.endOfWhiteSpace(a2, m), m = this.parseComment(m), (!this.hasComment || this.valueRange.isEmpty()) && (m = this.parseBlockValue(m)), m;
              }
            };
            n.Char = e, n.Node = T, n.PlainValue = f2, n.Range = M, n.Type = r, n.YAMLError = P, n.YAMLReferenceError = C, n.YAMLSemanticError = q, n.YAMLSyntaxError = R, n.YAMLWarning = B, n._defineProperty = U, n.defaultTagPrefix = c, n.defaultTags = h;
          } }), Jr = D({ "node_modules/yaml/dist/parse-cst.js"(n) {
            "use strict";
            Y();
            var e = Me(), r = class extends e.Node {
              constructor() {
                super(e.Type.BLANK_LINE);
              }
              get includesTrailingLines() {
                return true;
              }
              parse(f2, i) {
                return this.context = f2, this.range = new e.Range(i, i + 1), i + 1;
              }
            }, c = class extends e.Node {
              constructor(f2, i) {
                super(f2, i), this.node = null;
              }
              get includesTrailingLines() {
                return !!this.node && this.node.includesTrailingLines;
              }
              parse(f2, i) {
                this.context = f2;
                let { parseNode: t, src: s } = f2, { atLineStart: a2, lineStart: m } = f2;
                !a2 && this.type === e.Type.SEQ_ITEM && (this.error = new e.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line"));
                let g = a2 ? i - m : f2.indent, u = e.Node.endOfWhiteSpace(s, i + 1), p = s[u], L = p === "#", k = [], $ = null;
                for (; p === `
` || p === "#"; ) {
                  if (p === "#") {
                    let V = e.Node.endOfLine(s, u + 1);
                    k.push(new e.Range(u, V)), u = V;
                  } else {
                    a2 = true, m = u + 1;
                    let V = e.Node.endOfWhiteSpace(s, m);
                    s[V] === `
` && k.length === 0 && ($ = new r(), m = $.parse({ src: s }, m)), u = e.Node.endOfIndent(s, m);
                  }
                  p = s[u];
                }
                if (e.Node.nextNodeIsIndented(p, u - (m + g), this.type !== e.Type.SEQ_ITEM) ? this.node = t({ atLineStart: a2, inCollection: false, indent: g, lineStart: m, parent: this }, u) : p && m > i + 1 && (u = m - 1), this.node) {
                  if ($) {
                    let V = f2.parent.items || f2.parent.contents;
                    V && V.push($);
                  }
                  k.length && Array.prototype.push.apply(this.props, k), u = this.node.range.end;
                } else if (L) {
                  let V = k[0];
                  this.props.push(V), u = V.end;
                } else
                  u = e.Node.endOfLine(s, i + 1);
                let K = this.node ? this.node.valueRange.end : u;
                return this.valueRange = new e.Range(i, K), u;
              }
              setOrigRanges(f2, i) {
                return i = super.setOrigRanges(f2, i), this.node ? this.node.setOrigRanges(f2, i) : i;
              }
              toString() {
                let { context: { src: f2 }, node: i, range: t, value: s } = this;
                if (s != null)
                  return s;
                let a2 = i ? f2.slice(t.start, i.range.start) + String(i) : f2.slice(t.start, t.end);
                return e.Node.addStringTerminator(f2, t.end, a2);
              }
            }, h = class extends e.Node {
              constructor() {
                super(e.Type.COMMENT);
              }
              parse(f2, i) {
                this.context = f2;
                let t = this.parseComment(i);
                return this.range = new e.Range(i, t), t;
              }
            };
            function d(f2) {
              let i = f2;
              for (; i instanceof c; )
                i = i.node;
              if (!(i instanceof y))
                return null;
              let t = i.items.length, s = -1;
              for (let g = t - 1; g >= 0; --g) {
                let u = i.items[g];
                if (u.type === e.Type.COMMENT) {
                  let { indent: p, lineStart: L } = u.context;
                  if (p > 0 && u.range.start >= L + p)
                    break;
                  s = g;
                } else if (u.type === e.Type.BLANK_LINE)
                  s = g;
                else
                  break;
              }
              if (s === -1)
                return null;
              let a2 = i.items.splice(s, t - s), m = a2[0].range.start;
              for (; i.range.end = m, i.valueRange && i.valueRange.end > m && (i.valueRange.end = m), i !== f2; )
                i = i.context.parent;
              return a2;
            }
            var y = class extends e.Node {
              static nextContentHasIndent(f2, i, t) {
                let s = e.Node.endOfLine(f2, i) + 1;
                i = e.Node.endOfWhiteSpace(f2, s);
                let a2 = f2[i];
                return a2 ? i >= s + t ? true : a2 !== "#" && a2 !== `
` ? false : y.nextContentHasIndent(f2, i, t) : false;
              }
              constructor(f2) {
                super(f2.type === e.Type.SEQ_ITEM ? e.Type.SEQ : e.Type.MAP);
                for (let t = f2.props.length - 1; t >= 0; --t)
                  if (f2.props[t].start < f2.context.lineStart) {
                    this.props = f2.props.slice(0, t + 1), f2.props = f2.props.slice(t + 1);
                    let s = f2.props[0] || f2.valueRange;
                    f2.range.start = s.start;
                    break;
                  }
                this.items = [f2];
                let i = d(f2);
                i && Array.prototype.push.apply(this.items, i);
              }
              get includesTrailingLines() {
                return this.items.length > 0;
              }
              parse(f2, i) {
                this.context = f2;
                let { parseNode: t, src: s } = f2, a2 = e.Node.startOfLine(s, i), m = this.items[0];
                m.context.parent = this, this.valueRange = e.Range.copy(m.valueRange);
                let g = m.range.start - m.context.lineStart, u = i;
                u = e.Node.normalizeOffset(s, u);
                let p = s[u], L = e.Node.endOfWhiteSpace(s, a2) === u, k = false;
                for (; p; ) {
                  for (; p === `
` || p === "#"; ) {
                    if (L && p === `
` && !k) {
                      let V = new r();
                      if (u = V.parse({ src: s }, u), this.valueRange.end = u, u >= s.length) {
                        p = null;
                        break;
                      }
                      this.items.push(V), u -= 1;
                    } else if (p === "#") {
                      if (u < a2 + g && !y.nextContentHasIndent(s, u, g))
                        return u;
                      let V = new h();
                      if (u = V.parse({ indent: g, lineStart: a2, src: s }, u), this.items.push(V), this.valueRange.end = u, u >= s.length) {
                        p = null;
                        break;
                      }
                    }
                    if (a2 = u + 1, u = e.Node.endOfIndent(s, a2), e.Node.atBlank(s, u)) {
                      let V = e.Node.endOfWhiteSpace(s, u), z = s[V];
                      (!z || z === `
` || z === "#") && (u = V);
                    }
                    p = s[u], L = true;
                  }
                  if (!p)
                    break;
                  if (u !== a2 + g && (L || p !== ":")) {
                    if (u < a2 + g) {
                      a2 > i && (u = a2);
                      break;
                    } else if (!this.error) {
                      let V = "All collection items must start at the same column";
                      this.error = new e.YAMLSyntaxError(this, V);
                    }
                  }
                  if (m.type === e.Type.SEQ_ITEM) {
                    if (p !== "-") {
                      a2 > i && (u = a2);
                      break;
                    }
                  } else if (p === "-" && !this.error) {
                    let V = s[u + 1];
                    if (!V || V === `
` || V === "	" || V === " ") {
                      let z = "A collection cannot be both a mapping and a sequence";
                      this.error = new e.YAMLSyntaxError(this, z);
                    }
                  }
                  let $ = t({ atLineStart: L, inCollection: true, indent: g, lineStart: a2, parent: this }, u);
                  if (!$)
                    return u;
                  if (this.items.push($), this.valueRange.end = $.valueRange.end, u = e.Node.normalizeOffset(s, $.range.end), p = s[u], L = false, k = $.includesTrailingLines, p) {
                    let V = u - 1, z = s[V];
                    for (; z === " " || z === "	"; )
                      z = s[--V];
                    z === `
` && (a2 = V + 1, L = true);
                  }
                  let K = d($);
                  K && Array.prototype.push.apply(this.items, K);
                }
                return u;
              }
              setOrigRanges(f2, i) {
                return i = super.setOrigRanges(f2, i), this.items.forEach((t) => {
                  i = t.setOrigRanges(f2, i);
                }), i;
              }
              toString() {
                let { context: { src: f2 }, items: i, range: t, value: s } = this;
                if (s != null)
                  return s;
                let a2 = f2.slice(t.start, i[0].range.start) + String(i[0]);
                for (let m = 1; m < i.length; ++m) {
                  let g = i[m], { atLineStart: u, indent: p } = g.context;
                  if (u)
                    for (let L = 0; L < p; ++L)
                      a2 += " ";
                  a2 += String(g);
                }
                return e.Node.addStringTerminator(f2, t.end, a2);
              }
            }, E = class extends e.Node {
              constructor() {
                super(e.Type.DIRECTIVE), this.name = null;
              }
              get parameters() {
                let f2 = this.rawValue;
                return f2 ? f2.trim().split(/[ \t]+/) : [];
              }
              parseName(f2) {
                let { src: i } = this.context, t = f2, s = i[t];
                for (; s && s !== `
` && s !== "	" && s !== " "; )
                  s = i[t += 1];
                return this.name = i.slice(f2, t), t;
              }
              parseParameters(f2) {
                let { src: i } = this.context, t = f2, s = i[t];
                for (; s && s !== `
` && s !== "#"; )
                  s = i[t += 1];
                return this.valueRange = new e.Range(f2, t), t;
              }
              parse(f2, i) {
                this.context = f2;
                let t = this.parseName(i + 1);
                return t = this.parseParameters(t), t = this.parseComment(t), this.range = new e.Range(i, t), t;
              }
            }, I = class extends e.Node {
              static startCommentOrEndBlankLine(f2, i) {
                let t = e.Node.endOfWhiteSpace(f2, i), s = f2[t];
                return s === "#" || s === `
` ? t : i;
              }
              constructor() {
                super(e.Type.DOCUMENT), this.directives = null, this.contents = null, this.directivesEndMarker = null, this.documentEndMarker = null;
              }
              parseDirectives(f2) {
                let { src: i } = this.context;
                this.directives = [];
                let t = true, s = false, a2 = f2;
                for (; !e.Node.atDocumentBoundary(i, a2, e.Char.DIRECTIVES_END); )
                  switch (a2 = I.startCommentOrEndBlankLine(i, a2), i[a2]) {
                    case `
`:
                      if (t) {
                        let m = new r();
                        a2 = m.parse({ src: i }, a2), a2 < i.length && this.directives.push(m);
                      } else
                        a2 += 1, t = true;
                      break;
                    case "#":
                      {
                        let m = new h();
                        a2 = m.parse({ src: i }, a2), this.directives.push(m), t = false;
                      }
                      break;
                    case "%":
                      {
                        let m = new E();
                        a2 = m.parse({ parent: this, src: i }, a2), this.directives.push(m), s = true, t = false;
                      }
                      break;
                    default:
                      return s ? this.error = new e.YAMLSemanticError(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), a2;
                  }
                return i[a2] ? (this.directivesEndMarker = new e.Range(a2, a2 + 3), a2 + 3) : (s ? this.error = new e.YAMLSemanticError(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), a2);
              }
              parseContents(f2) {
                let { parseNode: i, src: t } = this.context;
                this.contents || (this.contents = []);
                let s = f2;
                for (; t[s - 1] === "-"; )
                  s -= 1;
                let a2 = e.Node.endOfWhiteSpace(t, f2), m = s === f2;
                for (this.valueRange = new e.Range(a2); !e.Node.atDocumentBoundary(t, a2, e.Char.DOCUMENT_END); ) {
                  switch (t[a2]) {
                    case `
`:
                      if (m) {
                        let g = new r();
                        a2 = g.parse({ src: t }, a2), a2 < t.length && this.contents.push(g);
                      } else
                        a2 += 1, m = true;
                      s = a2;
                      break;
                    case "#":
                      {
                        let g = new h();
                        a2 = g.parse({ src: t }, a2), this.contents.push(g), m = false;
                      }
                      break;
                    default: {
                      let g = e.Node.endOfIndent(t, a2), p = i({ atLineStart: m, indent: -1, inFlow: false, inCollection: false, lineStart: s, parent: this }, g);
                      if (!p)
                        return this.valueRange.end = g;
                      this.contents.push(p), a2 = p.range.end, m = false;
                      let L = d(p);
                      L && Array.prototype.push.apply(this.contents, L);
                    }
                  }
                  a2 = I.startCommentOrEndBlankLine(t, a2);
                }
                if (this.valueRange.end = a2, t[a2] && (this.documentEndMarker = new e.Range(a2, a2 + 3), a2 += 3, t[a2])) {
                  if (a2 = e.Node.endOfWhiteSpace(t, a2), t[a2] === "#") {
                    let g = new h();
                    a2 = g.parse({ src: t }, a2), this.contents.push(g);
                  }
                  switch (t[a2]) {
                    case `
`:
                      a2 += 1;
                      break;
                    case void 0:
                      break;
                    default:
                      this.error = new e.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
                  }
                }
                return a2;
              }
              parse(f2, i) {
                f2.root = this, this.context = f2;
                let { src: t } = f2, s = t.charCodeAt(i) === 65279 ? i + 1 : i;
                return s = this.parseDirectives(s), s = this.parseContents(s), s;
              }
              setOrigRanges(f2, i) {
                return i = super.setOrigRanges(f2, i), this.directives.forEach((t) => {
                  i = t.setOrigRanges(f2, i);
                }), this.directivesEndMarker && (i = this.directivesEndMarker.setOrigRange(f2, i)), this.contents.forEach((t) => {
                  i = t.setOrigRanges(f2, i);
                }), this.documentEndMarker && (i = this.documentEndMarker.setOrigRange(f2, i)), i;
              }
              toString() {
                let { contents: f2, directives: i, value: t } = this;
                if (t != null)
                  return t;
                let s = i.join("");
                return f2.length > 0 && ((i.length > 0 || f2[0].type === e.Type.COMMENT) && (s += `---
`), s += f2.join("")), s[s.length - 1] !== `
` && (s += `
`), s;
              }
            }, S = class extends e.Node {
              parse(f2, i) {
                this.context = f2;
                let { src: t } = f2, s = e.Node.endOfIdentifier(t, i + 1);
                return this.valueRange = new e.Range(i + 1, s), s = e.Node.endOfWhiteSpace(t, s), s = this.parseComment(s), s;
              }
            }, M = { CLIP: "CLIP", KEEP: "KEEP", STRIP: "STRIP" }, T = class extends e.Node {
              constructor(f2, i) {
                super(f2, i), this.blockIndent = null, this.chomping = M.CLIP, this.header = null;
              }
              get includesTrailingLines() {
                return this.chomping === M.KEEP;
              }
              get strValue() {
                if (!this.valueRange || !this.context)
                  return null;
                let { start: f2, end: i } = this.valueRange, { indent: t, src: s } = this.context;
                if (this.valueRange.isEmpty())
                  return "";
                let a2 = null, m = s[i - 1];
                for (; m === `
` || m === "	" || m === " "; ) {
                  if (i -= 1, i <= f2) {
                    if (this.chomping === M.KEEP)
                      break;
                    return "";
                  }
                  m === `
` && (a2 = i), m = s[i - 1];
                }
                let g = i + 1;
                a2 && (this.chomping === M.KEEP ? (g = a2, i = this.valueRange.end) : i = a2);
                let u = t + this.blockIndent, p = this.type === e.Type.BLOCK_FOLDED, L = true, k = "", $ = "", K = false;
                for (let V = f2; V < i; ++V) {
                  for (let ae = 0; ae < u && s[V] === " "; ++ae)
                    V += 1;
                  let z = s[V];
                  if (z === `
`)
                    $ === `
` ? k += `
` : $ = `
`;
                  else {
                    let ae = e.Node.endOfLine(s, V), ue = s.slice(V, ae);
                    V = ae, p && (z === " " || z === "	") && V < g ? ($ === " " ? $ = `
` : !K && !L && $ === `
` && ($ = `

`), k += $ + ue, $ = ae < i && s[ae] || "", K = true) : (k += $ + ue, $ = p && V < g ? " " : `
`, K = false), L && ue !== "" && (L = false);
                  }
                }
                return this.chomping === M.STRIP ? k : k + `
`;
              }
              parseBlockHeader(f2) {
                let { src: i } = this.context, t = f2 + 1, s = "";
                for (; ; ) {
                  let a2 = i[t];
                  switch (a2) {
                    case "-":
                      this.chomping = M.STRIP;
                      break;
                    case "+":
                      this.chomping = M.KEEP;
                      break;
                    case "0":
                    case "1":
                    case "2":
                    case "3":
                    case "4":
                    case "5":
                    case "6":
                    case "7":
                    case "8":
                    case "9":
                      s += a2;
                      break;
                    default:
                      return this.blockIndent = Number(s) || null, this.header = new e.Range(f2, t), t;
                  }
                  t += 1;
                }
              }
              parseBlockValue(f2) {
                let { indent: i, src: t } = this.context, s = !!this.blockIndent, a2 = f2, m = f2, g = 1;
                for (let u = t[a2]; u === `
` && (a2 += 1, !e.Node.atDocumentBoundary(t, a2)); u = t[a2]) {
                  let p = e.Node.endOfBlockIndent(t, i, a2);
                  if (p === null)
                    break;
                  let L = t[p], k = p - (a2 + i);
                  if (this.blockIndent) {
                    if (L && L !== `
` && k < this.blockIndent) {
                      if (t[p] === "#")
                        break;
                      if (!this.error) {
                        let K = `Block scalars must not be less indented than their ${s ? "explicit indentation indicator" : "first line"}`;
                        this.error = new e.YAMLSemanticError(this, K);
                      }
                    }
                  } else if (t[p] !== `
`) {
                    if (k < g) {
                      let $ = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                      this.error = new e.YAMLSemanticError(this, $);
                    }
                    this.blockIndent = k;
                  } else
                    k > g && (g = k);
                  t[p] === `
` ? a2 = p : a2 = m = e.Node.endOfLine(t, p);
                }
                return this.chomping !== M.KEEP && (a2 = t[m] ? m + 1 : m), this.valueRange = new e.Range(f2 + 1, a2), a2;
              }
              parse(f2, i) {
                this.context = f2;
                let { src: t } = f2, s = this.parseBlockHeader(i);
                return s = e.Node.endOfWhiteSpace(t, s), s = this.parseComment(s), s = this.parseBlockValue(s), s;
              }
              setOrigRanges(f2, i) {
                return i = super.setOrigRanges(f2, i), this.header ? this.header.setOrigRange(f2, i) : i;
              }
            }, P = class extends e.Node {
              constructor(f2, i) {
                super(f2, i), this.items = null;
              }
              prevNodeIsJsonLike() {
                let f2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.items.length, i = this.items[f2 - 1];
                return !!i && (i.jsonLike || i.type === e.Type.COMMENT && this.prevNodeIsJsonLike(f2 - 1));
              }
              parse(f2, i) {
                this.context = f2;
                let { parseNode: t, src: s } = f2, { indent: a2, lineStart: m } = f2, g = s[i];
                this.items = [{ char: g, offset: i }];
                let u = e.Node.endOfWhiteSpace(s, i + 1);
                for (g = s[u]; g && g !== "]" && g !== "}"; ) {
                  switch (g) {
                    case `
`:
                      {
                        m = u + 1;
                        let p = e.Node.endOfWhiteSpace(s, m);
                        if (s[p] === `
`) {
                          let L = new r();
                          m = L.parse({ src: s }, m), this.items.push(L);
                        }
                        if (u = e.Node.endOfIndent(s, m), u <= m + a2 && (g = s[u], u < m + a2 || g !== "]" && g !== "}")) {
                          let L = "Insufficient indentation in flow collection";
                          this.error = new e.YAMLSemanticError(this, L);
                        }
                      }
                      break;
                    case ",":
                      this.items.push({ char: g, offset: u }), u += 1;
                      break;
                    case "#":
                      {
                        let p = new h();
                        u = p.parse({ src: s }, u), this.items.push(p);
                      }
                      break;
                    case "?":
                    case ":": {
                      let p = s[u + 1];
                      if (p === `
` || p === "	" || p === " " || p === "," || g === ":" && this.prevNodeIsJsonLike()) {
                        this.items.push({ char: g, offset: u }), u += 1;
                        break;
                      }
                    }
                    default: {
                      let p = t({ atLineStart: false, inCollection: false, inFlow: true, indent: -1, lineStart: m, parent: this }, u);
                      if (!p)
                        return this.valueRange = new e.Range(i, u), u;
                      this.items.push(p), u = e.Node.normalizeOffset(s, p.range.end);
                    }
                  }
                  u = e.Node.endOfWhiteSpace(s, u), g = s[u];
                }
                return this.valueRange = new e.Range(i, u + 1), g && (this.items.push({ char: g, offset: u }), u = e.Node.endOfWhiteSpace(s, u + 1), u = this.parseComment(u)), u;
              }
              setOrigRanges(f2, i) {
                return i = super.setOrigRanges(f2, i), this.items.forEach((t) => {
                  if (t instanceof e.Node)
                    i = t.setOrigRanges(f2, i);
                  else if (f2.length === 0)
                    t.origOffset = t.offset;
                  else {
                    let s = i;
                    for (; s < f2.length && !(f2[s] > t.offset); )
                      ++s;
                    t.origOffset = t.offset + s, i = s;
                  }
                }), i;
              }
              toString() {
                let { context: { src: f2 }, items: i, range: t, value: s } = this;
                if (s != null)
                  return s;
                let a2 = i.filter((u) => u instanceof e.Node), m = "", g = t.start;
                return a2.forEach((u) => {
                  let p = f2.slice(g, u.range.start);
                  g = u.range.end, m += p + String(u), m[m.length - 1] === `
` && f2[g - 1] !== `
` && f2[g] === `
` && (g += 1);
                }), m += f2.slice(g, t.end), e.Node.addStringTerminator(f2, t.end, m);
              }
            }, C = class extends e.Node {
              static endOfQuote(f2, i) {
                let t = f2[i];
                for (; t && t !== '"'; )
                  i += t === "\\" ? 2 : 1, t = f2[i];
                return i + 1;
              }
              get strValue() {
                if (!this.valueRange || !this.context)
                  return null;
                let f2 = [], { start: i, end: t } = this.valueRange, { indent: s, src: a2 } = this.context;
                a2[t - 1] !== '"' && f2.push(new e.YAMLSyntaxError(this, 'Missing closing "quote'));
                let m = "";
                for (let g = i + 1; g < t - 1; ++g) {
                  let u = a2[g];
                  if (u === `
`) {
                    e.Node.atDocumentBoundary(a2, g + 1) && f2.push(new e.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                    let { fold: p, offset: L, error: k } = e.Node.foldNewline(a2, g, s);
                    m += p, g = L, k && f2.push(new e.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
                  } else if (u === "\\")
                    switch (g += 1, a2[g]) {
                      case "0":
                        m += "\0";
                        break;
                      case "a":
                        m += "\x07";
                        break;
                      case "b":
                        m += "\b";
                        break;
                      case "e":
                        m += "\x1B";
                        break;
                      case "f":
                        m += "\f";
                        break;
                      case "n":
                        m += `
`;
                        break;
                      case "r":
                        m += "\r";
                        break;
                      case "t":
                        m += "	";
                        break;
                      case "v":
                        m += "\v";
                        break;
                      case "N":
                        m += "\x85";
                        break;
                      case "_":
                        m += "\xA0";
                        break;
                      case "L":
                        m += "\u2028";
                        break;
                      case "P":
                        m += "\u2029";
                        break;
                      case " ":
                        m += " ";
                        break;
                      case '"':
                        m += '"';
                        break;
                      case "/":
                        m += "/";
                        break;
                      case "\\":
                        m += "\\";
                        break;
                      case "	":
                        m += "	";
                        break;
                      case "x":
                        m += this.parseCharCode(g + 1, 2, f2), g += 2;
                        break;
                      case "u":
                        m += this.parseCharCode(g + 1, 4, f2), g += 4;
                        break;
                      case "U":
                        m += this.parseCharCode(g + 1, 8, f2), g += 8;
                        break;
                      case `
`:
                        for (; a2[g + 1] === " " || a2[g + 1] === "	"; )
                          g += 1;
                        break;
                      default:
                        f2.push(new e.YAMLSyntaxError(this, `Invalid escape sequence ${a2.substr(g - 1, 2)}`)), m += "\\" + a2[g];
                    }
                  else if (u === " " || u === "	") {
                    let p = g, L = a2[g + 1];
                    for (; L === " " || L === "	"; )
                      g += 1, L = a2[g + 1];
                    L !== `
` && (m += g > p ? a2.slice(p, g + 1) : u);
                  } else
                    m += u;
                }
                return f2.length > 0 ? { errors: f2, str: m } : m;
              }
              parseCharCode(f2, i, t) {
                let { src: s } = this.context, a2 = s.substr(f2, i), g = a2.length === i && /^[0-9a-fA-F]+$/.test(a2) ? parseInt(a2, 16) : NaN;
                return isNaN(g) ? (t.push(new e.YAMLSyntaxError(this, `Invalid escape sequence ${s.substr(f2 - 2, i + 2)}`)), s.substr(f2 - 2, i + 2)) : String.fromCodePoint(g);
              }
              parse(f2, i) {
                this.context = f2;
                let { src: t } = f2, s = C.endOfQuote(t, i + 1);
                return this.valueRange = new e.Range(i, s), s = e.Node.endOfWhiteSpace(t, s), s = this.parseComment(s), s;
              }
            }, q = class extends e.Node {
              static endOfQuote(f2, i) {
                let t = f2[i];
                for (; t; )
                  if (t === "'") {
                    if (f2[i + 1] !== "'")
                      break;
                    t = f2[i += 2];
                  } else
                    t = f2[i += 1];
                return i + 1;
              }
              get strValue() {
                if (!this.valueRange || !this.context)
                  return null;
                let f2 = [], { start: i, end: t } = this.valueRange, { indent: s, src: a2 } = this.context;
                a2[t - 1] !== "'" && f2.push(new e.YAMLSyntaxError(this, "Missing closing 'quote"));
                let m = "";
                for (let g = i + 1; g < t - 1; ++g) {
                  let u = a2[g];
                  if (u === `
`) {
                    e.Node.atDocumentBoundary(a2, g + 1) && f2.push(new e.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                    let { fold: p, offset: L, error: k } = e.Node.foldNewline(a2, g, s);
                    m += p, g = L, k && f2.push(new e.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
                  } else if (u === "'")
                    m += u, g += 1, a2[g] !== "'" && f2.push(new e.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
                  else if (u === " " || u === "	") {
                    let p = g, L = a2[g + 1];
                    for (; L === " " || L === "	"; )
                      g += 1, L = a2[g + 1];
                    L !== `
` && (m += g > p ? a2.slice(p, g + 1) : u);
                  } else
                    m += u;
                }
                return f2.length > 0 ? { errors: f2, str: m } : m;
              }
              parse(f2, i) {
                this.context = f2;
                let { src: t } = f2, s = q.endOfQuote(t, i + 1);
                return this.valueRange = new e.Range(i, s), s = e.Node.endOfWhiteSpace(t, s), s = this.parseComment(s), s;
              }
            };
            function R(f2, i) {
              switch (f2) {
                case e.Type.ALIAS:
                  return new S(f2, i);
                case e.Type.BLOCK_FOLDED:
                case e.Type.BLOCK_LITERAL:
                  return new T(f2, i);
                case e.Type.FLOW_MAP:
                case e.Type.FLOW_SEQ:
                  return new P(f2, i);
                case e.Type.MAP_KEY:
                case e.Type.MAP_VALUE:
                case e.Type.SEQ_ITEM:
                  return new c(f2, i);
                case e.Type.COMMENT:
                case e.Type.PLAIN:
                  return new e.PlainValue(f2, i);
                case e.Type.QUOTE_DOUBLE:
                  return new C(f2, i);
                case e.Type.QUOTE_SINGLE:
                  return new q(f2, i);
                default:
                  return null;
              }
            }
            var B = class {
              static parseType(f2, i, t) {
                switch (f2[i]) {
                  case "*":
                    return e.Type.ALIAS;
                  case ">":
                    return e.Type.BLOCK_FOLDED;
                  case "|":
                    return e.Type.BLOCK_LITERAL;
                  case "{":
                    return e.Type.FLOW_MAP;
                  case "[":
                    return e.Type.FLOW_SEQ;
                  case "?":
                    return !t && e.Node.atBlank(f2, i + 1, true) ? e.Type.MAP_KEY : e.Type.PLAIN;
                  case ":":
                    return !t && e.Node.atBlank(f2, i + 1, true) ? e.Type.MAP_VALUE : e.Type.PLAIN;
                  case "-":
                    return !t && e.Node.atBlank(f2, i + 1, true) ? e.Type.SEQ_ITEM : e.Type.PLAIN;
                  case '"':
                    return e.Type.QUOTE_DOUBLE;
                  case "'":
                    return e.Type.QUOTE_SINGLE;
                  default:
                    return e.Type.PLAIN;
                }
              }
              constructor() {
                let f2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { atLineStart: i, inCollection: t, inFlow: s, indent: a2, lineStart: m, parent: g } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                e._defineProperty(this, "parseNode", (u, p) => {
                  if (e.Node.atDocumentBoundary(this.src, p))
                    return null;
                  let L = new B(this, u), { props: k, type: $, valueStart: K } = L.parseProps(p), V = R($, k), z = V.parse(L, K);
                  if (V.range = new e.Range(p, z), z <= p && (V.error = new Error("Node#parse consumed no characters"), V.error.parseEnd = z, V.error.source = V, V.range.end = p + 1), L.nodeStartsCollection(V)) {
                    !V.error && !L.atLineStart && L.parent.type === e.Type.DOCUMENT && (V.error = new e.YAMLSyntaxError(V, "Block collection must not have preceding content here (e.g. directives-end indicator)"));
                    let ae = new y(V);
                    return z = ae.parse(new B(L), z), ae.range = new e.Range(p, z), ae;
                  }
                  return V;
                }), this.atLineStart = i != null ? i : f2.atLineStart || false, this.inCollection = t != null ? t : f2.inCollection || false, this.inFlow = s != null ? s : f2.inFlow || false, this.indent = a2 != null ? a2 : f2.indent, this.lineStart = m != null ? m : f2.lineStart, this.parent = g != null ? g : f2.parent || {}, this.root = f2.root, this.src = f2.src;
              }
              nodeStartsCollection(f2) {
                let { inCollection: i, inFlow: t, src: s } = this;
                if (i || t)
                  return false;
                if (f2 instanceof c)
                  return true;
                let a2 = f2.range.end;
                return s[a2] === `
` || s[a2 - 1] === `
` ? false : (a2 = e.Node.endOfWhiteSpace(s, a2), s[a2] === ":");
              }
              parseProps(f2) {
                let { inFlow: i, parent: t, src: s } = this, a2 = [], m = false;
                f2 = this.atLineStart ? e.Node.endOfIndent(s, f2) : e.Node.endOfWhiteSpace(s, f2);
                let g = s[f2];
                for (; g === e.Char.ANCHOR || g === e.Char.COMMENT || g === e.Char.TAG || g === `
`; ) {
                  if (g === `
`) {
                    let p = f2, L;
                    do
                      L = p + 1, p = e.Node.endOfIndent(s, L);
                    while (s[p] === `
`);
                    let k = p - (L + this.indent), $ = t.type === e.Type.SEQ_ITEM && t.context.atLineStart;
                    if (s[p] !== "#" && !e.Node.nextNodeIsIndented(s[p], k, !$))
                      break;
                    this.atLineStart = true, this.lineStart = L, m = false, f2 = p;
                  } else if (g === e.Char.COMMENT) {
                    let p = e.Node.endOfLine(s, f2 + 1);
                    a2.push(new e.Range(f2, p)), f2 = p;
                  } else {
                    let p = e.Node.endOfIdentifier(s, f2 + 1);
                    g === e.Char.TAG && s[p] === "," && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(s.slice(f2 + 1, p + 13)) && (p = e.Node.endOfIdentifier(s, p + 5)), a2.push(new e.Range(f2, p)), m = true, f2 = e.Node.endOfWhiteSpace(s, p);
                  }
                  g = s[f2];
                }
                m && g === ":" && e.Node.atBlank(s, f2 + 1, true) && (f2 -= 1);
                let u = B.parseType(s, f2, i);
                return { props: a2, type: u, valueStart: f2 };
              }
            };
            function U(f2) {
              let i = [];
              f2.indexOf("\r") !== -1 && (f2 = f2.replace(/\r\n?/g, (a2, m) => (a2.length > 1 && i.push(m), `
`)));
              let t = [], s = 0;
              do {
                let a2 = new I(), m = new B({ src: f2 });
                s = a2.parse(m, s), t.push(a2);
              } while (s < f2.length);
              return t.setOrigRanges = () => {
                if (i.length === 0)
                  return false;
                for (let m = 1; m < i.length; ++m)
                  i[m] -= m;
                let a2 = 0;
                for (let m = 0; m < t.length; ++m)
                  a2 = t[m].setOrigRanges(i, a2);
                return i.splice(0, i.length), true;
              }, t.toString = () => t.join(`...
`), t;
            }
            n.parse = U;
          } }), ke = D({ "node_modules/yaml/dist/resolveSeq-d03cb037.js"(n) {
            "use strict";
            Y();
            var e = Me();
            function r(o, l, _) {
              return _ ? `#${_.replace(/[\s\S]^/gm, `$&${l}#`)}
${l}${o}` : o;
            }
            function c(o, l, _) {
              return _ ? _.indexOf(`
`) === -1 ? `${o} #${_}` : `${o}
` + _.replace(/^/gm, `${l || ""}#`) : o;
            }
            var h = class {
            };
            function d(o, l, _) {
              if (Array.isArray(o))
                return o.map((v, b) => d(v, String(b), _));
              if (o && typeof o.toJSON == "function") {
                let v = _ && _.anchors && _.anchors.get(o);
                v && (_.onCreate = (w) => {
                  v.res = w, delete _.onCreate;
                });
                let b = o.toJSON(l, _);
                return v && _.onCreate && _.onCreate(b), b;
              }
              return (!_ || !_.keep) && typeof o == "bigint" ? Number(o) : o;
            }
            var y = class extends h {
              constructor(o) {
                super(), this.value = o;
              }
              toJSON(o, l) {
                return l && l.keep ? this.value : d(this.value, o, l);
              }
              toString() {
                return String(this.value);
              }
            };
            function E(o, l, _) {
              let v = _;
              for (let b = l.length - 1; b >= 0; --b) {
                let w = l[b];
                if (Number.isInteger(w) && w >= 0) {
                  let A2 = [];
                  A2[w] = v, v = A2;
                } else {
                  let A2 = {};
                  Object.defineProperty(A2, w, { value: v, writable: true, enumerable: true, configurable: true }), v = A2;
                }
              }
              return o.createNode(v, false);
            }
            var I = (o) => o == null || typeof o == "object" && o[Symbol.iterator]().next().done, S = class extends h {
              constructor(o) {
                super(), e._defineProperty(this, "items", []), this.schema = o;
              }
              addIn(o, l) {
                if (I(o))
                  this.add(l);
                else {
                  let [_, ...v] = o, b = this.get(_, true);
                  if (b instanceof S)
                    b.addIn(v, l);
                  else if (b === void 0 && this.schema)
                    this.set(_, E(this.schema, v, l));
                  else
                    throw new Error(`Expected YAML collection at ${_}. Remaining path: ${v}`);
                }
              }
              deleteIn(o) {
                let [l, ..._] = o;
                if (_.length === 0)
                  return this.delete(l);
                let v = this.get(l, true);
                if (v instanceof S)
                  return v.deleteIn(_);
                throw new Error(`Expected YAML collection at ${l}. Remaining path: ${_}`);
              }
              getIn(o, l) {
                let [_, ...v] = o, b = this.get(_, true);
                return v.length === 0 ? !l && b instanceof y ? b.value : b : b instanceof S ? b.getIn(v, l) : void 0;
              }
              hasAllNullValues() {
                return this.items.every((o) => {
                  if (!o || o.type !== "PAIR")
                    return false;
                  let l = o.value;
                  return l == null || l instanceof y && l.value == null && !l.commentBefore && !l.comment && !l.tag;
                });
              }
              hasIn(o) {
                let [l, ..._] = o;
                if (_.length === 0)
                  return this.has(l);
                let v = this.get(l, true);
                return v instanceof S ? v.hasIn(_) : false;
              }
              setIn(o, l) {
                let [_, ...v] = o;
                if (v.length === 0)
                  this.set(_, l);
                else {
                  let b = this.get(_, true);
                  if (b instanceof S)
                    b.setIn(v, l);
                  else if (b === void 0 && this.schema)
                    this.set(_, E(this.schema, v, l));
                  else
                    throw new Error(`Expected YAML collection at ${_}. Remaining path: ${v}`);
                }
              }
              toJSON() {
                return null;
              }
              toString(o, l, _, v) {
                let { blockItem: b, flowChars: w, isMap: A2, itemIndent: N } = l, { indent: j, indentStep: F, stringify: Q } = o, H = this.type === e.Type.FLOW_MAP || this.type === e.Type.FLOW_SEQ || o.inFlow;
                H && (N += F);
                let oe = A2 && this.hasAllNullValues();
                o = Object.assign({}, o, { allNullValues: oe, indent: N, inFlow: H, type: null });
                let le = false, Z = false, ee = this.items.reduce((de, ne, he) => {
                  let ce;
                  ne && (!le && ne.spaceBefore && de.push({ type: "comment", str: "" }), ne.commentBefore && ne.commentBefore.match(/^.*$/gm).forEach((Ie) => {
                    de.push({ type: "comment", str: `#${Ie}` });
                  }), ne.comment && (ce = ne.comment), H && (!le && ne.spaceBefore || ne.commentBefore || ne.comment || ne.key && (ne.key.commentBefore || ne.key.comment) || ne.value && (ne.value.commentBefore || ne.value.comment)) && (Z = true)), le = false;
                  let fe = Q(ne, o, () => ce = null, () => le = true);
                  return H && !Z && fe.includes(`
`) && (Z = true), H && he < this.items.length - 1 && (fe += ","), fe = c(fe, N, ce), le && (ce || H) && (le = false), de.push({ type: "item", str: fe }), de;
                }, []), X;
                if (ee.length === 0)
                  X = w.start + w.end;
                else if (H) {
                  let { start: de, end: ne } = w, he = ee.map((ce) => ce.str);
                  if (Z || he.reduce((ce, fe) => ce + fe.length + 2, 2) > S.maxFlowStringSingleLineLength) {
                    X = de;
                    for (let ce of he)
                      X += ce ? `
${F}${j}${ce}` : `
`;
                    X += `
${j}${ne}`;
                  } else
                    X = `${de} ${he.join(" ")} ${ne}`;
                } else {
                  let de = ee.map(b);
                  X = de.shift();
                  for (let ne of de)
                    X += ne ? `
${j}${ne}` : `
`;
                }
                return this.comment ? (X += `
` + this.comment.replace(/^/gm, `${j}#`), _ && _()) : le && v && v(), X;
              }
            };
            e._defineProperty(S, "maxFlowStringSingleLineLength", 60);
            function M(o) {
              let l = o instanceof y ? o.value : o;
              return l && typeof l == "string" && (l = Number(l)), Number.isInteger(l) && l >= 0 ? l : null;
            }
            var T = class extends S {
              add(o) {
                this.items.push(o);
              }
              delete(o) {
                let l = M(o);
                return typeof l != "number" ? false : this.items.splice(l, 1).length > 0;
              }
              get(o, l) {
                let _ = M(o);
                if (typeof _ != "number")
                  return;
                let v = this.items[_];
                return !l && v instanceof y ? v.value : v;
              }
              has(o) {
                let l = M(o);
                return typeof l == "number" && l < this.items.length;
              }
              set(o, l) {
                let _ = M(o);
                if (typeof _ != "number")
                  throw new Error(`Expected a valid index, not ${o}.`);
                this.items[_] = l;
              }
              toJSON(o, l) {
                let _ = [];
                l && l.onCreate && l.onCreate(_);
                let v = 0;
                for (let b of this.items)
                  _.push(d(b, String(v++), l));
                return _;
              }
              toString(o, l, _) {
                return o ? super.toString(o, { blockItem: (v) => v.type === "comment" ? v.str : `- ${v.str}`, flowChars: { start: "[", end: "]" }, isMap: false, itemIndent: (o.indent || "") + "  " }, l, _) : JSON.stringify(this);
              }
            }, P = (o, l, _) => l === null ? "" : typeof l != "object" ? String(l) : o instanceof h && _ && _.doc ? o.toString({ anchors: /* @__PURE__ */ Object.create(null), doc: _.doc, indent: "", indentStep: _.indentStep, inFlow: true, inStringifyKey: true, stringify: _.stringify }) : JSON.stringify(l), C = class extends h {
              constructor(o) {
                let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                super(), this.key = o, this.value = l, this.type = C.Type.PAIR;
              }
              get commentBefore() {
                return this.key instanceof h ? this.key.commentBefore : void 0;
              }
              set commentBefore(o) {
                if (this.key == null && (this.key = new y(null)), this.key instanceof h)
                  this.key.commentBefore = o;
                else {
                  let l = "Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";
                  throw new Error(l);
                }
              }
              addToJSMap(o, l) {
                let _ = d(this.key, "", o);
                if (l instanceof Map) {
                  let v = d(this.value, _, o);
                  l.set(_, v);
                } else if (l instanceof Set)
                  l.add(_);
                else {
                  let v = P(this.key, _, o), b = d(this.value, v, o);
                  v in l ? Object.defineProperty(l, v, { value: b, writable: true, enumerable: true, configurable: true }) : l[v] = b;
                }
                return l;
              }
              toJSON(o, l) {
                let _ = l && l.mapAsMap ? /* @__PURE__ */ new Map() : {};
                return this.addToJSMap(l, _);
              }
              toString(o, l, _) {
                if (!o || !o.doc)
                  return JSON.stringify(this);
                let { indent: v, indentSeq: b, simpleKeys: w } = o.doc.options, { key: A2, value: N } = this, j = A2 instanceof h && A2.comment;
                if (w) {
                  if (j)
                    throw new Error("With simple keys, key nodes cannot have comments");
                  if (A2 instanceof S) {
                    let ce = "With simple keys, collection cannot be used as a key value";
                    throw new Error(ce);
                  }
                }
                let F = !w && (!A2 || j || (A2 instanceof h ? A2 instanceof S || A2.type === e.Type.BLOCK_FOLDED || A2.type === e.Type.BLOCK_LITERAL : typeof A2 == "object")), { doc: Q, indent: H, indentStep: oe, stringify: le } = o;
                o = Object.assign({}, o, { implicitKey: !F, indent: H + oe });
                let Z = false, ee = le(A2, o, () => j = null, () => Z = true);
                if (ee = c(ee, o.indent, j), !F && ee.length > 1024) {
                  if (w)
                    throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
                  F = true;
                }
                if (o.allNullValues && !w)
                  return this.comment ? (ee = c(ee, o.indent, this.comment), l && l()) : Z && !j && _ && _(), o.inFlow && !F ? ee : `? ${ee}`;
                ee = F ? `? ${ee}
${H}:` : `${ee}:`, this.comment && (ee = c(ee, o.indent, this.comment), l && l());
                let X = "", de = null;
                if (N instanceof h) {
                  if (N.spaceBefore && (X = `
`), N.commentBefore) {
                    let ce = N.commentBefore.replace(/^/gm, `${o.indent}#`);
                    X += `
${ce}`;
                  }
                  de = N.comment;
                } else
                  N && typeof N == "object" && (N = Q.schema.createNode(N, true));
                o.implicitKey = false, !F && !this.comment && N instanceof y && (o.indentAtStart = ee.length + 1), Z = false, !b && v >= 2 && !o.inFlow && !F && N instanceof T && N.type !== e.Type.FLOW_SEQ && !N.tag && !Q.anchors.getName(N) && (o.indent = o.indent.substr(2));
                let ne = le(N, o, () => de = null, () => Z = true), he = " ";
                return X || this.comment ? he = `${X}
${o.indent}` : !F && N instanceof S ? (!(ne[0] === "[" || ne[0] === "{") || ne.includes(`
`)) && (he = `
${o.indent}`) : ne[0] === `
` && (he = ""), Z && !de && _ && _(), c(ee + he + ne, o.indent, de);
              }
            };
            e._defineProperty(C, "Type", { PAIR: "PAIR", MERGE_PAIR: "MERGE_PAIR" });
            var q = (o, l) => {
              if (o instanceof R) {
                let _ = l.get(o.source);
                return _.count * _.aliasCount;
              } else if (o instanceof S) {
                let _ = 0;
                for (let v of o.items) {
                  let b = q(v, l);
                  b > _ && (_ = b);
                }
                return _;
              } else if (o instanceof C) {
                let _ = q(o.key, l), v = q(o.value, l);
                return Math.max(_, v);
              }
              return 1;
            }, R = class extends h {
              static stringify(o, l) {
                let { range: _, source: v } = o, { anchors: b, doc: w, implicitKey: A2, inStringifyKey: N } = l, j = Object.keys(b).find((Q) => b[Q] === v);
                if (!j && N && (j = w.anchors.getName(v) || w.anchors.newName()), j)
                  return `*${j}${A2 ? " " : ""}`;
                let F = w.anchors.getName(v) ? "Alias node must be after source node" : "Source node not found for alias node";
                throw new Error(`${F} [${_}]`);
              }
              constructor(o) {
                super(), this.source = o, this.type = e.Type.ALIAS;
              }
              set tag(o) {
                throw new Error("Alias nodes cannot have tags");
              }
              toJSON(o, l) {
                if (!l)
                  return d(this.source, o, l);
                let { anchors: _, maxAliasCount: v } = l, b = _.get(this.source);
                if (!b || b.res === void 0) {
                  let w = "This should not happen: Alias anchor was not resolved?";
                  throw this.cstNode ? new e.YAMLReferenceError(this.cstNode, w) : new ReferenceError(w);
                }
                if (v >= 0 && (b.count += 1, b.aliasCount === 0 && (b.aliasCount = q(this.source, _)), b.count * b.aliasCount > v)) {
                  let w = "Excessive alias count indicates a resource exhaustion attack";
                  throw this.cstNode ? new e.YAMLReferenceError(this.cstNode, w) : new ReferenceError(w);
                }
                return b.res;
              }
              toString(o) {
                return R.stringify(this, o);
              }
            };
            e._defineProperty(R, "default", true);
            function B(o, l) {
              let _ = l instanceof y ? l.value : l;
              for (let v of o)
                if (v instanceof C && (v.key === l || v.key === _ || v.key && v.key.value === _))
                  return v;
            }
            var U = class extends S {
              add(o, l) {
                o ? o instanceof C || (o = new C(o.key || o, o.value)) : o = new C(o);
                let _ = B(this.items, o.key), v = this.schema && this.schema.sortMapEntries;
                if (_)
                  if (l)
                    _.value = o.value;
                  else
                    throw new Error(`Key ${o.key} already set`);
                else if (v) {
                  let b = this.items.findIndex((w) => v(o, w) < 0);
                  b === -1 ? this.items.push(o) : this.items.splice(b, 0, o);
                } else
                  this.items.push(o);
              }
              delete(o) {
                let l = B(this.items, o);
                return l ? this.items.splice(this.items.indexOf(l), 1).length > 0 : false;
              }
              get(o, l) {
                let _ = B(this.items, o), v = _ && _.value;
                return !l && v instanceof y ? v.value : v;
              }
              has(o) {
                return !!B(this.items, o);
              }
              set(o, l) {
                this.add(new C(o, l), true);
              }
              toJSON(o, l, _) {
                let v = _ ? new _() : l && l.mapAsMap ? /* @__PURE__ */ new Map() : {};
                l && l.onCreate && l.onCreate(v);
                for (let b of this.items)
                  b.addToJSMap(l, v);
                return v;
              }
              toString(o, l, _) {
                if (!o)
                  return JSON.stringify(this);
                for (let v of this.items)
                  if (!(v instanceof C))
                    throw new Error(`Map items must all be pairs; found ${JSON.stringify(v)} instead`);
                return super.toString(o, { blockItem: (v) => v.str, flowChars: { start: "{", end: "}" }, isMap: true, itemIndent: o.indent || "" }, l, _);
              }
            }, f2 = "<<", i = class extends C {
              constructor(o) {
                if (o instanceof C) {
                  let l = o.value;
                  l instanceof T || (l = new T(), l.items.push(o.value), l.range = o.value.range), super(o.key, l), this.range = o.range;
                } else
                  super(new y(f2), new T());
                this.type = C.Type.MERGE_PAIR;
              }
              addToJSMap(o, l) {
                for (let { source: _ } of this.value.items) {
                  if (!(_ instanceof U))
                    throw new Error("Merge sources must be maps");
                  let v = _.toJSON(null, o, Map);
                  for (let [b, w] of v)
                    l instanceof Map ? l.has(b) || l.set(b, w) : l instanceof Set ? l.add(b) : Object.prototype.hasOwnProperty.call(l, b) || Object.defineProperty(l, b, { value: w, writable: true, enumerable: true, configurable: true });
                }
                return l;
              }
              toString(o, l) {
                let _ = this.value;
                if (_.items.length > 1)
                  return super.toString(o, l);
                this.value = _.items[0];
                let v = super.toString(o, l);
                return this.value = _, v;
              }
            }, t = { defaultType: e.Type.BLOCK_LITERAL, lineWidth: 76 }, s = { trueStr: "true", falseStr: "false" }, a2 = { asBigInt: false }, m = { nullStr: "null" }, g = { defaultType: e.Type.PLAIN, doubleQuoted: { jsonEncoding: false, minMultiLineLength: 40 }, fold: { lineWidth: 80, minContentWidth: 20 } };
            function u(o, l, _) {
              for (let { format: v, test: b, resolve: w } of l)
                if (b) {
                  let A2 = o.match(b);
                  if (A2) {
                    let N = w.apply(null, A2);
                    return N instanceof y || (N = new y(N)), v && (N.format = v), N;
                  }
                }
              return _ && (o = _(o)), new y(o);
            }
            var p = "flow", L = "block", k = "quoted", $ = (o, l) => {
              let _ = o[l + 1];
              for (; _ === " " || _ === "	"; ) {
                do
                  _ = o[l += 1];
                while (_ && _ !== `
`);
                _ = o[l + 1];
              }
              return l;
            };
            function K(o, l, _, v) {
              let { indentAtStart: b, lineWidth: w = 80, minContentWidth: A2 = 20, onFold: N, onOverflow: j } = v;
              if (!w || w < 0)
                return o;
              let F = Math.max(1 + A2, 1 + w - l.length);
              if (o.length <= F)
                return o;
              let Q = [], H = {}, oe = w - l.length;
              typeof b == "number" && (b > w - Math.max(2, A2) ? Q.push(0) : oe = w - b);
              let le, Z, ee = false, X = -1, de = -1, ne = -1;
              _ === L && (X = $(o, X), X !== -1 && (oe = X + F));
              for (let ce; ce = o[X += 1]; ) {
                if (_ === k && ce === "\\") {
                  switch (de = X, o[X + 1]) {
                    case "x":
                      X += 3;
                      break;
                    case "u":
                      X += 5;
                      break;
                    case "U":
                      X += 9;
                      break;
                    default:
                      X += 1;
                  }
                  ne = X;
                }
                if (ce === `
`)
                  _ === L && (X = $(o, X)), oe = X + F, le = void 0;
                else {
                  if (ce === " " && Z && Z !== " " && Z !== `
` && Z !== "	") {
                    let fe = o[X + 1];
                    fe && fe !== " " && fe !== `
` && fe !== "	" && (le = X);
                  }
                  if (X >= oe)
                    if (le)
                      Q.push(le), oe = le + F, le = void 0;
                    else if (_ === k) {
                      for (; Z === " " || Z === "	"; )
                        Z = ce, ce = o[X += 1], ee = true;
                      let fe = X > ne + 1 ? X - 2 : de - 1;
                      if (H[fe])
                        return o;
                      Q.push(fe), H[fe] = true, oe = fe + F, le = void 0;
                    } else
                      ee = true;
                }
                Z = ce;
              }
              if (ee && j && j(), Q.length === 0)
                return o;
              N && N();
              let he = o.slice(0, Q[0]);
              for (let ce = 0; ce < Q.length; ++ce) {
                let fe = Q[ce], Ie = Q[ce + 1] || o.length;
                fe === 0 ? he = `
${l}${o.slice(0, Ie)}` : (_ === k && H[fe] && (he += `${o[fe]}\\`), he += `
${l}${o.slice(fe + 1, Ie)}`);
              }
              return he;
            }
            var V = (o) => {
              let { indentAtStart: l } = o;
              return l ? Object.assign({ indentAtStart: l }, g.fold) : g.fold;
            }, z = (o) => /^(%|---|\.\.\.)/m.test(o);
            function ae(o, l, _) {
              if (!l || l < 0)
                return false;
              let v = l - _, b = o.length;
              if (b <= v)
                return false;
              for (let w = 0, A2 = 0; w < b; ++w)
                if (o[w] === `
`) {
                  if (w - A2 > v)
                    return true;
                  if (A2 = w + 1, b - A2 <= v)
                    return false;
                }
              return true;
            }
            function ue(o, l) {
              let { implicitKey: _ } = l, { jsonEncoding: v, minMultiLineLength: b } = g.doubleQuoted, w = JSON.stringify(o);
              if (v)
                return w;
              let A2 = l.indent || (z(o) ? "  " : ""), N = "", j = 0;
              for (let F = 0, Q = w[F]; Q; Q = w[++F])
                if (Q === " " && w[F + 1] === "\\" && w[F + 2] === "n" && (N += w.slice(j, F) + "\\ ", F += 1, j = F, Q = "\\"), Q === "\\")
                  switch (w[F + 1]) {
                    case "u":
                      {
                        N += w.slice(j, F);
                        let H = w.substr(F + 2, 4);
                        switch (H) {
                          case "0000":
                            N += "\\0";
                            break;
                          case "0007":
                            N += "\\a";
                            break;
                          case "000b":
                            N += "\\v";
                            break;
                          case "001b":
                            N += "\\e";
                            break;
                          case "0085":
                            N += "\\N";
                            break;
                          case "00a0":
                            N += "\\_";
                            break;
                          case "2028":
                            N += "\\L";
                            break;
                          case "2029":
                            N += "\\P";
                            break;
                          default:
                            H.substr(0, 2) === "00" ? N += "\\x" + H.substr(2) : N += w.substr(F, 6);
                        }
                        F += 5, j = F + 1;
                      }
                      break;
                    case "n":
                      if (_ || w[F + 2] === '"' || w.length < b)
                        F += 1;
                      else {
                        for (N += w.slice(j, F) + `

`; w[F + 2] === "\\" && w[F + 3] === "n" && w[F + 4] !== '"'; )
                          N += `
`, F += 2;
                        N += A2, w[F + 2] === " " && (N += "\\"), F += 1, j = F + 1;
                      }
                      break;
                    default:
                      F += 1;
                  }
              return N = j ? N + w.slice(j) : w, _ ? N : K(N, A2, k, V(l));
            }
            function pe(o, l) {
              if (l.implicitKey) {
                if (/\n/.test(o))
                  return ue(o, l);
              } else if (/[ \t]\n|\n[ \t]/.test(o))
                return ue(o, l);
              let _ = l.indent || (z(o) ? "  " : ""), v = "'" + o.replace(/'/g, "''").replace(/\n+/g, `$&
${_}`) + "'";
              return l.implicitKey ? v : K(v, _, p, V(l));
            }
            function ge(o, l, _, v) {
              let { comment: b, type: w, value: A2 } = o;
              if (/\n[\t ]+$/.test(A2) || /^\s*$/.test(A2))
                return ue(A2, l);
              let N = l.indent || (l.forceBlockIndent || z(A2) ? "  " : ""), j = N ? "2" : "1", F = w === e.Type.BLOCK_FOLDED ? false : w === e.Type.BLOCK_LITERAL ? true : !ae(A2, g.fold.lineWidth, N.length), Q = F ? "|" : ">";
              if (!A2)
                return Q + `
`;
              let H = "", oe = "";
              if (A2 = A2.replace(/[\n\t ]*$/, (Z) => {
                let ee = Z.indexOf(`
`);
                return ee === -1 ? Q += "-" : (A2 === Z || ee !== Z.length - 1) && (Q += "+", v && v()), oe = Z.replace(/\n$/, ""), "";
              }).replace(/^[\n ]*/, (Z) => {
                Z.indexOf(" ") !== -1 && (Q += j);
                let ee = Z.match(/ +$/);
                return ee ? (H = Z.slice(0, -ee[0].length), ee[0]) : (H = Z, "");
              }), oe && (oe = oe.replace(/\n+(?!\n|$)/g, `$&${N}`)), H && (H = H.replace(/\n+/g, `$&${N}`)), b && (Q += " #" + b.replace(/ ?[\r\n]+/g, " "), _ && _()), !A2)
                return `${Q}${j}
${N}${oe}`;
              if (F)
                return A2 = A2.replace(/\n+/g, `$&${N}`), `${Q}
${N}${H}${A2}${oe}`;
              A2 = A2.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${N}`);
              let le = K(`${H}${A2}${oe}`, N, L, g.fold);
              return `${Q}
${N}${le}`;
            }
            function O(o, l, _, v) {
              let { comment: b, type: w, value: A2 } = o, { actualString: N, implicitKey: j, indent: F, inFlow: Q } = l;
              if (j && /[\n[\]{},]/.test(A2) || Q && /[[\]{},]/.test(A2))
                return ue(A2, l);
              if (!A2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(A2))
                return j || Q || A2.indexOf(`
`) === -1 ? A2.indexOf('"') !== -1 && A2.indexOf("'") === -1 ? pe(A2, l) : ue(A2, l) : ge(o, l, _, v);
              if (!j && !Q && w !== e.Type.PLAIN && A2.indexOf(`
`) !== -1)
                return ge(o, l, _, v);
              if (F === "" && z(A2))
                return l.forceBlockIndent = true, ge(o, l, _, v);
              let H = A2.replace(/\n+/g, `$&
${F}`);
              if (N) {
                let { tags: le } = l.doc.schema;
                if (typeof u(H, le, le.scalarFallback).value != "string")
                  return ue(A2, l);
              }
              let oe = j ? H : K(H, F, p, V(l));
              return b && !Q && (oe.indexOf(`
`) !== -1 || b.indexOf(`
`) !== -1) ? (_ && _(), r(oe, F, b)) : oe;
            }
            function W(o, l, _, v) {
              let { defaultType: b } = g, { implicitKey: w, inFlow: A2 } = l, { type: N, value: j } = o;
              typeof j != "string" && (j = String(j), o = Object.assign({}, o, { value: j }));
              let F = (H) => {
                switch (H) {
                  case e.Type.BLOCK_FOLDED:
                  case e.Type.BLOCK_LITERAL:
                    return ge(o, l, _, v);
                  case e.Type.QUOTE_DOUBLE:
                    return ue(j, l);
                  case e.Type.QUOTE_SINGLE:
                    return pe(j, l);
                  case e.Type.PLAIN:
                    return O(o, l, _, v);
                  default:
                    return null;
                }
              };
              (N !== e.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(j) || (w || A2) && (N === e.Type.BLOCK_FOLDED || N === e.Type.BLOCK_LITERAL)) && (N = e.Type.QUOTE_DOUBLE);
              let Q = F(N);
              if (Q === null && (Q = F(b), Q === null))
                throw new Error(`Unsupported default string type ${b}`);
              return Q;
            }
            function J(o) {
              let { format: l, minFractionDigits: _, tag: v, value: b } = o;
              if (typeof b == "bigint")
                return String(b);
              if (!isFinite(b))
                return isNaN(b) ? ".nan" : b < 0 ? "-.inf" : ".inf";
              let w = JSON.stringify(b);
              if (!l && _ && (!v || v === "tag:yaml.org,2002:float") && /^\d/.test(w)) {
                let A2 = w.indexOf(".");
                A2 < 0 && (A2 = w.length, w += ".");
                let N = _ - (w.length - A2 - 1);
                for (; N-- > 0; )
                  w += "0";
              }
              return w;
            }
            function x(o, l) {
              let _, v;
              switch (l.type) {
                case e.Type.FLOW_MAP:
                  _ = "}", v = "flow map";
                  break;
                case e.Type.FLOW_SEQ:
                  _ = "]", v = "flow sequence";
                  break;
                default:
                  o.push(new e.YAMLSemanticError(l, "Not a flow collection!?"));
                  return;
              }
              let b;
              for (let w = l.items.length - 1; w >= 0; --w) {
                let A2 = l.items[w];
                if (!A2 || A2.type !== e.Type.COMMENT) {
                  b = A2;
                  break;
                }
              }
              if (b && b.char !== _) {
                let w = `Expected ${v} to end with ${_}`, A2;
                typeof b.offset == "number" ? (A2 = new e.YAMLSemanticError(l, w), A2.offset = b.offset + 1) : (A2 = new e.YAMLSemanticError(b, w), b.range && b.range.end && (A2.offset = b.range.end - b.range.start)), o.push(A2);
              }
            }
            function G(o, l) {
              let _ = l.context.src[l.range.start - 1];
              if (_ !== `
` && _ !== "	" && _ !== " ") {
                let v = "Comments must be separated from other tokens by white space characters";
                o.push(new e.YAMLSemanticError(l, v));
              }
            }
            function re(o, l) {
              let _ = String(l), v = _.substr(0, 8) + "..." + _.substr(-8);
              return new e.YAMLSemanticError(o, `The "${v}" key is too long`);
            }
            function _e(o, l) {
              for (let { afterKey: _, before: v, comment: b } of l) {
                let w = o.items[v];
                w ? (_ && w.value && (w = w.value), b === void 0 ? (_ || !w.commentBefore) && (w.spaceBefore = true) : w.commentBefore ? w.commentBefore += `
` + b : w.commentBefore = b) : b !== void 0 && (o.comment ? o.comment += `
` + b : o.comment = b);
              }
            }
            function ye(o, l) {
              let _ = l.strValue;
              return _ ? typeof _ == "string" ? _ : (_.errors.forEach((v) => {
                v.source || (v.source = l), o.errors.push(v);
              }), _.str) : "";
            }
            function be(o, l) {
              let { handle: _, suffix: v } = l.tag, b = o.tagPrefixes.find((w) => w.handle === _);
              if (!b) {
                let w = o.getDefaults().tagPrefixes;
                if (w && (b = w.find((A2) => A2.handle === _)), !b)
                  throw new e.YAMLSemanticError(l, `The ${_} tag handle is non-default and was not declared.`);
              }
              if (!v)
                throw new e.YAMLSemanticError(l, `The ${_} tag has no suffix.`);
              if (_ === "!" && (o.version || o.options.version) === "1.0") {
                if (v[0] === "^")
                  return o.warnings.push(new e.YAMLWarning(l, "YAML 1.0 ^ tag expansion is not supported")), v;
                if (/[:/]/.test(v)) {
                  let w = v.match(/^([a-z0-9-]+)\/(.*)/i);
                  return w ? `tag:${w[1]}.yaml.org,2002:${w[2]}` : `tag:${v}`;
                }
              }
              return b.prefix + decodeURIComponent(v);
            }
            function ve(o, l) {
              let { tag: _, type: v } = l, b = false;
              if (_) {
                let { handle: w, suffix: A2, verbatim: N } = _;
                if (N) {
                  if (N !== "!" && N !== "!!")
                    return N;
                  let j = `Verbatim tags aren't resolved, so ${N} is invalid.`;
                  o.errors.push(new e.YAMLSemanticError(l, j));
                } else if (w === "!" && !A2)
                  b = true;
                else
                  try {
                    return be(o, l);
                  } catch (j) {
                    o.errors.push(j);
                  }
              }
              switch (v) {
                case e.Type.BLOCK_FOLDED:
                case e.Type.BLOCK_LITERAL:
                case e.Type.QUOTE_DOUBLE:
                case e.Type.QUOTE_SINGLE:
                  return e.defaultTags.STR;
                case e.Type.FLOW_MAP:
                case e.Type.MAP:
                  return e.defaultTags.MAP;
                case e.Type.FLOW_SEQ:
                case e.Type.SEQ:
                  return e.defaultTags.SEQ;
                case e.Type.PLAIN:
                  return b ? e.defaultTags.STR : null;
                default:
                  return null;
              }
            }
            function Ne(o, l, _) {
              let { tags: v } = o.schema, b = [];
              for (let A2 of v)
                if (A2.tag === _)
                  if (A2.test)
                    b.push(A2);
                  else {
                    let N = A2.resolve(o, l);
                    return N instanceof S ? N : new y(N);
                  }
              let w = ye(o, l);
              return typeof w == "string" && b.length > 0 ? u(w, b, v.scalarFallback) : null;
            }
            function Pe(o) {
              let { type: l } = o;
              switch (l) {
                case e.Type.FLOW_MAP:
                case e.Type.MAP:
                  return e.defaultTags.MAP;
                case e.Type.FLOW_SEQ:
                case e.Type.SEQ:
                  return e.defaultTags.SEQ;
                default:
                  return e.defaultTags.STR;
              }
            }
            function ot(o, l, _) {
              try {
                let v = Ne(o, l, _);
                if (v)
                  return _ && l.tag && (v.tag = _), v;
              } catch (v) {
                return v.source || (v.source = l), o.errors.push(v), null;
              }
              try {
                let v = Pe(l);
                if (!v)
                  throw new Error(`The tag ${_} is unavailable`);
                let b = `The tag ${_} is unavailable, falling back to ${v}`;
                o.warnings.push(new e.YAMLWarning(l, b));
                let w = Ne(o, l, v);
                return w.tag = _, w;
              } catch (v) {
                let b = new e.YAMLReferenceError(l, v.message);
                return b.stack = v.stack, o.errors.push(b), null;
              }
            }
            var lt = (o) => {
              if (!o)
                return false;
              let { type: l } = o;
              return l === e.Type.MAP_KEY || l === e.Type.MAP_VALUE || l === e.Type.SEQ_ITEM;
            };
            function ct(o, l) {
              let _ = { before: [], after: [] }, v = false, b = false, w = lt(l.context.parent) ? l.context.parent.props.concat(l.props) : l.props;
              for (let { start: A2, end: N } of w)
                switch (l.context.src[A2]) {
                  case e.Char.COMMENT: {
                    if (!l.commentHasRequiredWhitespace(A2)) {
                      let H = "Comments must be separated from other tokens by white space characters";
                      o.push(new e.YAMLSemanticError(l, H));
                    }
                    let { header: j, valueRange: F } = l;
                    (F && (A2 > F.start || j && A2 > j.start) ? _.after : _.before).push(l.context.src.slice(A2 + 1, N));
                    break;
                  }
                  case e.Char.ANCHOR:
                    if (v) {
                      let j = "A node can have at most one anchor";
                      o.push(new e.YAMLSemanticError(l, j));
                    }
                    v = true;
                    break;
                  case e.Char.TAG:
                    if (b) {
                      let j = "A node can have at most one tag";
                      o.push(new e.YAMLSemanticError(l, j));
                    }
                    b = true;
                    break;
                }
              return { comments: _, hasAnchor: v, hasTag: b };
            }
            function ut(o, l) {
              let { anchors: _, errors: v, schema: b } = o;
              if (l.type === e.Type.ALIAS) {
                let A2 = l.rawValue, N = _.getNode(A2);
                if (!N) {
                  let F = `Aliased anchor not found: ${A2}`;
                  return v.push(new e.YAMLReferenceError(l, F)), null;
                }
                let j = new R(N);
                return _._cstAliases.push(j), j;
              }
              let w = ve(o, l);
              if (w)
                return ot(o, l, w);
              if (l.type !== e.Type.PLAIN) {
                let A2 = `Failed to resolve ${l.type} node here`;
                return v.push(new e.YAMLSyntaxError(l, A2)), null;
              }
              try {
                let A2 = ye(o, l);
                return u(A2, b.tags, b.tags.scalarFallback);
              } catch (A2) {
                return A2.source || (A2.source = l), v.push(A2), null;
              }
            }
            function we(o, l) {
              if (!l)
                return null;
              l.error && o.errors.push(l.error);
              let { comments: _, hasAnchor: v, hasTag: b } = ct(o.errors, l);
              if (v) {
                let { anchors: A2 } = o, N = l.anchor, j = A2.getNode(N);
                j && (A2.map[A2.newName(N)] = j), A2.map[N] = l;
              }
              if (l.type === e.Type.ALIAS && (v || b)) {
                let A2 = "An alias node must not specify any properties";
                o.errors.push(new e.YAMLSemanticError(l, A2));
              }
              let w = ut(o, l);
              if (w) {
                w.range = [l.range.start, l.range.end], o.options.keepCstNodes && (w.cstNode = l), o.options.keepNodeTypes && (w.type = l.type);
                let A2 = _.before.join(`
`);
                A2 && (w.commentBefore = w.commentBefore ? `${w.commentBefore}
${A2}` : A2);
                let N = _.after.join(`
`);
                N && (w.comment = w.comment ? `${w.comment}
${N}` : N);
              }
              return l.resolved = w;
            }
            function ft(o, l) {
              if (l.type !== e.Type.MAP && l.type !== e.Type.FLOW_MAP) {
                let A2 = `A ${l.type} node cannot be resolved as a mapping`;
                return o.errors.push(new e.YAMLSyntaxError(l, A2)), null;
              }
              let { comments: _, items: v } = l.type === e.Type.FLOW_MAP ? gt(o, l) : ht(o, l), b = new U();
              b.items = v, _e(b, _);
              let w = false;
              for (let A2 = 0; A2 < v.length; ++A2) {
                let { key: N } = v[A2];
                if (N instanceof S && (w = true), o.schema.merge && N && N.value === f2) {
                  v[A2] = new i(v[A2]);
                  let j = v[A2].value.items, F = null;
                  j.some((Q) => {
                    if (Q instanceof R) {
                      let { type: H } = Q.source;
                      return H === e.Type.MAP || H === e.Type.FLOW_MAP ? false : F = "Merge nodes aliases can only point to maps";
                    }
                    return F = "Merge nodes can only have Alias nodes as values";
                  }), F && o.errors.push(new e.YAMLSemanticError(l, F));
                } else
                  for (let j = A2 + 1; j < v.length; ++j) {
                    let { key: F } = v[j];
                    if (N === F || N && F && Object.prototype.hasOwnProperty.call(N, "value") && N.value === F.value) {
                      let Q = `Map keys must be unique; "${N}" is repeated`;
                      o.errors.push(new e.YAMLSemanticError(l, Q));
                      break;
                    }
                  }
              }
              if (w && !o.options.mapAsMap) {
                let A2 = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
                o.warnings.push(new e.YAMLWarning(l, A2));
              }
              return l.resolved = b, b;
            }
            var mt = (o) => {
              let { context: { lineStart: l, node: _, src: v }, props: b } = o;
              if (b.length === 0)
                return false;
              let { start: w } = b[0];
              if (_ && w > _.valueRange.start || v[w] !== e.Char.COMMENT)
                return false;
              for (let A2 = l; A2 < w; ++A2)
                if (v[A2] === `
`)
                  return false;
              return true;
            };
            function dt(o, l) {
              if (!mt(o))
                return;
              let _ = o.getPropValue(0, e.Char.COMMENT, true), v = false, b = l.value.commentBefore;
              if (b && b.startsWith(_))
                l.value.commentBefore = b.substr(_.length + 1), v = true;
              else {
                let w = l.value.comment;
                !o.node && w && w.startsWith(_) && (l.value.comment = w.substr(_.length + 1), v = true);
              }
              v && (l.comment = _);
            }
            function ht(o, l) {
              let _ = [], v = [], b, w = null;
              for (let A2 = 0; A2 < l.items.length; ++A2) {
                let N = l.items[A2];
                switch (N.type) {
                  case e.Type.BLANK_LINE:
                    _.push({ afterKey: !!b, before: v.length });
                    break;
                  case e.Type.COMMENT:
                    _.push({ afterKey: !!b, before: v.length, comment: N.comment });
                    break;
                  case e.Type.MAP_KEY:
                    b !== void 0 && v.push(new C(b)), N.error && o.errors.push(N.error), b = we(o, N.node), w = null;
                    break;
                  case e.Type.MAP_VALUE:
                    {
                      if (b === void 0 && (b = null), N.error && o.errors.push(N.error), !N.context.atLineStart && N.node && N.node.type === e.Type.MAP && !N.node.context.atLineStart) {
                        let Q = "Nested mappings are not allowed in compact mappings";
                        o.errors.push(new e.YAMLSemanticError(N.node, Q));
                      }
                      let j = N.node;
                      if (!j && N.props.length > 0) {
                        j = new e.PlainValue(e.Type.PLAIN, []), j.context = { parent: N, src: N.context.src };
                        let Q = N.range.start + 1;
                        if (j.range = { start: Q, end: Q }, j.valueRange = { start: Q, end: Q }, typeof N.range.origStart == "number") {
                          let H = N.range.origStart + 1;
                          j.range.origStart = j.range.origEnd = H, j.valueRange.origStart = j.valueRange.origEnd = H;
                        }
                      }
                      let F = new C(b, we(o, j));
                      dt(N, F), v.push(F), b && typeof w == "number" && N.range.start > w + 1024 && o.errors.push(re(l, b)), b = void 0, w = null;
                    }
                    break;
                  default:
                    b !== void 0 && v.push(new C(b)), b = we(o, N), w = N.range.start, N.error && o.errors.push(N.error);
                    e:
                      for (let j = A2 + 1; ; ++j) {
                        let F = l.items[j];
                        switch (F && F.type) {
                          case e.Type.BLANK_LINE:
                          case e.Type.COMMENT:
                            continue e;
                          case e.Type.MAP_VALUE:
                            break e;
                          default: {
                            let Q = "Implicit map keys need to be followed by map values";
                            o.errors.push(new e.YAMLSemanticError(N, Q));
                            break e;
                          }
                        }
                      }
                    if (N.valueRangeContainsNewline) {
                      let j = "Implicit map keys need to be on a single line";
                      o.errors.push(new e.YAMLSemanticError(N, j));
                    }
                }
              }
              return b !== void 0 && v.push(new C(b)), { comments: _, items: v };
            }
            function gt(o, l) {
              let _ = [], v = [], b, w = false, A2 = "{";
              for (let N = 0; N < l.items.length; ++N) {
                let j = l.items[N];
                if (typeof j.char == "string") {
                  let { char: F, offset: Q } = j;
                  if (F === "?" && b === void 0 && !w) {
                    w = true, A2 = ":";
                    continue;
                  }
                  if (F === ":") {
                    if (b === void 0 && (b = null), A2 === ":") {
                      A2 = ",";
                      continue;
                    }
                  } else if (w && (b === void 0 && F !== "," && (b = null), w = false), b !== void 0 && (v.push(new C(b)), b = void 0, F === ",")) {
                    A2 = ":";
                    continue;
                  }
                  if (F === "}") {
                    if (N === l.items.length - 1)
                      continue;
                  } else if (F === A2) {
                    A2 = ":";
                    continue;
                  }
                  let H = `Flow map contains an unexpected ${F}`, oe = new e.YAMLSyntaxError(l, H);
                  oe.offset = Q, o.errors.push(oe);
                } else
                  j.type === e.Type.BLANK_LINE ? _.push({ afterKey: !!b, before: v.length }) : j.type === e.Type.COMMENT ? (G(o.errors, j), _.push({ afterKey: !!b, before: v.length, comment: j.comment })) : b === void 0 ? (A2 === "," && o.errors.push(new e.YAMLSemanticError(j, "Separator , missing in flow map")), b = we(o, j)) : (A2 !== "," && o.errors.push(new e.YAMLSemanticError(j, "Indicator : missing in flow map entry")), v.push(new C(b, we(o, j))), b = void 0, w = false);
              }
              return x(o.errors, l), b !== void 0 && v.push(new C(b)), { comments: _, items: v };
            }
            function pt(o, l) {
              if (l.type !== e.Type.SEQ && l.type !== e.Type.FLOW_SEQ) {
                let w = `A ${l.type} node cannot be resolved as a sequence`;
                return o.errors.push(new e.YAMLSyntaxError(l, w)), null;
              }
              let { comments: _, items: v } = l.type === e.Type.FLOW_SEQ ? vt(o, l) : _t(o, l), b = new T();
              if (b.items = v, _e(b, _), !o.options.mapAsMap && v.some((w) => w instanceof C && w.key instanceof S)) {
                let w = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
                o.warnings.push(new e.YAMLWarning(l, w));
              }
              return l.resolved = b, b;
            }
            function _t(o, l) {
              let _ = [], v = [];
              for (let b = 0; b < l.items.length; ++b) {
                let w = l.items[b];
                switch (w.type) {
                  case e.Type.BLANK_LINE:
                    _.push({ before: v.length });
                    break;
                  case e.Type.COMMENT:
                    _.push({ comment: w.comment, before: v.length });
                    break;
                  case e.Type.SEQ_ITEM:
                    if (w.error && o.errors.push(w.error), v.push(we(o, w.node)), w.hasProps) {
                      let A2 = "Sequence items cannot have tags or anchors before the - indicator";
                      o.errors.push(new e.YAMLSemanticError(w, A2));
                    }
                    break;
                  default:
                    w.error && o.errors.push(w.error), o.errors.push(new e.YAMLSyntaxError(w, `Unexpected ${w.type} node in sequence`));
                }
              }
              return { comments: _, items: v };
            }
            function vt(o, l) {
              let _ = [], v = [], b = false, w, A2 = null, N = "[", j = null;
              for (let F = 0; F < l.items.length; ++F) {
                let Q = l.items[F];
                if (typeof Q.char == "string") {
                  let { char: H, offset: oe } = Q;
                  if (H !== ":" && (b || w !== void 0) && (b && w === void 0 && (w = N ? v.pop() : null), v.push(new C(w)), b = false, w = void 0, A2 = null), H === N)
                    N = null;
                  else if (!N && H === "?")
                    b = true;
                  else if (N !== "[" && H === ":" && w === void 0) {
                    if (N === ",") {
                      if (w = v.pop(), w instanceof C) {
                        let le = "Chaining flow sequence pairs is invalid", Z = new e.YAMLSemanticError(l, le);
                        Z.offset = oe, o.errors.push(Z);
                      }
                      if (!b && typeof A2 == "number") {
                        let le = Q.range ? Q.range.start : Q.offset;
                        le > A2 + 1024 && o.errors.push(re(l, w));
                        let { src: Z } = j.context;
                        for (let ee = A2; ee < le; ++ee)
                          if (Z[ee] === `
`) {
                            let X = "Implicit keys of flow sequence pairs need to be on a single line";
                            o.errors.push(new e.YAMLSemanticError(j, X));
                            break;
                          }
                      }
                    } else
                      w = null;
                    A2 = null, b = false, N = null;
                  } else if (N === "[" || H !== "]" || F < l.items.length - 1) {
                    let le = `Flow sequence contains an unexpected ${H}`, Z = new e.YAMLSyntaxError(l, le);
                    Z.offset = oe, o.errors.push(Z);
                  }
                } else if (Q.type === e.Type.BLANK_LINE)
                  _.push({ before: v.length });
                else if (Q.type === e.Type.COMMENT)
                  G(o.errors, Q), _.push({ comment: Q.comment, before: v.length });
                else {
                  if (N) {
                    let oe = `Expected a ${N} in flow sequence`;
                    o.errors.push(new e.YAMLSemanticError(Q, oe));
                  }
                  let H = we(o, Q);
                  w === void 0 ? (v.push(H), j = Q) : (v.push(new C(w, H)), w = void 0), A2 = Q.range.start, N = ",";
                }
              }
              return x(o.errors, l), w !== void 0 && v.push(new C(w)), { comments: _, items: v };
            }
            n.Alias = R, n.Collection = S, n.Merge = i, n.Node = h, n.Pair = C, n.Scalar = y, n.YAMLMap = U, n.YAMLSeq = T, n.addComment = c, n.binaryOptions = t, n.boolOptions = s, n.findPair = B, n.intOptions = a2, n.isEmptyPath = I, n.nullOptions = m, n.resolveMap = ft, n.resolveNode = we, n.resolveSeq = pt, n.resolveString = ye, n.strOptions = g, n.stringifyNumber = J, n.stringifyString = W, n.toJSON = d;
          } }), st = D({ "node_modules/yaml/dist/warnings-1000a372.js"(n) {
            "use strict";
            Y();
            var e = Me(), r = ke(), c = { identify: (u) => u instanceof Uint8Array, default: false, tag: "tag:yaml.org,2002:binary", resolve: (u, p) => {
              let L = r.resolveString(u, p);
              if (typeof Buffer == "function")
                return Buffer.from(L, "base64");
              if (typeof atob == "function") {
                let k = atob(L.replace(/[\n\r]/g, "")), $ = new Uint8Array(k.length);
                for (let K = 0; K < k.length; ++K)
                  $[K] = k.charCodeAt(K);
                return $;
              } else {
                let k = "This environment does not support reading binary tags; either Buffer or atob is required";
                return u.errors.push(new e.YAMLReferenceError(p, k)), null;
              }
            }, options: r.binaryOptions, stringify: (u, p, L, k) => {
              let { comment: $, type: K, value: V } = u, z;
              if (typeof Buffer == "function")
                z = V instanceof Buffer ? V.toString("base64") : Buffer.from(V.buffer).toString("base64");
              else if (typeof btoa == "function") {
                let ae = "";
                for (let ue = 0; ue < V.length; ++ue)
                  ae += String.fromCharCode(V[ue]);
                z = btoa(ae);
              } else
                throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
              if (K || (K = r.binaryOptions.defaultType), K === e.Type.QUOTE_DOUBLE)
                V = z;
              else {
                let { lineWidth: ae } = r.binaryOptions, ue = Math.ceil(z.length / ae), pe = new Array(ue);
                for (let ge = 0, O = 0; ge < ue; ++ge, O += ae)
                  pe[ge] = z.substr(O, ae);
                V = pe.join(K === e.Type.BLOCK_LITERAL ? `
` : " ");
              }
              return r.stringifyString({ comment: $, type: K, value: V }, p, L, k);
            } };
            function h(u, p) {
              let L = r.resolveSeq(u, p);
              for (let k = 0; k < L.items.length; ++k) {
                let $ = L.items[k];
                if (!($ instanceof r.Pair)) {
                  if ($ instanceof r.YAMLMap) {
                    if ($.items.length > 1) {
                      let V = "Each pair must have its own sequence indicator";
                      throw new e.YAMLSemanticError(p, V);
                    }
                    let K = $.items[0] || new r.Pair();
                    $.commentBefore && (K.commentBefore = K.commentBefore ? `${$.commentBefore}
${K.commentBefore}` : $.commentBefore), $.comment && (K.comment = K.comment ? `${$.comment}
${K.comment}` : $.comment), $ = K;
                  }
                  L.items[k] = $ instanceof r.Pair ? $ : new r.Pair($);
                }
              }
              return L;
            }
            function d(u, p, L) {
              let k = new r.YAMLSeq(u);
              k.tag = "tag:yaml.org,2002:pairs";
              for (let $ of p) {
                let K, V;
                if (Array.isArray($))
                  if ($.length === 2)
                    K = $[0], V = $[1];
                  else
                    throw new TypeError(`Expected [key, value] tuple: ${$}`);
                else if ($ && $ instanceof Object) {
                  let ae = Object.keys($);
                  if (ae.length === 1)
                    K = ae[0], V = $[K];
                  else
                    throw new TypeError(`Expected { key: value } tuple: ${$}`);
                } else
                  K = $;
                let z = u.createPair(K, V, L);
                k.items.push(z);
              }
              return k;
            }
            var y = { default: false, tag: "tag:yaml.org,2002:pairs", resolve: h, createNode: d }, E = class extends r.YAMLSeq {
              constructor() {
                super(), e._defineProperty(this, "add", r.YAMLMap.prototype.add.bind(this)), e._defineProperty(this, "delete", r.YAMLMap.prototype.delete.bind(this)), e._defineProperty(this, "get", r.YAMLMap.prototype.get.bind(this)), e._defineProperty(this, "has", r.YAMLMap.prototype.has.bind(this)), e._defineProperty(this, "set", r.YAMLMap.prototype.set.bind(this)), this.tag = E.tag;
              }
              toJSON(u, p) {
                let L = /* @__PURE__ */ new Map();
                p && p.onCreate && p.onCreate(L);
                for (let k of this.items) {
                  let $, K;
                  if (k instanceof r.Pair ? ($ = r.toJSON(k.key, "", p), K = r.toJSON(k.value, $, p)) : $ = r.toJSON(k, "", p), L.has($))
                    throw new Error("Ordered maps must not include duplicate keys");
                  L.set($, K);
                }
                return L;
              }
            };
            e._defineProperty(E, "tag", "tag:yaml.org,2002:omap");
            function I(u, p) {
              let L = h(u, p), k = [];
              for (let { key: $ } of L.items)
                if ($ instanceof r.Scalar)
                  if (k.includes($.value)) {
                    let K = "Ordered maps must not include duplicate keys";
                    throw new e.YAMLSemanticError(p, K);
                  } else
                    k.push($.value);
              return Object.assign(new E(), L);
            }
            function S(u, p, L) {
              let k = d(u, p, L), $ = new E();
              return $.items = k.items, $;
            }
            var M = { identify: (u) => u instanceof Map, nodeClass: E, default: false, tag: "tag:yaml.org,2002:omap", resolve: I, createNode: S }, T = class extends r.YAMLMap {
              constructor() {
                super(), this.tag = T.tag;
              }
              add(u) {
                let p = u instanceof r.Pair ? u : new r.Pair(u);
                r.findPair(this.items, p.key) || this.items.push(p);
              }
              get(u, p) {
                let L = r.findPair(this.items, u);
                return !p && L instanceof r.Pair ? L.key instanceof r.Scalar ? L.key.value : L.key : L;
              }
              set(u, p) {
                if (typeof p != "boolean")
                  throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof p}`);
                let L = r.findPair(this.items, u);
                L && !p ? this.items.splice(this.items.indexOf(L), 1) : !L && p && this.items.push(new r.Pair(u));
              }
              toJSON(u, p) {
                return super.toJSON(u, p, Set);
              }
              toString(u, p, L) {
                if (!u)
                  return JSON.stringify(this);
                if (this.hasAllNullValues())
                  return super.toString(u, p, L);
                throw new Error("Set items must all have null values");
              }
            };
            e._defineProperty(T, "tag", "tag:yaml.org,2002:set");
            function P(u, p) {
              let L = r.resolveMap(u, p);
              if (!L.hasAllNullValues())
                throw new e.YAMLSemanticError(p, "Set items must all have null values");
              return Object.assign(new T(), L);
            }
            function C(u, p, L) {
              let k = new T();
              for (let $ of p)
                k.items.push(u.createPair($, null, L));
              return k;
            }
            var q = { identify: (u) => u instanceof Set, nodeClass: T, default: false, tag: "tag:yaml.org,2002:set", resolve: P, createNode: C }, R = (u, p) => {
              let L = p.split(":").reduce((k, $) => k * 60 + Number($), 0);
              return u === "-" ? -L : L;
            }, B = (u) => {
              let { value: p } = u;
              if (isNaN(p) || !isFinite(p))
                return r.stringifyNumber(p);
              let L = "";
              p < 0 && (L = "-", p = Math.abs(p));
              let k = [p % 60];
              return p < 60 ? k.unshift(0) : (p = Math.round((p - k[0]) / 60), k.unshift(p % 60), p >= 60 && (p = Math.round((p - k[0]) / 60), k.unshift(p))), L + k.map(($) => $ < 10 ? "0" + String($) : String($)).join(":").replace(/000000\d*$/, "");
            }, U = { identify: (u) => typeof u == "number", default: true, tag: "tag:yaml.org,2002:int", format: "TIME", test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/, resolve: (u, p, L) => R(p, L.replace(/_/g, "")), stringify: B }, f2 = { identify: (u) => typeof u == "number", default: true, tag: "tag:yaml.org,2002:float", format: "TIME", test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/, resolve: (u, p, L) => R(p, L.replace(/_/g, "")), stringify: B }, i = { identify: (u) => u instanceof Date, default: true, tag: "tag:yaml.org,2002:timestamp", test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"), resolve: (u, p, L, k, $, K, V, z, ae) => {
              z && (z = (z + "00").substr(1, 3));
              let ue = Date.UTC(p, L - 1, k, $ || 0, K || 0, V || 0, z || 0);
              if (ae && ae !== "Z") {
                let pe = R(ae[0], ae.slice(1));
                Math.abs(pe) < 30 && (pe *= 60), ue -= 6e4 * pe;
              }
              return new Date(ue);
            }, stringify: (u) => {
              let { value: p } = u;
              return p.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "");
            } };
            function t(u) {
              let p = typeof Te < "u" && Te.env || {};
              return u ? typeof YAML_SILENCE_DEPRECATION_WARNINGS < "u" ? !YAML_SILENCE_DEPRECATION_WARNINGS : !p.YAML_SILENCE_DEPRECATION_WARNINGS : typeof YAML_SILENCE_WARNINGS < "u" ? !YAML_SILENCE_WARNINGS : !p.YAML_SILENCE_WARNINGS;
            }
            function s(u, p) {
              if (t(false)) {
                let L = typeof Te < "u" && Te.emitWarning;
                L ? L(u, p) : console.warn(p ? `${p}: ${u}` : u);
              }
            }
            function a2(u) {
              if (t(true)) {
                let p = u.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/");
                s(`The endpoint 'yaml/${p}' will be removed in a future release.`, "DeprecationWarning");
              }
            }
            var m = {};
            function g(u, p) {
              if (!m[u] && t(true)) {
                m[u] = true;
                let L = `The option '${u}' will be removed in a future release`;
                L += p ? `, use '${p}' instead.` : ".", s(L, "DeprecationWarning");
              }
            }
            n.binary = c, n.floatTime = f2, n.intTime = U, n.omap = M, n.pairs = y, n.set = q, n.timestamp = i, n.warn = s, n.warnFileDeprecation = a2, n.warnOptionDeprecation = g;
          } }), it = D({ "node_modules/yaml/dist/Schema-88e323a7.js"(n) {
            "use strict";
            Y();
            var e = Me(), r = ke(), c = st();
            function h(O, W, J) {
              let x = new r.YAMLMap(O);
              if (W instanceof Map)
                for (let [G, re] of W)
                  x.items.push(O.createPair(G, re, J));
              else if (W && typeof W == "object")
                for (let G of Object.keys(W))
                  x.items.push(O.createPair(G, W[G], J));
              return typeof O.sortMapEntries == "function" && x.items.sort(O.sortMapEntries), x;
            }
            var d = { createNode: h, default: true, nodeClass: r.YAMLMap, tag: "tag:yaml.org,2002:map", resolve: r.resolveMap };
            function y(O, W, J) {
              let x = new r.YAMLSeq(O);
              if (W && W[Symbol.iterator])
                for (let G of W) {
                  let re = O.createNode(G, J.wrapScalars, null, J);
                  x.items.push(re);
                }
              return x;
            }
            var E = { createNode: y, default: true, nodeClass: r.YAMLSeq, tag: "tag:yaml.org,2002:seq", resolve: r.resolveSeq }, I = { identify: (O) => typeof O == "string", default: true, tag: "tag:yaml.org,2002:str", resolve: r.resolveString, stringify(O, W, J, x) {
              return W = Object.assign({ actualString: true }, W), r.stringifyString(O, W, J, x);
            }, options: r.strOptions }, S = [d, E, I], M = (O) => typeof O == "bigint" || Number.isInteger(O), T = (O, W, J) => r.intOptions.asBigInt ? BigInt(O) : parseInt(W, J);
            function P(O, W, J) {
              let { value: x } = O;
              return M(x) && x >= 0 ? J + x.toString(W) : r.stringifyNumber(O);
            }
            var C = { identify: (O) => O == null, createNode: (O, W, J) => J.wrapScalars ? new r.Scalar(null) : null, default: true, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => null, options: r.nullOptions, stringify: () => r.nullOptions.nullStr }, q = { identify: (O) => typeof O == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/, resolve: (O) => O[0] === "t" || O[0] === "T", options: r.boolOptions, stringify: (O) => {
              let { value: W } = O;
              return W ? r.boolOptions.trueStr : r.boolOptions.falseStr;
            } }, R = { identify: (O) => M(O) && O >= 0, default: true, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^0o([0-7]+)$/, resolve: (O, W) => T(O, W, 8), options: r.intOptions, stringify: (O) => P(O, 8, "0o") }, B = { identify: M, default: true, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9]+$/, resolve: (O) => T(O, O, 10), options: r.intOptions, stringify: r.stringifyNumber }, U = { identify: (O) => M(O) && O >= 0, default: true, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^0x([0-9a-fA-F]+)$/, resolve: (O, W) => T(O, W, 16), options: r.intOptions, stringify: (O) => P(O, 16, "0x") }, f2 = { identify: (O) => typeof O == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.inf|(\.nan))$/i, resolve: (O, W) => W ? NaN : O[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: r.stringifyNumber }, i = { identify: (O) => typeof O == "number", default: true, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/, resolve: (O) => parseFloat(O), stringify: (O) => {
              let { value: W } = O;
              return Number(W).toExponential();
            } }, t = { identify: (O) => typeof O == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/, resolve(O, W, J) {
              let x = W || J, G = new r.Scalar(parseFloat(O));
              return x && x[x.length - 1] === "0" && (G.minFractionDigits = x.length), G;
            }, stringify: r.stringifyNumber }, s = S.concat([C, q, R, B, U, f2, i, t]), a2 = (O) => typeof O == "bigint" || Number.isInteger(O), m = (O) => {
              let { value: W } = O;
              return JSON.stringify(W);
            }, g = [d, E, { identify: (O) => typeof O == "string", default: true, tag: "tag:yaml.org,2002:str", resolve: r.resolveString, stringify: m }, { identify: (O) => O == null, createNode: (O, W, J) => J.wrapScalars ? new r.Scalar(null) : null, default: true, tag: "tag:yaml.org,2002:null", test: /^null$/, resolve: () => null, stringify: m }, { identify: (O) => typeof O == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^true|false$/, resolve: (O) => O === "true", stringify: m }, { identify: a2, default: true, tag: "tag:yaml.org,2002:int", test: /^-?(?:0|[1-9][0-9]*)$/, resolve: (O) => r.intOptions.asBigInt ? BigInt(O) : parseInt(O, 10), stringify: (O) => {
              let { value: W } = O;
              return a2(W) ? W.toString() : JSON.stringify(W);
            } }, { identify: (O) => typeof O == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/, resolve: (O) => parseFloat(O), stringify: m }];
            g.scalarFallback = (O) => {
              throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(O)}`);
            };
            var u = (O) => {
              let { value: W } = O;
              return W ? r.boolOptions.trueStr : r.boolOptions.falseStr;
            }, p = (O) => typeof O == "bigint" || Number.isInteger(O);
            function L(O, W, J) {
              let x = W.replace(/_/g, "");
              if (r.intOptions.asBigInt) {
                switch (J) {
                  case 2:
                    x = `0b${x}`;
                    break;
                  case 8:
                    x = `0o${x}`;
                    break;
                  case 16:
                    x = `0x${x}`;
                    break;
                }
                let re = BigInt(x);
                return O === "-" ? BigInt(-1) * re : re;
              }
              let G = parseInt(x, J);
              return O === "-" ? -1 * G : G;
            }
            function k(O, W, J) {
              let { value: x } = O;
              if (p(x)) {
                let G = x.toString(W);
                return x < 0 ? "-" + J + G.substr(1) : J + G;
              }
              return r.stringifyNumber(O);
            }
            var $ = S.concat([{ identify: (O) => O == null, createNode: (O, W, J) => J.wrapScalars ? new r.Scalar(null) : null, default: true, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => null, options: r.nullOptions, stringify: () => r.nullOptions.nullStr }, { identify: (O) => typeof O == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/, resolve: () => true, options: r.boolOptions, stringify: u }, { identify: (O) => typeof O == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i, resolve: () => false, options: r.boolOptions, stringify: u }, { identify: p, default: true, tag: "tag:yaml.org,2002:int", format: "BIN", test: /^([-+]?)0b([0-1_]+)$/, resolve: (O, W, J) => L(W, J, 2), stringify: (O) => k(O, 2, "0b") }, { identify: p, default: true, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^([-+]?)0([0-7_]+)$/, resolve: (O, W, J) => L(W, J, 8), stringify: (O) => k(O, 8, "0") }, { identify: p, default: true, tag: "tag:yaml.org,2002:int", test: /^([-+]?)([0-9][0-9_]*)$/, resolve: (O, W, J) => L(W, J, 10), stringify: r.stringifyNumber }, { identify: p, default: true, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^([-+]?)0x([0-9a-fA-F_]+)$/, resolve: (O, W, J) => L(W, J, 16), stringify: (O) => k(O, 16, "0x") }, { identify: (O) => typeof O == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.inf|(\.nan))$/i, resolve: (O, W) => W ? NaN : O[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: r.stringifyNumber }, { identify: (O) => typeof O == "number", default: true, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/, resolve: (O) => parseFloat(O.replace(/_/g, "")), stringify: (O) => {
              let { value: W } = O;
              return Number(W).toExponential();
            } }, { identify: (O) => typeof O == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/, resolve(O, W) {
              let J = new r.Scalar(parseFloat(O.replace(/_/g, "")));
              if (W) {
                let x = W.replace(/_/g, "");
                x[x.length - 1] === "0" && (J.minFractionDigits = x.length);
              }
              return J;
            }, stringify: r.stringifyNumber }], c.binary, c.omap, c.pairs, c.set, c.intTime, c.floatTime, c.timestamp), K = { core: s, failsafe: S, json: g, yaml11: $ }, V = { binary: c.binary, bool: q, float: t, floatExp: i, floatNaN: f2, floatTime: c.floatTime, int: B, intHex: U, intOct: R, intTime: c.intTime, map: d, null: C, omap: c.omap, pairs: c.pairs, seq: E, set: c.set, timestamp: c.timestamp };
            function z(O, W, J) {
              if (W) {
                let x = J.filter((re) => re.tag === W), G = x.find((re) => !re.format) || x[0];
                if (!G)
                  throw new Error(`Tag ${W} not found`);
                return G;
              }
              return J.find((x) => (x.identify && x.identify(O) || x.class && O instanceof x.class) && !x.format);
            }
            function ae(O, W, J) {
              if (O instanceof r.Node)
                return O;
              let { defaultPrefix: x, onTagObj: G, prevObjects: re, schema: _e, wrapScalars: ye } = J;
              W && W.startsWith("!!") && (W = x + W.slice(2));
              let be = z(O, W, _e.tags);
              if (!be) {
                if (typeof O.toJSON == "function" && (O = O.toJSON()), !O || typeof O != "object")
                  return ye ? new r.Scalar(O) : O;
                be = O instanceof Map ? d : O[Symbol.iterator] ? E : d;
              }
              G && (G(be), delete J.onTagObj);
              let ve = { value: void 0, node: void 0 };
              if (O && typeof O == "object" && re) {
                let Ne = re.get(O);
                if (Ne) {
                  let Pe = new r.Alias(Ne);
                  return J.aliasNodes.push(Pe), Pe;
                }
                ve.value = O, re.set(O, ve);
              }
              return ve.node = be.createNode ? be.createNode(J.schema, O, J) : ye ? new r.Scalar(O) : O, W && ve.node instanceof r.Node && (ve.node.tag = W), ve.node;
            }
            function ue(O, W, J, x) {
              let G = O[x.replace(/\W/g, "")];
              if (!G) {
                let re = Object.keys(O).map((_e) => JSON.stringify(_e)).join(", ");
                throw new Error(`Unknown schema "${x}"; use one of ${re}`);
              }
              if (Array.isArray(J))
                for (let re of J)
                  G = G.concat(re);
              else
                typeof J == "function" && (G = J(G.slice()));
              for (let re = 0; re < G.length; ++re) {
                let _e = G[re];
                if (typeof _e == "string") {
                  let ye = W[_e];
                  if (!ye) {
                    let be = Object.keys(W).map((ve) => JSON.stringify(ve)).join(", ");
                    throw new Error(`Unknown custom tag "${_e}"; use one of ${be}`);
                  }
                  G[re] = ye;
                }
              }
              return G;
            }
            var pe = (O, W) => O.key < W.key ? -1 : O.key > W.key ? 1 : 0, ge = class {
              constructor(O) {
                let { customTags: W, merge: J, schema: x, sortMapEntries: G, tags: re } = O;
                this.merge = !!J, this.name = x, this.sortMapEntries = G === true ? pe : G || null, !W && re && c.warnOptionDeprecation("tags", "customTags"), this.tags = ue(K, V, W || re, x);
              }
              createNode(O, W, J, x) {
                let G = { defaultPrefix: ge.defaultPrefix, schema: this, wrapScalars: W }, re = x ? Object.assign(x, G) : G;
                return ae(O, J, re);
              }
              createPair(O, W, J) {
                J || (J = { wrapScalars: true });
                let x = this.createNode(O, J.wrapScalars, null, J), G = this.createNode(W, J.wrapScalars, null, J);
                return new r.Pair(x, G);
              }
            };
            e._defineProperty(ge, "defaultPrefix", e.defaultTagPrefix), e._defineProperty(ge, "defaultTags", e.defaultTags), n.Schema = ge;
          } }), xr = D({ "node_modules/yaml/dist/Document-9b4560a1.js"(n) {
            "use strict";
            Y();
            var e = Me(), r = ke(), c = it(), h = { anchorPrefix: "a", customTags: null, indent: 2, indentSeq: true, keepCstNodes: false, keepNodeTypes: true, keepBlobsInJSON: true, mapAsMap: false, maxAliasCount: 100, prettyErrors: false, simpleKeys: false, version: "1.2" }, d = { get binary() {
              return r.binaryOptions;
            }, set binary(t) {
              Object.assign(r.binaryOptions, t);
            }, get bool() {
              return r.boolOptions;
            }, set bool(t) {
              Object.assign(r.boolOptions, t);
            }, get int() {
              return r.intOptions;
            }, set int(t) {
              Object.assign(r.intOptions, t);
            }, get null() {
              return r.nullOptions;
            }, set null(t) {
              Object.assign(r.nullOptions, t);
            }, get str() {
              return r.strOptions;
            }, set str(t) {
              Object.assign(r.strOptions, t);
            } }, y = { "1.0": { schema: "yaml-1.1", merge: true, tagPrefixes: [{ handle: "!", prefix: e.defaultTagPrefix }, { handle: "!!", prefix: "tag:private.yaml.org,2002:" }] }, 1.1: { schema: "yaml-1.1", merge: true, tagPrefixes: [{ handle: "!", prefix: "!" }, { handle: "!!", prefix: e.defaultTagPrefix }] }, 1.2: { schema: "core", merge: false, tagPrefixes: [{ handle: "!", prefix: "!" }, { handle: "!!", prefix: e.defaultTagPrefix }] } };
            function E(t, s) {
              if ((t.version || t.options.version) === "1.0") {
                let g = s.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
                if (g)
                  return "!" + g[1];
                let u = s.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
                return u ? `!${u[1]}/${u[2]}` : `!${s.replace(/^tag:/, "")}`;
              }
              let a2 = t.tagPrefixes.find((g) => s.indexOf(g.prefix) === 0);
              if (!a2) {
                let g = t.getDefaults().tagPrefixes;
                a2 = g && g.find((u) => s.indexOf(u.prefix) === 0);
              }
              if (!a2)
                return s[0] === "!" ? s : `!<${s}>`;
              let m = s.substr(a2.prefix.length).replace(/[!,[\]{}]/g, (g) => ({ "!": "%21", ",": "%2C", "[": "%5B", "]": "%5D", "{": "%7B", "}": "%7D" })[g]);
              return a2.handle + m;
            }
            function I(t, s) {
              if (s instanceof r.Alias)
                return r.Alias;
              if (s.tag) {
                let g = t.filter((u) => u.tag === s.tag);
                if (g.length > 0)
                  return g.find((u) => u.format === s.format) || g[0];
              }
              let a2, m;
              if (s instanceof r.Scalar) {
                m = s.value;
                let g = t.filter((u) => u.identify && u.identify(m) || u.class && m instanceof u.class);
                a2 = g.find((u) => u.format === s.format) || g.find((u) => !u.format);
              } else
                m = s, a2 = t.find((g) => g.nodeClass && m instanceof g.nodeClass);
              if (!a2) {
                let g = m && m.constructor ? m.constructor.name : typeof m;
                throw new Error(`Tag not resolved for ${g} value`);
              }
              return a2;
            }
            function S(t, s, a2) {
              let { anchors: m, doc: g } = a2, u = [], p = g.anchors.getName(t);
              return p && (m[p] = t, u.push(`&${p}`)), t.tag ? u.push(E(g, t.tag)) : s.default || u.push(E(g, s.tag)), u.join(" ");
            }
            function M(t, s, a2, m) {
              let { anchors: g, schema: u } = s.doc, p;
              if (!(t instanceof r.Node)) {
                let $ = { aliasNodes: [], onTagObj: (K) => p = K, prevObjects: /* @__PURE__ */ new Map() };
                t = u.createNode(t, true, null, $);
                for (let K of $.aliasNodes) {
                  K.source = K.source.node;
                  let V = g.getName(K.source);
                  V || (V = g.newName(), g.map[V] = K.source);
                }
              }
              if (t instanceof r.Pair)
                return t.toString(s, a2, m);
              p || (p = I(u.tags, t));
              let L = S(t, p, s);
              L.length > 0 && (s.indentAtStart = (s.indentAtStart || 0) + L.length + 1);
              let k = typeof p.stringify == "function" ? p.stringify(t, s, a2, m) : t instanceof r.Scalar ? r.stringifyString(t, s, a2, m) : t.toString(s, a2, m);
              return L ? t instanceof r.Scalar || k[0] === "{" || k[0] === "[" ? `${L} ${k}` : `${L}
${s.indent}${k}` : k;
            }
            var T = class {
              static validAnchorNode(t) {
                return t instanceof r.Scalar || t instanceof r.YAMLSeq || t instanceof r.YAMLMap;
              }
              constructor(t) {
                e._defineProperty(this, "map", /* @__PURE__ */ Object.create(null)), this.prefix = t;
              }
              createAlias(t, s) {
                return this.setAnchor(t, s), new r.Alias(t);
              }
              createMergePair() {
                let t = new r.Merge();
                for (var s = arguments.length, a2 = new Array(s), m = 0; m < s; m++)
                  a2[m] = arguments[m];
                return t.value.items = a2.map((g) => {
                  if (g instanceof r.Alias) {
                    if (g.source instanceof r.YAMLMap)
                      return g;
                  } else if (g instanceof r.YAMLMap)
                    return this.createAlias(g);
                  throw new Error("Merge sources must be Map nodes or their Aliases");
                }), t;
              }
              getName(t) {
                let { map: s } = this;
                return Object.keys(s).find((a2) => s[a2] === t);
              }
              getNames() {
                return Object.keys(this.map);
              }
              getNode(t) {
                return this.map[t];
              }
              newName(t) {
                t || (t = this.prefix);
                let s = Object.keys(this.map);
                for (let a2 = 1; ; ++a2) {
                  let m = `${t}${a2}`;
                  if (!s.includes(m))
                    return m;
                }
              }
              resolveNodes() {
                let { map: t, _cstAliases: s } = this;
                Object.keys(t).forEach((a2) => {
                  t[a2] = t[a2].resolved;
                }), s.forEach((a2) => {
                  a2.source = a2.source.resolved;
                }), delete this._cstAliases;
              }
              setAnchor(t, s) {
                if (t != null && !T.validAnchorNode(t))
                  throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");
                if (s && /[\x00-\x19\s,[\]{}]/.test(s))
                  throw new Error("Anchor names must not contain whitespace or control characters");
                let { map: a2 } = this, m = t && Object.keys(a2).find((g) => a2[g] === t);
                if (m)
                  if (s)
                    m !== s && (delete a2[m], a2[s] = t);
                  else
                    return m;
                else {
                  if (!s) {
                    if (!t)
                      return null;
                    s = this.newName();
                  }
                  a2[s] = t;
                }
                return s;
              }
            }, P = (t, s) => {
              if (t && typeof t == "object") {
                let { tag: a2 } = t;
                t instanceof r.Collection ? (a2 && (s[a2] = true), t.items.forEach((m) => P(m, s))) : t instanceof r.Pair ? (P(t.key, s), P(t.value, s)) : t instanceof r.Scalar && a2 && (s[a2] = true);
              }
              return s;
            }, C = (t) => Object.keys(P(t, {}));
            function q(t, s) {
              let a2 = { before: [], after: [] }, m, g = false;
              for (let u of s)
                if (u.valueRange) {
                  if (m !== void 0) {
                    let L = "Document contains trailing content not separated by a ... or --- line";
                    t.errors.push(new e.YAMLSyntaxError(u, L));
                    break;
                  }
                  let p = r.resolveNode(t, u);
                  g && (p.spaceBefore = true, g = false), m = p;
                } else
                  u.comment !== null ? (m === void 0 ? a2.before : a2.after).push(u.comment) : u.type === e.Type.BLANK_LINE && (g = true, m === void 0 && a2.before.length > 0 && !t.commentBefore && (t.commentBefore = a2.before.join(`
`), a2.before = []));
              if (t.contents = m || null, !m)
                t.comment = a2.before.concat(a2.after).join(`
`) || null;
              else {
                let u = a2.before.join(`
`);
                if (u) {
                  let p = m instanceof r.Collection && m.items[0] ? m.items[0] : m;
                  p.commentBefore = p.commentBefore ? `${u}
${p.commentBefore}` : u;
                }
                t.comment = a2.after.join(`
`) || null;
              }
            }
            function R(t, s) {
              let { tagPrefixes: a2 } = t, [m, g] = s.parameters;
              if (!m || !g) {
                let u = "Insufficient parameters given for %TAG directive";
                throw new e.YAMLSemanticError(s, u);
              }
              if (a2.some((u) => u.handle === m)) {
                let u = "The %TAG directive must only be given at most once per handle in the same document.";
                throw new e.YAMLSemanticError(s, u);
              }
              return { handle: m, prefix: g };
            }
            function B(t, s) {
              let [a2] = s.parameters;
              if (s.name === "YAML:1.0" && (a2 = "1.0"), !a2) {
                let m = "Insufficient parameters given for %YAML directive";
                throw new e.YAMLSemanticError(s, m);
              }
              if (!y[a2]) {
                let g = `Document will be parsed as YAML ${t.version || t.options.version} rather than YAML ${a2}`;
                t.warnings.push(new e.YAMLWarning(s, g));
              }
              return a2;
            }
            function U(t, s, a2) {
              let m = [], g = false;
              for (let u of s) {
                let { comment: p, name: L } = u;
                switch (L) {
                  case "TAG":
                    try {
                      t.tagPrefixes.push(R(t, u));
                    } catch (k) {
                      t.errors.push(k);
                    }
                    g = true;
                    break;
                  case "YAML":
                  case "YAML:1.0":
                    if (t.version) {
                      let k = "The %YAML directive must only be given at most once per document.";
                      t.errors.push(new e.YAMLSemanticError(u, k));
                    }
                    try {
                      t.version = B(t, u);
                    } catch (k) {
                      t.errors.push(k);
                    }
                    g = true;
                    break;
                  default:
                    if (L) {
                      let k = `YAML only supports %TAG and %YAML directives, and not %${L}`;
                      t.warnings.push(new e.YAMLWarning(u, k));
                    }
                }
                p && m.push(p);
              }
              if (a2 && !g && (t.version || a2.version || t.options.version) === "1.1") {
                let u = (p) => {
                  let { handle: L, prefix: k } = p;
                  return { handle: L, prefix: k };
                };
                t.tagPrefixes = a2.tagPrefixes.map(u), t.version = a2.version;
              }
              t.commentBefore = m.join(`
`) || null;
            }
            function f2(t) {
              if (t instanceof r.Collection)
                return true;
              throw new Error("Expected a YAML collection as document contents");
            }
            var i = class {
              constructor(t) {
                this.anchors = new T(t.anchorPrefix), this.commentBefore = null, this.comment = null, this.contents = null, this.directivesEndMarker = null, this.errors = [], this.options = t, this.schema = null, this.tagPrefixes = [], this.version = null, this.warnings = [];
              }
              add(t) {
                return f2(this.contents), this.contents.add(t);
              }
              addIn(t, s) {
                f2(this.contents), this.contents.addIn(t, s);
              }
              delete(t) {
                return f2(this.contents), this.contents.delete(t);
              }
              deleteIn(t) {
                return r.isEmptyPath(t) ? this.contents == null ? false : (this.contents = null, true) : (f2(this.contents), this.contents.deleteIn(t));
              }
              getDefaults() {
                return i.defaults[this.version] || i.defaults[this.options.version] || {};
              }
              get(t, s) {
                return this.contents instanceof r.Collection ? this.contents.get(t, s) : void 0;
              }
              getIn(t, s) {
                return r.isEmptyPath(t) ? !s && this.contents instanceof r.Scalar ? this.contents.value : this.contents : this.contents instanceof r.Collection ? this.contents.getIn(t, s) : void 0;
              }
              has(t) {
                return this.contents instanceof r.Collection ? this.contents.has(t) : false;
              }
              hasIn(t) {
                return r.isEmptyPath(t) ? this.contents !== void 0 : this.contents instanceof r.Collection ? this.contents.hasIn(t) : false;
              }
              set(t, s) {
                f2(this.contents), this.contents.set(t, s);
              }
              setIn(t, s) {
                r.isEmptyPath(t) ? this.contents = s : (f2(this.contents), this.contents.setIn(t, s));
              }
              setSchema(t, s) {
                if (!t && !s && this.schema)
                  return;
                typeof t == "number" && (t = t.toFixed(1)), t === "1.0" || t === "1.1" || t === "1.2" ? (this.version ? this.version = t : this.options.version = t, delete this.options.schema) : t && typeof t == "string" && (this.options.schema = t), Array.isArray(s) && (this.options.customTags = s);
                let a2 = Object.assign({}, this.getDefaults(), this.options);
                this.schema = new c.Schema(a2);
              }
              parse(t, s) {
                this.options.keepCstNodes && (this.cstNode = t), this.options.keepNodeTypes && (this.type = "DOCUMENT");
                let { directives: a2 = [], contents: m = [], directivesEndMarker: g, error: u, valueRange: p } = t;
                if (u && (u.source || (u.source = this), this.errors.push(u)), U(this, a2, s), g && (this.directivesEndMarker = true), this.range = p ? [p.start, p.end] : null, this.setSchema(), this.anchors._cstAliases = [], q(this, m), this.anchors.resolveNodes(), this.options.prettyErrors) {
                  for (let L of this.errors)
                    L instanceof e.YAMLError && L.makePretty();
                  for (let L of this.warnings)
                    L instanceof e.YAMLError && L.makePretty();
                }
                return this;
              }
              listNonDefaultTags() {
                return C(this.contents).filter((t) => t.indexOf(c.Schema.defaultPrefix) !== 0);
              }
              setTagPrefix(t, s) {
                if (t[0] !== "!" || t[t.length - 1] !== "!")
                  throw new Error("Handle must start and end with !");
                if (s) {
                  let a2 = this.tagPrefixes.find((m) => m.handle === t);
                  a2 ? a2.prefix = s : this.tagPrefixes.push({ handle: t, prefix: s });
                } else
                  this.tagPrefixes = this.tagPrefixes.filter((a2) => a2.handle !== t);
              }
              toJSON(t, s) {
                let { keepBlobsInJSON: a2, mapAsMap: m, maxAliasCount: g } = this.options, u = a2 && (typeof t != "string" || !(this.contents instanceof r.Scalar)), p = { doc: this, indentStep: "  ", keep: u, mapAsMap: u && !!m, maxAliasCount: g, stringify: M }, L = Object.keys(this.anchors.map);
                L.length > 0 && (p.anchors = new Map(L.map(($) => [this.anchors.map[$], { alias: [], aliasCount: 0, count: 1 }])));
                let k = r.toJSON(this.contents, t, p);
                if (typeof s == "function" && p.anchors)
                  for (let { count: $, res: K } of p.anchors.values())
                    s(K, $);
                return k;
              }
              toString() {
                if (this.errors.length > 0)
                  throw new Error("Document with errors cannot be stringified");
                let t = this.options.indent;
                if (!Number.isInteger(t) || t <= 0) {
                  let L = JSON.stringify(t);
                  throw new Error(`"indent" option must be a positive integer, not ${L}`);
                }
                this.setSchema();
                let s = [], a2 = false;
                if (this.version) {
                  let L = "%YAML 1.2";
                  this.schema.name === "yaml-1.1" && (this.version === "1.0" ? L = "%YAML:1.0" : this.version === "1.1" && (L = "%YAML 1.1")), s.push(L), a2 = true;
                }
                let m = this.listNonDefaultTags();
                this.tagPrefixes.forEach((L) => {
                  let { handle: k, prefix: $ } = L;
                  m.some((K) => K.indexOf($) === 0) && (s.push(`%TAG ${k} ${$}`), a2 = true);
                }), (a2 || this.directivesEndMarker) && s.push("---"), this.commentBefore && ((a2 || !this.directivesEndMarker) && s.unshift(""), s.unshift(this.commentBefore.replace(/^/gm, "#")));
                let g = { anchors: /* @__PURE__ */ Object.create(null), doc: this, indent: "", indentStep: " ".repeat(t), stringify: M }, u = false, p = null;
                if (this.contents) {
                  this.contents instanceof r.Node && (this.contents.spaceBefore && (a2 || this.directivesEndMarker) && s.push(""), this.contents.commentBefore && s.push(this.contents.commentBefore.replace(/^/gm, "#")), g.forceBlockIndent = !!this.comment, p = this.contents.comment);
                  let L = p ? null : () => u = true, k = M(this.contents, g, () => p = null, L);
                  s.push(r.addComment(k, "", p));
                } else
                  this.contents !== void 0 && s.push(M(this.contents, g));
                return this.comment && ((!u || p) && s[s.length - 1] !== "" && s.push(""), s.push(this.comment.replace(/^/gm, "#"))), s.join(`
`) + `
`;
              }
            };
            e._defineProperty(i, "defaults", y), n.Document = i, n.defaultOptions = h, n.scalarOptions = d;
          } }), Hr = D({ "node_modules/yaml/dist/index.js"(n) {
            "use strict";
            Y();
            var e = Jr(), r = xr(), c = it(), h = Me(), d = st();
            ke();
            function y(C) {
              let q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, R = arguments.length > 2 ? arguments[2] : void 0;
              R === void 0 && typeof q == "string" && (R = q, q = true);
              let B = Object.assign({}, r.Document.defaults[r.defaultOptions.version], r.defaultOptions);
              return new c.Schema(B).createNode(C, q, R);
            }
            var E = class extends r.Document {
              constructor(C) {
                super(Object.assign({}, r.defaultOptions, C));
              }
            };
            function I(C, q) {
              let R = [], B;
              for (let U of e.parse(C)) {
                let f2 = new E(q);
                f2.parse(U, B), R.push(f2), B = f2;
              }
              return R;
            }
            function S(C, q) {
              let R = e.parse(C), B = new E(q).parse(R[0]);
              if (R.length > 1) {
                let U = "Source contains multiple documents; please use YAML.parseAllDocuments()";
                B.errors.unshift(new h.YAMLSemanticError(R[1], U));
              }
              return B;
            }
            function M(C, q) {
              let R = S(C, q);
              if (R.warnings.forEach((B) => d.warn(B)), R.errors.length > 0)
                throw R.errors[0];
              return R.toJSON();
            }
            function T(C, q) {
              let R = new E(q);
              return R.contents = C, String(R);
            }
            var P = { createNode: y, defaultOptions: r.defaultOptions, Document: E, parse: M, parseAllDocuments: I, parseCST: e.parse, parseDocument: S, scalarOptions: r.scalarOptions, stringify: T };
            n.YAML = P;
          } }), Ue = D({ "node_modules/yaml/index.js"(n, e) {
            Y(), e.exports = Hr().YAML;
          } }), Gr = D({ "node_modules/yaml/dist/util.js"(n) {
            "use strict";
            Y();
            var e = ke(), r = Me();
            n.findPair = e.findPair, n.parseMap = e.resolveMap, n.parseSeq = e.resolveSeq, n.stringifyNumber = e.stringifyNumber, n.stringifyString = e.stringifyString, n.toJSON = e.toJSON, n.Type = r.Type, n.YAMLError = r.YAMLError, n.YAMLReferenceError = r.YAMLReferenceError, n.YAMLSemanticError = r.YAMLSemanticError, n.YAMLSyntaxError = r.YAMLSyntaxError, n.YAMLWarning = r.YAMLWarning;
          } }), zr = D({ "node_modules/yaml/util.js"(n) {
            Y();
            var e = Gr();
            n.findPair = e.findPair, n.toJSON = e.toJSON, n.parseMap = e.parseMap, n.parseSeq = e.parseSeq, n.stringifyNumber = e.stringifyNumber, n.stringifyString = e.stringifyString, n.Type = e.Type, n.YAMLError = e.YAMLError, n.YAMLReferenceError = e.YAMLReferenceError, n.YAMLSemanticError = e.YAMLSemanticError, n.YAMLSyntaxError = e.YAMLSyntaxError, n.YAMLWarning = e.YAMLWarning;
          } }), Zr = D({ "node_modules/yaml-unist-parser/lib/yaml.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Ue();
            n.Document = e.Document;
            var r = Ue();
            n.parseCST = r.parseCST;
            var c = zr();
            n.YAMLError = c.YAMLError, n.YAMLSyntaxError = c.YAMLSyntaxError, n.YAMLSemanticError = c.YAMLSemanticError;
          } }), Xr = D({ "node_modules/yaml-unist-parser/lib/parse.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = Kt(), r = xt(), c = Ht(), h = Gt(), d = Br(), y = He(), E = Yr(), I = Fr(), S = Wr(), M = Vr(), T = Qr(), P = Kr(), C = Zr();
            function q(R) {
              var B = C.parseCST(R);
              M.addOrigRange(B);
              for (var U = B.map(function(k) {
                return new C.Document({ merge: false, keepCstNodes: true }).parse(k);
              }), f2 = new e.default(R), i = [], t = { text: R, locator: f2, comments: i, transformOffset: function(k) {
                return I.transformOffset(k, t);
              }, transformRange: function(k) {
                return S.transformRange(k, t);
              }, transformNode: function(k) {
                return d.transformNode(k, t);
              }, transformContent: function(k) {
                return y.transformContent(k, t);
              } }, s = 0, a2 = U; s < a2.length; s++)
                for (var m = a2[s], g = 0, u = m.errors; g < u.length; g++) {
                  var p = u[g];
                  if (!(p instanceof C.YAMLSemanticError && p.message === 'Map keys must be unique; "<<" is repeated'))
                    throw E.transformError(p, t);
                }
              U.forEach(function(k) {
                return h.removeCstBlankLine(k.cstNode);
              });
              var L = c.createRoot(t.transformRange({ origStart: 0, origEnd: t.text.length }), U.map(t.transformNode), i);
              return r.attachComments(L), P.updatePositions(L), T.removeFakeNodes(L), L;
            }
            n.parse = q;
          } }), en = D({ "node_modules/yaml-unist-parser/lib/index.js"(n) {
            "use strict";
            Y(), n.__esModule = true;
            var e = (ie(), se(te));
            e.__exportStar(Xr(), n);
          } });
          Y();
          var tn = Mt(), { hasPragma: rn } = Ot(), { locStart: nn, locEnd: sn } = Lt();
          function an(n) {
            let { parse: e } = en();
            try {
              let r = e(n);
              return delete r.comments, r;
            } catch (r) {
              throw r != null && r.position ? tn(r.message, r.position) : r;
            }
          }
          var on = { astFormat: "yaml", parse: an, hasPragma: rn, locStart: nn, locEnd: sn };
          at.exports = { parsers: { yaml: on } };
        });
        return ln();
      });
    }
  });

  // node_modules/monaco-editor/esm/vs/base/common/errors.js
  var ErrorHandler = class {
    constructor() {
      this.listeners = [];
      this.unexpectedErrorHandler = function(e) {
        setTimeout(() => {
          if (e.stack) {
            if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {
              throw new ErrorNoTelemetry(e.message + "\n\n" + e.stack);
            }
            throw new Error(e.message + "\n\n" + e.stack);
          }
          throw e;
        }, 0);
      };
    }
    emit(e) {
      this.listeners.forEach((listener) => {
        listener(e);
      });
    }
    onUnexpectedError(e) {
      this.unexpectedErrorHandler(e);
      this.emit(e);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e) {
      this.unexpectedErrorHandler(e);
    }
  };
  var errorHandler = new ErrorHandler();
  function onUnexpectedError(e) {
    if (!isCancellationError(e)) {
      errorHandler.onUnexpectedError(e);
    }
    return void 0;
  }
  function transformErrorForSerialization(error) {
    if (error instanceof Error) {
      const { name, message } = error;
      const stack = error.stacktrace || error.stack;
      return {
        $isError: true,
        name,
        message,
        stack,
        noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)
      };
    }
    return error;
  }
  var canceledName = "Canceled";
  function isCancellationError(error) {
    if (error instanceof CancellationError) {
      return true;
    }
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  var CancellationError = class extends Error {
    constructor() {
      super(canceledName);
      this.name = this.message;
    }
  };
  var ErrorNoTelemetry = class _ErrorNoTelemetry extends Error {
    constructor(msg) {
      super(msg);
      this.name = "CodeExpectedError";
    }
    static fromError(err) {
      if (err instanceof _ErrorNoTelemetry) {
        return err;
      }
      const result = new _ErrorNoTelemetry();
      result.message = err.message;
      result.stack = err.stack;
      return result;
    }
    static isErrorNoTelemetry(err) {
      return err.name === "CodeExpectedError";
    }
  };
  var BugIndicatingError = class _BugIndicatingError extends Error {
    constructor(message) {
      super(message || "An unexpected bug occurred.");
      Object.setPrototypeOf(this, _BugIndicatingError.prototype);
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/functional.js
  function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function() {
      if (didCall) {
        return result;
      }
      didCall = true;
      result = fn.apply(_this, arguments);
      return result;
    };
  }

  // node_modules/monaco-editor/esm/vs/base/common/iterator.js
  var Iterable;
  (function(Iterable2) {
    function is(thing) {
      return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
    }
    Iterable2.is = is;
    const _empty2 = Object.freeze([]);
    function empty() {
      return _empty2;
    }
    Iterable2.empty = empty;
    function* single(element) {
      yield element;
    }
    Iterable2.single = single;
    function wrap(iterableOrElement) {
      if (is(iterableOrElement)) {
        return iterableOrElement;
      } else {
        return single(iterableOrElement);
      }
    }
    Iterable2.wrap = wrap;
    function from(iterable) {
      return iterable || _empty2;
    }
    Iterable2.from = from;
    function isEmpty2(iterable) {
      return !iterable || iterable[Symbol.iterator]().next().done === true;
    }
    Iterable2.isEmpty = isEmpty2;
    function first(iterable) {
      return iterable[Symbol.iterator]().next().value;
    }
    Iterable2.first = first;
    function some(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return true;
        }
      }
      return false;
    }
    Iterable2.some = some;
    function find(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          return element;
        }
      }
      return void 0;
    }
    Iterable2.find = find;
    function* filter(iterable, predicate) {
      for (const element of iterable) {
        if (predicate(element)) {
          yield element;
        }
      }
    }
    Iterable2.filter = filter;
    function* map2(iterable, fn) {
      let index = 0;
      for (const element of iterable) {
        yield fn(element, index++);
      }
    }
    Iterable2.map = map2;
    function* concat(...iterables) {
      for (const iterable of iterables) {
        for (const element of iterable) {
          yield element;
        }
      }
    }
    Iterable2.concat = concat;
    function reduce(iterable, reducer, initialValue) {
      let value = initialValue;
      for (const element of iterable) {
        value = reducer(value, element);
      }
      return value;
    }
    Iterable2.reduce = reduce;
    function* slice(arr, from2, to = arr.length) {
      if (from2 < 0) {
        from2 += arr.length;
      }
      if (to < 0) {
        to += arr.length;
      } else if (to > arr.length) {
        to = arr.length;
      }
      for (; from2 < to; from2++) {
        yield arr[from2];
      }
    }
    Iterable2.slice = slice;
    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
      const consumed = [];
      if (atMost === 0) {
        return [consumed, iterable];
      }
      const iterator = iterable[Symbol.iterator]();
      for (let i = 0; i < atMost; i++) {
        const next = iterator.next();
        if (next.done) {
          return [consumed, Iterable2.empty()];
        }
        consumed.push(next.value);
      }
      return [consumed, { [Symbol.iterator]() {
        return iterator;
      } }];
    }
    Iterable2.consume = consume;
  })(Iterable || (Iterable = {}));

  // node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
  var TRACK_DISPOSABLES = false;
  var disposableTracker = null;
  function setDisposableTracker(tracker) {
    disposableTracker = tracker;
  }
  if (TRACK_DISPOSABLES) {
    const __is_disposable_tracked__ = "__is_disposable_tracked__";
    setDisposableTracker(new class {
      trackDisposable(x) {
        const stack = new Error("Potentially leaked disposable").stack;
        setTimeout(() => {
          if (!x[__is_disposable_tracked__]) {
            console.log(stack);
          }
        }, 3e3);
      }
      setParent(child, parent) {
        if (child && child !== Disposable.None) {
          try {
            child[__is_disposable_tracked__] = true;
          } catch (_a3) {
          }
        }
      }
      markAsDisposed(disposable) {
        if (disposable && disposable !== Disposable.None) {
          try {
            disposable[__is_disposable_tracked__] = true;
          } catch (_a3) {
          }
        }
      }
      markAsSingleton(disposable) {
      }
    }());
  }
  function trackDisposable(x) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);
    return x;
  }
  function markAsDisposed(disposable) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);
  }
  function setParentOfDisposable(child, parent) {
    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);
  }
  function setParentOfDisposables(children, parent) {
    if (!disposableTracker) {
      return;
    }
    for (const child of children) {
      disposableTracker.setParent(child, parent);
    }
  }
  function dispose(arg) {
    if (Iterable.is(arg)) {
      const errors = [];
      for (const d of arg) {
        if (d) {
          try {
            d.dispose();
          } catch (e) {
            errors.push(e);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      } else if (errors.length > 1) {
        throw new AggregateError(errors, "Encountered errors while disposing of store");
      }
      return Array.isArray(arg) ? [] : arg;
    } else if (arg) {
      arg.dispose();
      return arg;
    }
  }
  function combinedDisposable(...disposables) {
    const parent = toDisposable(() => dispose(disposables));
    setParentOfDisposables(disposables, parent);
    return parent;
  }
  function toDisposable(fn) {
    const self2 = trackDisposable({
      dispose: once(() => {
        markAsDisposed(self2);
        fn();
      })
    });
    return self2;
  }
  var DisposableStore = class _DisposableStore {
    constructor() {
      this._toDispose = /* @__PURE__ */ new Set();
      this._isDisposed = false;
      trackDisposable(this);
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
      if (this._isDisposed) {
        return;
      }
      markAsDisposed(this);
      this._isDisposed = true;
      this.clear();
    }
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed() {
      return this._isDisposed;
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
      if (this._toDispose.size === 0) {
        return;
      }
      try {
        dispose(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
    }
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add(o) {
      if (!o) {
        return o;
      }
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      setParentOfDisposable(o, this);
      if (this._isDisposed) {
        if (!_DisposableStore.DISABLE_DISPOSED_WARNING) {
          console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack);
        }
      } else {
        this._toDispose.add(o);
      }
      return o;
    }
  };
  DisposableStore.DISABLE_DISPOSED_WARNING = false;
  var Disposable = class {
    constructor() {
      this._store = new DisposableStore();
      trackDisposable(this);
      setParentOfDisposable(this._store, this);
    }
    dispose() {
      markAsDisposed(this);
      this._store.dispose();
    }
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    _register(o) {
      if (o === this) {
        throw new Error("Cannot register a disposable on itself!");
      }
      return this._store.add(o);
    }
  };
  Disposable.None = Object.freeze({ dispose() {
  } });
  var DisposableMap = class {
    constructor() {
      this._store = /* @__PURE__ */ new Map();
      this._isDisposed = false;
      trackDisposable(this);
    }
    /**
     * Disposes of all stored values and mark this object as disposed.
     *
     * Trying to use this object after it has been disposed of is an error.
     */
    dispose() {
      markAsDisposed(this);
      this._isDisposed = true;
      this.clearAndDisposeAll();
    }
    /**
     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
     */
    clearAndDisposeAll() {
      if (!this._store.size) {
        return;
      }
      try {
        dispose(this._store.values());
      } finally {
        this._store.clear();
      }
    }
    get(key) {
      return this._store.get(key);
    }
    set(key, value, skipDisposeOnOverwrite = false) {
      var _a3;
      if (this._isDisposed) {
        console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack);
      }
      if (!skipDisposeOnOverwrite) {
        (_a3 = this._store.get(key)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
      }
      this._store.set(key, value);
    }
    /**
     * Delete the value stored for `key` from this map and also dispose of it.
     */
    deleteAndDispose(key) {
      var _a3;
      (_a3 = this._store.get(key)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
      this._store.delete(key);
    }
    [Symbol.iterator]() {
      return this._store[Symbol.iterator]();
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/linkedList.js
  var Node = class _Node {
    constructor(element) {
      this.element = element;
      this.next = _Node.Undefined;
      this.prev = _Node.Undefined;
    }
  };
  Node.Undefined = new Node(void 0);
  var LinkedList = class {
    constructor() {
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    get size() {
      return this._size;
    }
    isEmpty() {
      return this._first === Node.Undefined;
    }
    clear() {
      let node = this._first;
      while (node !== Node.Undefined) {
        const next = node.next;
        node.prev = Node.Undefined;
        node.next = Node.Undefined;
        node = next;
      }
      this._first = Node.Undefined;
      this._last = Node.Undefined;
      this._size = 0;
    }
    unshift(element) {
      return this._insert(element, false);
    }
    push(element) {
      return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
      const newNode = new Node(element);
      if (this._first === Node.Undefined) {
        this._first = newNode;
        this._last = newNode;
      } else if (atTheEnd) {
        const oldLast = this._last;
        this._last = newNode;
        newNode.prev = oldLast;
        oldLast.next = newNode;
      } else {
        const oldFirst = this._first;
        this._first = newNode;
        newNode.next = oldFirst;
        oldFirst.prev = newNode;
      }
      this._size += 1;
      let didRemove = false;
      return () => {
        if (!didRemove) {
          didRemove = true;
          this._remove(newNode);
        }
      };
    }
    shift() {
      if (this._first === Node.Undefined) {
        return void 0;
      } else {
        const res = this._first.element;
        this._remove(this._first);
        return res;
      }
    }
    pop() {
      if (this._last === Node.Undefined) {
        return void 0;
      } else {
        const res = this._last.element;
        this._remove(this._last);
        return res;
      }
    }
    _remove(node) {
      if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
        const anchor = node.prev;
        anchor.next = node.next;
        node.next.prev = anchor;
      } else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
      } else if (node.next === Node.Undefined) {
        this._last = this._last.prev;
        this._last.next = Node.Undefined;
      } else if (node.prev === Node.Undefined) {
        this._first = this._first.next;
        this._first.prev = Node.Undefined;
      }
      this._size -= 1;
    }
    *[Symbol.iterator]() {
      let node = this._first;
      while (node !== Node.Undefined) {
        yield node.element;
        node = node.next;
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
  var hasPerformanceNow = globalThis.performance && typeof globalThis.performance.now === "function";
  var StopWatch = class _StopWatch {
    static create(highResolution) {
      return new _StopWatch(highResolution);
    }
    constructor(highResolution) {
      this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);
      this._startTime = this._now();
      this._stopTime = -1;
    }
    stop() {
      this._stopTime = this._now();
    }
    elapsed() {
      if (this._stopTime !== -1) {
        return this._stopTime - this._startTime;
      }
      return this._now() - this._startTime;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/event.js
  var _enableDisposeWithListenerWarning = false;
  var _enableSnapshotPotentialLeakWarning = false;
  var Event;
  (function(Event2) {
    Event2.None = () => Disposable.None;
    function _addLeakageTraceLogic(options) {
      if (_enableSnapshotPotentialLeakWarning) {
        const { onDidAddListener: origListenerDidAdd } = options;
        const stack = Stacktrace.create();
        let count = 0;
        options.onDidAddListener = () => {
          if (++count === 2) {
            console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here");
            stack.print();
          }
          origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();
        };
      }
    }
    function defer(event, disposable) {
      return debounce(event, () => void 0, 0, void 0, true, void 0, disposable);
    }
    Event2.defer = defer;
    function once3(event) {
      return (listener, thisArgs = null, disposables) => {
        let didFire = false;
        let result = void 0;
        result = event((e) => {
          if (didFire) {
            return;
          } else if (result) {
            result.dispose();
          } else {
            didFire = true;
          }
          return listener.call(thisArgs, e);
        }, null, disposables);
        if (didFire) {
          result.dispose();
        }
        return result;
      };
    }
    Event2.once = once3;
    function map2(event, map3, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map3(i)), null, disposables), disposable);
    }
    Event2.map = map2;
    function forEach(event, each, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((i) => {
        each(i);
        listener.call(thisArgs, i);
      }, null, disposables), disposable);
    }
    Event2.forEach = forEach;
    function filter(event, filter2, disposable) {
      return snapshot((listener, thisArgs = null, disposables) => event((e) => filter2(e) && listener.call(thisArgs, e), null, disposables), disposable);
    }
    Event2.filter = filter;
    function signal(event) {
      return event;
    }
    Event2.signal = signal;
    function any(...events) {
      return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
    }
    Event2.any = any;
    function reduce(event, merge, initial, disposable) {
      let output = initial;
      return map2(event, (e) => {
        output = merge(output, e);
        return output;
      }, disposable);
    }
    Event2.reduce = reduce;
    function snapshot(event, disposable) {
      let listener;
      const options = {
        onWillAddFirstListener() {
          listener = event(emitter.fire, emitter);
        },
        onDidRemoveLastListener() {
          listener === null || listener === void 0 ? void 0 : listener.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {
      let subscription;
      let output = void 0;
      let handle = void 0;
      let numDebouncedCalls = 0;
      let doFire;
      const options = {
        leakWarningThreshold,
        onWillAddFirstListener() {
          subscription = event((cur) => {
            numDebouncedCalls++;
            output = merge(output, cur);
            if (leading && !handle) {
              emitter.fire(output);
              output = void 0;
            }
            doFire = () => {
              const _output = output;
              output = void 0;
              handle = void 0;
              if (!leading || numDebouncedCalls > 1) {
                emitter.fire(_output);
              }
              numDebouncedCalls = 0;
            };
            if (typeof delay === "number") {
              clearTimeout(handle);
              handle = setTimeout(doFire, delay);
            } else {
              if (handle === void 0) {
                handle = 0;
                queueMicrotask(doFire);
              }
            }
          });
        },
        onWillRemoveListener() {
          if (flushOnListenerRemove && numDebouncedCalls > 0) {
            doFire === null || doFire === void 0 ? void 0 : doFire();
          }
        },
        onDidRemoveLastListener() {
          doFire = void 0;
          subscription.dispose();
        }
      };
      if (!disposable) {
        _addLeakageTraceLogic(options);
      }
      const emitter = new Emitter(options);
      disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);
      return emitter.event;
    }
    Event2.debounce = debounce;
    function accumulate(event, delay = 0, disposable) {
      return Event2.debounce(event, (last, e) => {
        if (!last) {
          return [e];
        }
        last.push(e);
        return last;
      }, delay, void 0, true, void 0, disposable);
    }
    Event2.accumulate = accumulate;
    function latch(event, equals3 = (a2, b) => a2 === b, disposable) {
      let firstCall = true;
      let cache;
      return filter(event, (value) => {
        const shouldEmit = firstCall || !equals3(value, cache);
        firstCall = false;
        cache = value;
        return shouldEmit;
      }, disposable);
    }
    Event2.latch = latch;
    function split(event, isT, disposable) {
      return [
        Event2.filter(event, isT, disposable),
        Event2.filter(event, (e) => !isT(e), disposable)
      ];
    }
    Event2.split = split;
    function buffer(event, flushAfterTimeout = false, _buffer = []) {
      let buffer2 = _buffer.slice();
      let listener = event((e) => {
        if (buffer2) {
          buffer2.push(e);
        } else {
          emitter.fire(e);
        }
      });
      const flush = () => {
        buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.forEach((e) => emitter.fire(e));
        buffer2 = null;
      };
      const emitter = new Emitter({
        onWillAddFirstListener() {
          if (!listener) {
            listener = event((e) => emitter.fire(e));
          }
        },
        onDidAddFirstListener() {
          if (buffer2) {
            if (flushAfterTimeout) {
              setTimeout(flush);
            } else {
              flush();
            }
          }
        },
        onDidRemoveLastListener() {
          if (listener) {
            listener.dispose();
          }
          listener = null;
        }
      });
      return emitter.event;
    }
    Event2.buffer = buffer;
    class ChainableEvent {
      constructor(event) {
        this.event = event;
        this.disposables = new DisposableStore();
      }
      /** @see {@link Event.map} */
      map(fn) {
        return new ChainableEvent(map2(this.event, fn, this.disposables));
      }
      /** @see {@link Event.forEach} */
      forEach(fn) {
        return new ChainableEvent(forEach(this.event, fn, this.disposables));
      }
      filter(fn) {
        return new ChainableEvent(filter(this.event, fn, this.disposables));
      }
      /** @see {@link Event.reduce} */
      reduce(merge, initial) {
        return new ChainableEvent(reduce(this.event, merge, initial, this.disposables));
      }
      /** @see {@link Event.reduce} */
      latch() {
        return new ChainableEvent(latch(this.event, void 0, this.disposables));
      }
      debounce(merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold) {
        return new ChainableEvent(debounce(this.event, merge, delay, leading, flushOnListenerRemove, leakWarningThreshold, this.disposables));
      }
      /**
       * Attach a listener to the event.
       */
      on(listener, thisArgs, disposables) {
        return this.event(listener, thisArgs, disposables);
      }
      /** @see {@link Event.once} */
      once(listener, thisArgs, disposables) {
        return once3(this.event)(listener, thisArgs, disposables);
      }
      dispose() {
        this.disposables.dispose();
      }
    }
    function chain(event) {
      return new ChainableEvent(event);
    }
    Event2.chain = chain;
    function fromNodeEventEmitter(emitter, eventName, map3 = (id) => id) {
      const fn = (...args) => result.fire(map3(...args));
      const onFirstListenerAdd = () => emitter.on(eventName, fn);
      const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map3 = (id) => id) {
      const fn = (...args) => result.fire(map3(...args));
      const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
      const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
      const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });
      return result.event;
    }
    Event2.fromDOMEventEmitter = fromDOMEventEmitter;
    function toPromise(event) {
      return new Promise((resolve3) => once3(event)(resolve3));
    }
    Event2.toPromise = toPromise;
    function runAndSubscribe(event, handler) {
      handler(void 0);
      return event((e) => handler(e));
    }
    Event2.runAndSubscribe = runAndSubscribe;
    function runAndSubscribeWithStore(event, handler) {
      let store = null;
      function run(e) {
        store === null || store === void 0 ? void 0 : store.dispose();
        store = new DisposableStore();
        handler(e, store);
      }
      run(void 0);
      const disposable = event((e) => run(e));
      return toDisposable(() => {
        disposable.dispose();
        store === null || store === void 0 ? void 0 : store.dispose();
      });
    }
    Event2.runAndSubscribeWithStore = runAndSubscribeWithStore;
    class EmitterObserver {
      constructor(_observable, store) {
        this._observable = _observable;
        this._counter = 0;
        this._hasChanged = false;
        const options = {
          onWillAddFirstListener: () => {
            _observable.addObserver(this);
          },
          onDidRemoveLastListener: () => {
            _observable.removeObserver(this);
          }
        };
        if (!store) {
          _addLeakageTraceLogic(options);
        }
        this.emitter = new Emitter(options);
        if (store) {
          store.add(this.emitter);
        }
      }
      beginUpdate(_observable) {
        this._counter++;
      }
      handlePossibleChange(_observable) {
      }
      handleChange(_observable, _change) {
        this._hasChanged = true;
      }
      endUpdate(_observable) {
        this._counter--;
        if (this._counter === 0) {
          this._observable.reportChanges();
          if (this._hasChanged) {
            this._hasChanged = false;
            this.emitter.fire(this._observable.get());
          }
        }
      }
    }
    function fromObservable(obs, store) {
      const observer = new EmitterObserver(obs, store);
      return observer.emitter.event;
    }
    Event2.fromObservable = fromObservable;
    function fromObservableLight(observable) {
      return (listener) => {
        let count = 0;
        let didChange = false;
        const observer = {
          beginUpdate() {
            count++;
          },
          endUpdate() {
            count--;
            if (count === 0) {
              observable.reportChanges();
              if (didChange) {
                didChange = false;
                listener();
              }
            }
          },
          handlePossibleChange() {
          },
          handleChange() {
            didChange = true;
          }
        };
        observable.addObserver(observer);
        return {
          dispose() {
            observable.removeObserver(observer);
          }
        };
      };
    }
    Event2.fromObservableLight = fromObservableLight;
  })(Event || (Event = {}));
  var EventProfiling = class _EventProfiling {
    constructor(name) {
      this.listenerCount = 0;
      this.invocationCount = 0;
      this.elapsedOverall = 0;
      this.durations = [];
      this.name = `${name}_${_EventProfiling._idPool++}`;
      _EventProfiling.all.add(this);
    }
    start(listenerCount) {
      this._stopWatch = new StopWatch();
      this.listenerCount = listenerCount;
    }
    stop() {
      if (this._stopWatch) {
        const elapsed = this._stopWatch.elapsed();
        this.durations.push(elapsed);
        this.elapsedOverall += elapsed;
        this.invocationCount += 1;
        this._stopWatch = void 0;
      }
    }
  };
  EventProfiling.all = /* @__PURE__ */ new Set();
  EventProfiling._idPool = 0;
  var _globalLeakWarningThreshold = -1;
  var LeakageMonitor = class {
    constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {
      this.threshold = threshold;
      this.name = name;
      this._warnCountdown = 0;
    }
    dispose() {
      var _a3;
      (_a3 = this._stacks) === null || _a3 === void 0 ? void 0 : _a3.clear();
    }
    check(stack, listenerCount) {
      const threshold = this.threshold;
      if (threshold <= 0 || listenerCount < threshold) {
        return void 0;
      }
      if (!this._stacks) {
        this._stacks = /* @__PURE__ */ new Map();
      }
      const count = this._stacks.get(stack.value) || 0;
      this._stacks.set(stack.value, count + 1);
      this._warnCountdown -= 1;
      if (this._warnCountdown <= 0) {
        this._warnCountdown = threshold * 0.5;
        let topStack;
        let topCount = 0;
        for (const [stack2, count2] of this._stacks) {
          if (!topStack || topCount < count2) {
            topStack = stack2;
            topCount = count2;
          }
        }
        console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
        console.warn(topStack);
      }
      return () => {
        const count2 = this._stacks.get(stack.value) || 0;
        this._stacks.set(stack.value, count2 - 1);
      };
    }
  };
  var Stacktrace = class _Stacktrace {
    static create() {
      var _a3;
      return new _Stacktrace((_a3 = new Error().stack) !== null && _a3 !== void 0 ? _a3 : "");
    }
    constructor(value) {
      this.value = value;
    }
    print() {
      console.warn(this.value.split("\n").slice(2).join("\n"));
    }
  };
  var UniqueContainer = class {
    constructor(value) {
      this.value = value;
    }
  };
  var compactionThreshold = 2;
  var forEachListener = (listeners, fn) => {
    if (listeners instanceof UniqueContainer) {
      fn(listeners);
    } else {
      for (let i = 0; i < listeners.length; i++) {
        const l = listeners[i];
        if (l) {
          fn(l);
        }
      }
    }
  };
  var Emitter = class {
    constructor(options) {
      var _a3, _b, _c, _d, _e;
      this._size = 0;
      this._options = options;
      this._leakageMon = _globalLeakWarningThreshold > 0 || ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.leakWarningThreshold) ? new LeakageMonitor((_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.leakWarningThreshold) !== null && _c !== void 0 ? _c : _globalLeakWarningThreshold) : void 0;
      this._perfMon = ((_d = this._options) === null || _d === void 0 ? void 0 : _d._profName) ? new EventProfiling(this._options._profName) : void 0;
      this._deliveryQueue = (_e = this._options) === null || _e === void 0 ? void 0 : _e.deliveryQueue;
    }
    dispose() {
      var _a3, _b, _c, _d;
      if (!this._disposed) {
        this._disposed = true;
        if (((_a3 = this._deliveryQueue) === null || _a3 === void 0 ? void 0 : _a3.current) === this) {
          this._deliveryQueue.reset();
        }
        if (this._listeners) {
          if (_enableDisposeWithListenerWarning) {
            const listeners = this._listeners;
            queueMicrotask(() => {
              forEachListener(listeners, (l) => {
                var _a4;
                return (_a4 = l.stack) === null || _a4 === void 0 ? void 0 : _a4.print();
              });
            });
          }
          this._listeners = void 0;
          this._size = 0;
        }
        (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);
        (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();
      }
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
      var _a3;
      (_a3 = this._event) !== null && _a3 !== void 0 ? _a3 : this._event = (callback, thisArgs, disposables) => {
        var _a4, _b, _c, _d, _e;
        if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {
          console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
          return Disposable.None;
        }
        if (this._disposed) {
          return Disposable.None;
        }
        if (thisArgs) {
          callback = callback.bind(thisArgs);
        }
        const contained = new UniqueContainer(callback);
        let removeMonitor;
        let stack;
        if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
          contained.stack = Stacktrace.create();
          removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);
        }
        if (_enableDisposeWithListenerWarning) {
          contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();
        }
        if (!this._listeners) {
          (_b = (_a4 = this._options) === null || _a4 === void 0 ? void 0 : _a4.onWillAddFirstListener) === null || _b === void 0 ? void 0 : _b.call(_a4, this);
          this._listeners = contained;
          (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        } else if (this._listeners instanceof UniqueContainer) {
          (_e = this._deliveryQueue) !== null && _e !== void 0 ? _e : this._deliveryQueue = new EventDeliveryQueuePrivate();
          this._listeners = [this._listeners, contained];
        } else {
          this._listeners.push(contained);
        }
        this._size++;
        const result = toDisposable(() => {
          removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();
          this._removeListener(contained);
        });
        if (disposables instanceof DisposableStore) {
          disposables.add(result);
        } else if (Array.isArray(disposables)) {
          disposables.push(result);
        }
        return result;
      };
      return this._event;
    }
    _removeListener(listener) {
      var _a3, _b, _c, _d;
      (_b = (_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a3, this);
      if (!this._listeners) {
        return;
      }
      if (this._size === 1) {
        this._listeners = void 0;
        (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this._size = 0;
        return;
      }
      const listeners = this._listeners;
      const index = listeners.indexOf(listener);
      if (index === -1) {
        console.log("disposed?", this._disposed);
        console.log("size?", this._size);
        console.log("arr?", JSON.stringify(this._listeners));
        throw new Error("Attempted to dispose unknown listener");
      }
      this._size--;
      listeners[index] = void 0;
      const adjustDeliveryQueue = this._deliveryQueue.current === this;
      if (this._size * compactionThreshold <= listeners.length) {
        let n = 0;
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i]) {
            listeners[n++] = listeners[i];
          } else if (adjustDeliveryQueue) {
            this._deliveryQueue.end--;
            if (n < this._deliveryQueue.i) {
              this._deliveryQueue.i--;
            }
          }
        }
        listeners.length = n;
      }
    }
    _deliver(listener, value) {
      var _a3;
      if (!listener) {
        return;
      }
      const errorHandler2 = ((_a3 = this._options) === null || _a3 === void 0 ? void 0 : _a3.onListenerError) || onUnexpectedError;
      if (!errorHandler2) {
        listener.value(value);
        return;
      }
      try {
        listener.value(value);
      } catch (e) {
        errorHandler2(e);
      }
    }
    /** Delivers items in the queue. Assumes the queue is ready to go. */
    _deliverQueue(dq) {
      const listeners = dq.current._listeners;
      while (dq.i < dq.end) {
        this._deliver(listeners[dq.i++], dq.value);
      }
      dq.reset();
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
      var _a3, _b, _c, _d;
      if ((_a3 = this._deliveryQueue) === null || _a3 === void 0 ? void 0 : _a3.current) {
        this._deliverQueue(this._deliveryQueue);
        (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();
      }
      (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);
      if (!this._listeners) {
      } else if (this._listeners instanceof UniqueContainer) {
        this._deliver(this._listeners, event);
      } else {
        const dq = this._deliveryQueue;
        dq.enqueue(this, event, this._listeners.length);
        this._deliverQueue(dq);
      }
      (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();
    }
    hasListeners() {
      return this._size > 0;
    }
  };
  var EventDeliveryQueuePrivate = class {
    constructor() {
      this.i = -1;
      this.end = 0;
    }
    enqueue(emitter, value, end) {
      this.i = 0;
      this.end = end;
      this.current = emitter;
      this.value = value;
    }
    reset() {
      this.i = this.end;
      this.current = void 0;
      this.value = void 0;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/types.js
  function isString(str) {
    return typeof str === "string";
  }

  // node_modules/monaco-editor/esm/vs/base/common/objects.js
  function getAllPropertyNames(obj) {
    let res = [];
    let proto = Object.getPrototypeOf(obj);
    while (Object.prototype !== proto) {
      res = res.concat(Object.getOwnPropertyNames(proto));
      proto = Object.getPrototypeOf(proto);
    }
    return res;
  }
  function getAllMethodNames(obj) {
    const methods = [];
    for (const prop of getAllPropertyNames(obj)) {
      if (typeof obj[prop] === "function") {
        methods.push(prop);
      }
    }
    return methods;
  }
  function createProxyObject(methodNames, invoke) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }

  // node_modules/monaco-editor/esm/vs/nls.js
  var isPseudo = typeof document !== "undefined" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
  function _format(message, args) {
    let result;
    if (args.length === 0) {
      result = message;
    } else {
      result = message.replace(/\{(\d+)\}/g, (match, rest) => {
        const index = rest[0];
        const arg = args[index];
        let result2 = match;
        if (typeof arg === "string") {
          result2 = arg;
        } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
          result2 = String(arg);
        }
        return result2;
      });
    }
    if (isPseudo) {
      result = "\uFF3B" + result.replace(/[aouei]/g, "$&$&") + "\uFF3D";
    }
    return result;
  }
  function localize(data, message, ...args) {
    return _format(message, args);
  }
  function getConfiguredDefaultLocale(_) {
    return void 0;
  }

  // node_modules/monaco-editor/esm/vs/base/common/platform.js
  var _a;
  var LANGUAGE_DEFAULT = "en";
  var _isWindows = false;
  var _isMacintosh = false;
  var _isLinux = false;
  var _isLinuxSnap = false;
  var _isNative = false;
  var _isWeb = false;
  var _isElectron = false;
  var _isIOS = false;
  var _isCI = false;
  var _isMobile = false;
  var _locale = void 0;
  var _language = LANGUAGE_DEFAULT;
  var _platformLocale = LANGUAGE_DEFAULT;
  var _translationsConfigFile = void 0;
  var _userAgent = void 0;
  var globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
  var nodeProcess = void 0;
  if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
    nodeProcess = globals.vscode.process;
  } else if (typeof process !== "undefined") {
    nodeProcess = process;
  }
  var isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string";
  var isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
  if (typeof navigator === "object" && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf("Windows") >= 0;
    _isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
    _isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf("Linux") >= 0;
    _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf("Mobi")) >= 0;
    _isWeb = true;
    const configuredLocale = getConfiguredDefaultLocale(
      // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`
      // to ensure that the NLS AMD Loader plugin has been loaded and configured.
      // This is because the loader plugin decides what the default locale is based on
      // how it's able to resolve the strings.
      localize({ key: "ensureLoaderPluginIsLoaded", comment: ["{Locked}"] }, "_")
    );
    _locale = configuredLocale || LANGUAGE_DEFAULT;
    _language = _locale;
    _platformLocale = navigator.language;
  } else if (typeof nodeProcess === "object") {
    _isWindows = nodeProcess.platform === "win32";
    _isMacintosh = nodeProcess.platform === "darwin";
    _isLinux = nodeProcess.platform === "linux";
    _isLinuxSnap = _isLinux && !!nodeProcess.env["SNAP"] && !!nodeProcess.env["SNAP_REVISION"];
    _isElectron = isElectronProcess;
    _isCI = !!nodeProcess.env["CI"] || !!nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
    if (rawNlsConfig) {
      try {
        const nlsConfig = JSON.parse(rawNlsConfig);
        const resolved = nlsConfig.availableLanguages["*"];
        _locale = nlsConfig.locale;
        _platformLocale = nlsConfig.osLocale;
        _language = resolved ? resolved : LANGUAGE_DEFAULT;
        _translationsConfigFile = nlsConfig._translationsConfigFile;
      } catch (e) {
      }
    }
    _isNative = true;
  } else {
    console.error("Unable to resolve platform.");
  }
  var _platform = 0;
  if (_isMacintosh) {
    _platform = 1;
  } else if (_isWindows) {
    _platform = 3;
  } else if (_isLinux) {
    _platform = 2;
  }
  var isWindows = _isWindows;
  var isMacintosh = _isMacintosh;
  var isWebWorker = _isWeb && typeof globals.importScripts === "function";
  var userAgent = _userAgent;
  var setTimeout0IsFaster = typeof globals.postMessage === "function" && !globals.importScripts;
  var setTimeout0 = (() => {
    if (setTimeout0IsFaster) {
      const pending = [];
      globals.addEventListener("message", (e) => {
        if (e.data && e.data.vscodeScheduleAsyncWork) {
          for (let i = 0, len = pending.length; i < len; i++) {
            const candidate = pending[i];
            if (candidate.id === e.data.vscodeScheduleAsyncWork) {
              pending.splice(i, 1);
              candidate.callback();
              return;
            }
          }
        }
      });
      let lastId = 0;
      return (callback) => {
        const myId = ++lastId;
        pending.push({
          id: myId,
          callback
        });
        globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
      };
    }
    return (callback) => setTimeout(callback);
  })();
  var isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
  var isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
  var isSafari = !!(!isChrome && (userAgent && userAgent.indexOf("Safari") >= 0));
  var isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
  var isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

  // node_modules/monaco-editor/esm/vs/base/common/cache.js
  var LRUCachedFunction = class {
    constructor(fn) {
      this.fn = fn;
      this.lastCache = void 0;
      this.lastArgKey = void 0;
    }
    get(arg) {
      const key = JSON.stringify(arg);
      if (this.lastArgKey !== key) {
        this.lastArgKey = key;
        this.lastCache = this.fn(arg);
      }
      return this.lastCache;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/lazy.js
  var Lazy = class {
    constructor(executor) {
      this.executor = executor;
      this._didRun = false;
    }
    /**
     * Get the wrapped value.
     *
     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
     */
    get value() {
      if (!this._didRun) {
        try {
          this._value = this.executor();
        } catch (err) {
          this._error = err;
        } finally {
          this._didRun = true;
        }
      }
      if (this._error) {
        throw this._error;
      }
      return this._value;
    }
    /**
     * Get the wrapped value without forcing evaluation.
     */
    get rawValue() {
      return this._value;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/strings.js
  var _a2;
  function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
  }
  function splitLines(str) {
    return str.split(/\r\n|\r|\n/);
  }
  function firstNonWhitespaceIndex(str) {
    for (let i = 0, len = str.length; i < len; i++) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {
    for (let i = startIndex; i >= 0; i--) {
      const chCode = str.charCodeAt(i);
      if (chCode !== 32 && chCode !== 9) {
        return i;
      }
    }
    return -1;
  }
  function isUpperAsciiLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isHighSurrogate(charCode) {
    return 55296 <= charCode && charCode <= 56319;
  }
  function isLowSurrogate(charCode) {
    return 56320 <= charCode && charCode <= 57343;
  }
  function computeCodePoint(highSurrogate, lowSurrogate) {
    return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
  }
  function getNextCodePoint(str, len, offset) {
    const charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
      const nextCharCode = str.charCodeAt(offset + 1);
      if (isLowSurrogate(nextCharCode)) {
        return computeCodePoint(charCode, nextCharCode);
      }
    }
    return charCode;
  }
  var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
  function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
  }
  var UTF8_BOM_CHARACTER = String.fromCharCode(
    65279
    /* CharCode.UTF8_BOM */
  );
  var GraphemeBreakTree = class _GraphemeBreakTree {
    static getInstance() {
      if (!_GraphemeBreakTree._INSTANCE) {
        _GraphemeBreakTree._INSTANCE = new _GraphemeBreakTree();
      }
      return _GraphemeBreakTree._INSTANCE;
    }
    constructor() {
      this._data = getGraphemeBreakRawData();
    }
    getGraphemeBreakType(codePoint) {
      if (codePoint < 32) {
        if (codePoint === 10) {
          return 3;
        }
        if (codePoint === 13) {
          return 2;
        }
        return 4;
      }
      if (codePoint < 127) {
        return 0;
      }
      const data = this._data;
      const nodeCount = data.length / 3;
      let nodeIndex = 1;
      while (nodeIndex <= nodeCount) {
        if (codePoint < data[3 * nodeIndex]) {
          nodeIndex = 2 * nodeIndex;
        } else if (codePoint > data[3 * nodeIndex + 1]) {
          nodeIndex = 2 * nodeIndex + 1;
        } else {
          return data[3 * nodeIndex + 2];
        }
      }
      return 0;
    }
  };
  GraphemeBreakTree._INSTANCE = null;
  function getGraphemeBreakRawData() {
    return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
  }
  var AmbiguousCharacters = class _AmbiguousCharacters {
    static getInstance(locales) {
      return _AmbiguousCharacters.cache.get(Array.from(locales));
    }
    static getLocales() {
      return _AmbiguousCharacters._locales.value;
    }
    constructor(confusableDictionary) {
      this.confusableDictionary = confusableDictionary;
    }
    isAmbiguous(codePoint) {
      return this.confusableDictionary.has(codePoint);
    }
    /**
     * Returns the non basic ASCII code point that the given code point can be confused,
     * or undefined if such code point does note exist.
     */
    getPrimaryConfusable(codePoint) {
      return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
      return new Set(this.confusableDictionary.keys());
    }
  };
  _a2 = AmbiguousCharacters;
  AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
    return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
  });
  AmbiguousCharacters.cache = new LRUCachedFunction((locales) => {
    function arrayToMap(arr) {
      const result = /* @__PURE__ */ new Map();
      for (let i = 0; i < arr.length; i += 2) {
        result.set(arr[i], arr[i + 1]);
      }
      return result;
    }
    function mergeMaps(map1, map22) {
      const result = new Map(map1);
      for (const [key, value] of map22) {
        result.set(key, value);
      }
      return result;
    }
    function intersectMaps(map1, map22) {
      if (!map1) {
        return map22;
      }
      const result = /* @__PURE__ */ new Map();
      for (const [key, value] of map1) {
        if (map22.has(key)) {
          result.set(key, value);
        }
      }
      return result;
    }
    const data = _a2.ambiguousCharacterData.value;
    let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
    if (filteredLocales.length === 0) {
      filteredLocales = ["_default"];
    }
    let languageSpecificMap = void 0;
    for (const locale of filteredLocales) {
      const map3 = arrayToMap(data[locale]);
      languageSpecificMap = intersectMaps(languageSpecificMap, map3);
    }
    const commonMap = arrayToMap(data["_common"]);
    const map2 = mergeMaps(commonMap, languageSpecificMap);
    return new AmbiguousCharacters(map2);
  });
  AmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.value).filter((k) => !k.startsWith("_")));
  var InvisibleCharacters = class _InvisibleCharacters {
    static getRawData() {
      return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
    }
    static getData() {
      if (!this._data) {
        this._data = new Set(_InvisibleCharacters.getRawData());
      }
      return this._data;
    }
    static isInvisibleCharacter(codePoint) {
      return _InvisibleCharacters.getData().has(codePoint);
    }
    static get codePoints() {
      return _InvisibleCharacters.getData();
    }
  };
  InvisibleCharacters._data = void 0;

  // node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
  var INITIALIZE = "$initialize";
  var RequestMessage = class {
    constructor(vsWorker, req, method, args) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.method = method;
      this.args = args;
      this.type = 0;
    }
  };
  var ReplyMessage = class {
    constructor(vsWorker, seq2, res, err) {
      this.vsWorker = vsWorker;
      this.seq = seq2;
      this.res = res;
      this.err = err;
      this.type = 1;
    }
  };
  var SubscribeEventMessage = class {
    constructor(vsWorker, req, eventName, arg) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.eventName = eventName;
      this.arg = arg;
      this.type = 2;
    }
  };
  var EventMessage = class {
    constructor(vsWorker, req, event) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.event = event;
      this.type = 3;
    }
  };
  var UnsubscribeEventMessage = class {
    constructor(vsWorker, req) {
      this.vsWorker = vsWorker;
      this.req = req;
      this.type = 4;
    }
  };
  var SimpleWorkerProtocol = class {
    constructor(handler) {
      this._workerId = -1;
      this._handler = handler;
      this._lastSentReq = 0;
      this._pendingReplies = /* @__PURE__ */ Object.create(null);
      this._pendingEmitters = /* @__PURE__ */ new Map();
      this._pendingEvents = /* @__PURE__ */ new Map();
    }
    setWorkerId(workerId) {
      this._workerId = workerId;
    }
    sendMessage(method, args) {
      const req = String(++this._lastSentReq);
      return new Promise((resolve3, reject) => {
        this._pendingReplies[req] = {
          resolve: resolve3,
          reject
        };
        this._send(new RequestMessage(this._workerId, req, method, args));
      });
    }
    listen(eventName, arg) {
      let req = null;
      const emitter = new Emitter({
        onWillAddFirstListener: () => {
          req = String(++this._lastSentReq);
          this._pendingEmitters.set(req, emitter);
          this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));
        },
        onDidRemoveLastListener: () => {
          this._pendingEmitters.delete(req);
          this._send(new UnsubscribeEventMessage(this._workerId, req));
          req = null;
        }
      });
      return emitter.event;
    }
    handleMessage(message) {
      if (!message || !message.vsWorker) {
        return;
      }
      if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
        return;
      }
      this._handleMessage(message);
    }
    _handleMessage(msg) {
      switch (msg.type) {
        case 1:
          return this._handleReplyMessage(msg);
        case 0:
          return this._handleRequestMessage(msg);
        case 2:
          return this._handleSubscribeEventMessage(msg);
        case 3:
          return this._handleEventMessage(msg);
        case 4:
          return this._handleUnsubscribeEventMessage(msg);
      }
    }
    _handleReplyMessage(replyMessage) {
      if (!this._pendingReplies[replyMessage.seq]) {
        console.warn("Got reply to unknown seq");
        return;
      }
      const reply = this._pendingReplies[replyMessage.seq];
      delete this._pendingReplies[replyMessage.seq];
      if (replyMessage.err) {
        let err = replyMessage.err;
        if (replyMessage.err.$isError) {
          err = new Error();
          err.name = replyMessage.err.name;
          err.message = replyMessage.err.message;
          err.stack = replyMessage.err.stack;
        }
        reply.reject(err);
        return;
      }
      reply.resolve(replyMessage.res);
    }
    _handleRequestMessage(requestMessage) {
      const req = requestMessage.req;
      const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
      result.then((r) => {
        this._send(new ReplyMessage(this._workerId, req, r, void 0));
      }, (e) => {
        if (e.detail instanceof Error) {
          e.detail = transformErrorForSerialization(e.detail);
        }
        this._send(new ReplyMessage(this._workerId, req, void 0, transformErrorForSerialization(e)));
      });
    }
    _handleSubscribeEventMessage(msg) {
      const req = msg.req;
      const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {
        this._send(new EventMessage(this._workerId, req, event));
      });
      this._pendingEvents.set(req, disposable);
    }
    _handleEventMessage(msg) {
      if (!this._pendingEmitters.has(msg.req)) {
        console.warn("Got event for unknown req");
        return;
      }
      this._pendingEmitters.get(msg.req).fire(msg.event);
    }
    _handleUnsubscribeEventMessage(msg) {
      if (!this._pendingEvents.has(msg.req)) {
        console.warn("Got unsubscribe for unknown req");
        return;
      }
      this._pendingEvents.get(msg.req).dispose();
      this._pendingEvents.delete(msg.req);
    }
    _send(msg) {
      const transfer = [];
      if (msg.type === 0) {
        for (let i = 0; i < msg.args.length; i++) {
          if (msg.args[i] instanceof ArrayBuffer) {
            transfer.push(msg.args[i]);
          }
        }
      } else if (msg.type === 1) {
        if (msg.res instanceof ArrayBuffer) {
          transfer.push(msg.res);
        }
      }
      this._handler.sendMessage(msg, transfer);
    }
  };
  function propertyIsEvent(name) {
    return name[0] === "o" && name[1] === "n" && isUpperAsciiLetter(name.charCodeAt(2));
  }
  function propertyIsDynamicEvent(name) {
    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));
  }
  function createProxyObject2(methodNames, invoke, proxyListen) {
    const createProxyMethod = (method) => {
      return function() {
        const args = Array.prototype.slice.call(arguments, 0);
        return invoke(method, args);
      };
    };
    const createProxyDynamicEvent = (eventName) => {
      return function(arg) {
        return proxyListen(eventName, arg);
      };
    };
    const result = {};
    for (const methodName of methodNames) {
      if (propertyIsDynamicEvent(methodName)) {
        result[methodName] = createProxyDynamicEvent(methodName);
        continue;
      }
      if (propertyIsEvent(methodName)) {
        result[methodName] = proxyListen(methodName, void 0);
        continue;
      }
      result[methodName] = createProxyMethod(methodName);
    }
    return result;
  }
  var SimpleWorkerServer = class {
    constructor(postMessage, requestHandlerFactory) {
      this._requestHandlerFactory = requestHandlerFactory;
      this._requestHandler = null;
      this._protocol = new SimpleWorkerProtocol({
        sendMessage: (msg, transfer) => {
          postMessage(msg, transfer);
        },
        handleMessage: (method, args) => this._handleMessage(method, args),
        handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)
      });
    }
    onmessage(msg) {
      this._protocol.handleMessage(msg);
    }
    _handleMessage(method, args) {
      if (method === INITIALIZE) {
        return this.initialize(args[0], args[1], args[2], args[3]);
      }
      if (!this._requestHandler || typeof this._requestHandler[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _handleEvent(eventName, arg) {
      if (!this._requestHandler) {
        throw new Error(`Missing requestHandler`);
      }
      if (propertyIsDynamicEvent(eventName)) {
        const event = this._requestHandler[eventName].call(this._requestHandler, arg);
        if (typeof event !== "function") {
          throw new Error(`Missing dynamic event ${eventName} on request handler.`);
        }
        return event;
      }
      if (propertyIsEvent(eventName)) {
        const event = this._requestHandler[eventName];
        if (typeof event !== "function") {
          throw new Error(`Missing event ${eventName} on request handler.`);
        }
        return event;
      }
      throw new Error(`Malformed event name ${eventName}`);
    }
    initialize(workerId, loaderConfig, moduleId, hostMethods) {
      this._protocol.setWorkerId(workerId);
      const proxyMethodRequest = (method, args) => {
        return this._protocol.sendMessage(method, args);
      };
      const proxyListen = (eventName, arg) => {
        return this._protocol.listen(eventName, arg);
      };
      const hostProxy = createProxyObject2(hostMethods, proxyMethodRequest, proxyListen);
      if (this._requestHandlerFactory) {
        this._requestHandler = this._requestHandlerFactory(hostProxy);
        return Promise.resolve(getAllMethodNames(this._requestHandler));
      }
      if (loaderConfig) {
        if (typeof loaderConfig.baseUrl !== "undefined") {
          delete loaderConfig["baseUrl"];
        }
        if (typeof loaderConfig.paths !== "undefined") {
          if (typeof loaderConfig.paths.vs !== "undefined") {
            delete loaderConfig.paths["vs"];
          }
        }
        if (typeof loaderConfig.trustedTypesPolicy !== void 0) {
          delete loaderConfig["trustedTypesPolicy"];
        }
        loaderConfig.catchError = true;
        globalThis.require.config(loaderConfig);
      }
      return new Promise((resolve3, reject) => {
        const req = globalThis.require;
        req([moduleId], (module) => {
          this._requestHandler = module.create(hostProxy);
          if (!this._requestHandler) {
            reject(new Error(`No RequestHandler!`));
            return;
          }
          resolve3(getAllMethodNames(this._requestHandler));
        }, reject);
      });
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
  var DiffChange = class {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {
      this.originalStart = originalStart;
      this.originalLength = originalLength;
      this.modifiedStart = modifiedStart;
      this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    getOriginalEnd() {
      return this.originalStart + this.originalLength;
    }
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    getModifiedEnd() {
      return this.modifiedStart + this.modifiedLength;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/hash.js
  function numberHash(val, initialHashVal) {
    return (initialHashVal << 5) - initialHashVal + val | 0;
  }
  function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (let i = 0, length = s.length; i < length; i++) {
      hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
  }
  function leftRotate(value, bits, totalBits = 32) {
    const delta = totalBits - bits;
    const mask = ~((1 << delta) - 1);
    return (value << bits | (mask & value) >>> delta) >>> 0;
  }
  function fill(dest, index = 0, count = dest.byteLength, value = 0) {
    for (let i = 0; i < count; i++) {
      dest[index + i] = value;
    }
  }
  function leftPad(value, length, char = "0") {
    while (value.length < length) {
      value = char + value;
    }
    return value;
  }
  function toHexString(bufferOrValue, bitsize = 32) {
    if (bufferOrValue instanceof ArrayBuffer) {
      return Array.from(new Uint8Array(bufferOrValue)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);
  }
  var StringSHA1 = class _StringSHA1 {
    constructor() {
      this._h0 = 1732584193;
      this._h1 = 4023233417;
      this._h2 = 2562383102;
      this._h3 = 271733878;
      this._h4 = 3285377520;
      this._buff = new Uint8Array(
        64 + 3
        /* to fit any utf-8 */
      );
      this._buffDV = new DataView(this._buff.buffer);
      this._buffLen = 0;
      this._totalLen = 0;
      this._leftoverHighSurrogate = 0;
      this._finished = false;
    }
    update(str) {
      const strLen = str.length;
      if (strLen === 0) {
        return;
      }
      const buff = this._buff;
      let buffLen = this._buffLen;
      let leftoverHighSurrogate = this._leftoverHighSurrogate;
      let charCode;
      let offset;
      if (leftoverHighSurrogate !== 0) {
        charCode = leftoverHighSurrogate;
        offset = -1;
        leftoverHighSurrogate = 0;
      } else {
        charCode = str.charCodeAt(0);
        offset = 0;
      }
      while (true) {
        let codePoint = charCode;
        if (isHighSurrogate(charCode)) {
          if (offset + 1 < strLen) {
            const nextCharCode = str.charCodeAt(offset + 1);
            if (isLowSurrogate(nextCharCode)) {
              offset++;
              codePoint = computeCodePoint(charCode, nextCharCode);
            } else {
              codePoint = 65533;
            }
          } else {
            leftoverHighSurrogate = charCode;
            break;
          }
        } else if (isLowSurrogate(charCode)) {
          codePoint = 65533;
        }
        buffLen = this._push(buff, buffLen, codePoint);
        offset++;
        if (offset < strLen) {
          charCode = str.charCodeAt(offset);
        } else {
          break;
        }
      }
      this._buffLen = buffLen;
      this._leftoverHighSurrogate = leftoverHighSurrogate;
    }
    _push(buff, buffLen, codePoint) {
      if (codePoint < 128) {
        buff[buffLen++] = codePoint;
      } else if (codePoint < 2048) {
        buff[buffLen++] = 192 | (codePoint & 1984) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else if (codePoint < 65536) {
        buff[buffLen++] = 224 | (codePoint & 61440) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      } else {
        buff[buffLen++] = 240 | (codePoint & 1835008) >>> 18;
        buff[buffLen++] = 128 | (codePoint & 258048) >>> 12;
        buff[buffLen++] = 128 | (codePoint & 4032) >>> 6;
        buff[buffLen++] = 128 | (codePoint & 63) >>> 0;
      }
      if (buffLen >= 64) {
        this._step();
        buffLen -= 64;
        this._totalLen += 64;
        buff[0] = buff[64 + 0];
        buff[1] = buff[64 + 1];
        buff[2] = buff[64 + 2];
      }
      return buffLen;
    }
    digest() {
      if (!this._finished) {
        this._finished = true;
        if (this._leftoverHighSurrogate) {
          this._leftoverHighSurrogate = 0;
          this._buffLen = this._push(
            this._buff,
            this._buffLen,
            65533
            /* SHA1Constant.UNICODE_REPLACEMENT */
          );
        }
        this._totalLen += this._buffLen;
        this._wrapUp();
      }
      return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);
    }
    _wrapUp() {
      this._buff[this._buffLen++] = 128;
      fill(this._buff, this._buffLen);
      if (this._buffLen > 56) {
        this._step();
        fill(this._buff);
      }
      const ml = 8 * this._totalLen;
      this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);
      this._buffDV.setUint32(60, ml % 4294967296, false);
      this._step();
    }
    _step() {
      const bigBlock32 = _StringSHA1._bigBlock32;
      const data = this._buffDV;
      for (let j = 0; j < 64; j += 4) {
        bigBlock32.setUint32(j, data.getUint32(j, false), false);
      }
      for (let j = 64; j < 320; j += 4) {
        bigBlock32.setUint32(j, leftRotate(bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false), 1), false);
      }
      let a2 = this._h0;
      let b = this._h1;
      let c = this._h2;
      let d = this._h3;
      let e = this._h4;
      let f2, k;
      let temp;
      for (let j = 0; j < 80; j++) {
        if (j < 20) {
          f2 = b & c | ~b & d;
          k = 1518500249;
        } else if (j < 40) {
          f2 = b ^ c ^ d;
          k = 1859775393;
        } else if (j < 60) {
          f2 = b & c | b & d | c & d;
          k = 2400959708;
        } else {
          f2 = b ^ c ^ d;
          k = 3395469782;
        }
        temp = leftRotate(a2, 5) + f2 + e + k + bigBlock32.getUint32(j * 4, false) & 4294967295;
        e = d;
        d = c;
        c = leftRotate(b, 30);
        b = a2;
        a2 = temp;
      }
      this._h0 = this._h0 + a2 & 4294967295;
      this._h1 = this._h1 + b & 4294967295;
      this._h2 = this._h2 + c & 4294967295;
      this._h3 = this._h3 + d & 4294967295;
      this._h4 = this._h4 + e & 4294967295;
    }
  };
  StringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320));

  // node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
  var StringDiffSequence = class {
    constructor(source) {
      this.source = source;
    }
    getElements() {
      const source = this.source;
      const characters = new Int32Array(source.length);
      for (let i = 0, len = source.length; i < len; i++) {
        characters[i] = source.charCodeAt(i);
      }
      return characters;
    }
  };
  function stringDiff(original, modified, pretty) {
    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
  }
  var Debug = class {
    static Assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
  };
  var MyArray = class {
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
      for (let i = 0; i < length; i++) {
        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
      }
    }
  };
  var DiffChangeHelper = class {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    constructor() {
      this.m_changes = [];
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    MarkNextChange() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
      }
      this.m_originalCount = 0;
      this.m_modifiedCount = 0;
      this.m_originalStart = 1073741824;
      this.m_modifiedStart = 1073741824;
    }
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    AddOriginalElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_originalCount++;
    }
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    AddModifiedElement(originalIndex, modifiedIndex) {
      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
      this.m_modifiedCount++;
    }
    /**
     * Retrieves all of the changes marked by the class.
     */
    getChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      return this.m_changes;
    }
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    getReverseChanges() {
      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
        this.MarkNextChange();
      }
      this.m_changes.reverse();
      return this.m_changes;
    }
  };
  var LcsDiff = class _LcsDiff {
    /**
     * Constructs the DiffFinder
     */
    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {
      this.ContinueProcessingPredicate = continueProcessingPredicate;
      this._originalSequence = originalSequence;
      this._modifiedSequence = modifiedSequence;
      const [originalStringElements, originalElementsOrHash, originalHasStrings] = _LcsDiff._getElements(originalSequence);
      const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = _LcsDiff._getElements(modifiedSequence);
      this._hasStrings = originalHasStrings && modifiedHasStrings;
      this._originalStringElements = originalStringElements;
      this._originalElementsOrHash = originalElementsOrHash;
      this._modifiedStringElements = modifiedStringElements;
      this._modifiedElementsOrHash = modifiedElementsOrHash;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
    }
    static _isStringArray(arr) {
      return arr.length > 0 && typeof arr[0] === "string";
    }
    static _getElements(sequence) {
      const elements = sequence.getElements();
      if (_LcsDiff._isStringArray(elements)) {
        const hashes = new Int32Array(elements.length);
        for (let i = 0, len = elements.length; i < len; i++) {
          hashes[i] = stringHash(elements[i], 0);
        }
        return [elements, hashes, true];
      }
      if (elements instanceof Int32Array) {
        return [[], elements, false];
      }
      return [[], new Int32Array(elements), false];
    }
    ElementsAreEqual(originalIndex, newIndex) {
      if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;
    }
    ElementsAreStrictEqual(originalIndex, newIndex) {
      if (!this.ElementsAreEqual(originalIndex, newIndex)) {
        return false;
      }
      const originalElement = _LcsDiff._getStrictElement(this._originalSequence, originalIndex);
      const modifiedElement = _LcsDiff._getStrictElement(this._modifiedSequence, newIndex);
      return originalElement === modifiedElement;
    }
    static _getStrictElement(sequence, index) {
      if (typeof sequence.getStrictElement === "function") {
        return sequence.getStrictElement(index);
      }
      return null;
    }
    OriginalElementsAreEqual(index1, index2) {
      if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;
    }
    ModifiedElementsAreEqual(index1, index2) {
      if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
        return false;
      }
      return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;
    }
    ComputeDiff(pretty) {
      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    }
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
      const quitEarlyArr = [false];
      let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
      if (pretty) {
        changes = this.PrettifyChanges(changes);
      }
      return {
        quitEarly: quitEarlyArr[0],
        changes
      };
    }
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
      quitEarlyArr[0] = false;
      while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
        originalStart++;
        modifiedStart++;
      }
      while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
        originalEnd--;
        modifiedEnd--;
      }
      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
        let changes;
        if (modifiedStart <= modifiedEnd) {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          changes = [
            new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
          ];
        } else if (originalStart <= originalEnd) {
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
          ];
        } else {
          Debug.Assert(originalStart === originalEnd + 1, "originalStart should only be one more than originalEnd");
          Debug.Assert(modifiedStart === modifiedEnd + 1, "modifiedStart should only be one more than modifiedEnd");
          changes = [];
        }
        return changes;
      }
      const midOriginalArr = [0];
      const midModifiedArr = [0];
      const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
      const midOriginal = midOriginalArr[0];
      const midModified = midModifiedArr[0];
      if (result !== null) {
        return result;
      } else if (!quitEarlyArr[0]) {
        const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
        let rightChanges = [];
        if (!quitEarlyArr[0]) {
          rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
        } else {
          rightChanges = [
            new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
          ];
        }
        return this.ConcatenateChanges(leftChanges, rightChanges);
      }
      return [
        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
      ];
    }
    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
      let forwardChanges = null;
      let reverseChanges = null;
      let changeHelper = new DiffChangeHelper();
      let diagonalMin = diagonalForwardStart;
      let diagonalMax = diagonalForwardEnd;
      let diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;
      let lastOriginalIndex = -1073741824;
      let historyIndex = this.m_forwardHistory.length - 1;
      do {
        const diagonal = diagonalRelative + diagonalForwardBase;
        if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
          originalIndex = forwardPoints[diagonal + 1];
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex;
          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
          diagonalRelative = diagonal + 1 - diagonalForwardBase;
        } else {
          originalIndex = forwardPoints[diagonal - 1] + 1;
          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
          if (originalIndex < lastOriginalIndex) {
            changeHelper.MarkNextChange();
          }
          lastOriginalIndex = originalIndex - 1;
          changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
          diagonalRelative = diagonal - 1 - diagonalForwardBase;
        }
        if (historyIndex >= 0) {
          forwardPoints = this.m_forwardHistory[historyIndex];
          diagonalForwardBase = forwardPoints[0];
          diagonalMin = 1;
          diagonalMax = forwardPoints.length - 1;
        }
      } while (--historyIndex >= -1);
      forwardChanges = changeHelper.getReverseChanges();
      if (quitEarlyArr[0]) {
        let originalStartPoint = midOriginalArr[0] + 1;
        let modifiedStartPoint = midModifiedArr[0] + 1;
        if (forwardChanges !== null && forwardChanges.length > 0) {
          const lastForwardChange = forwardChanges[forwardChanges.length - 1];
          originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
          modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
        }
        reverseChanges = [
          new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
        ];
      } else {
        changeHelper = new DiffChangeHelper();
        diagonalMin = diagonalReverseStart;
        diagonalMax = diagonalReverseEnd;
        diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;
        lastOriginalIndex = 1073741824;
        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
        do {
          const diagonal = diagonalRelative + diagonalReverseBase;
          if (diagonal === diagonalMin || diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex + 1;
            changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal + 1 - diagonalReverseBase;
          } else {
            originalIndex = reversePoints[diagonal - 1];
            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
            if (originalIndex > lastOriginalIndex) {
              changeHelper.MarkNextChange();
            }
            lastOriginalIndex = originalIndex;
            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
            diagonalRelative = diagonal - 1 - diagonalReverseBase;
          }
          if (historyIndex >= 0) {
            reversePoints = this.m_reverseHistory[historyIndex];
            diagonalReverseBase = reversePoints[0];
            diagonalMin = 1;
            diagonalMax = reversePoints.length - 1;
          }
        } while (--historyIndex >= -1);
        reverseChanges = changeHelper.getChanges();
      }
      return this.ConcatenateChanges(forwardChanges, reverseChanges);
    }
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
      let originalIndex = 0, modifiedIndex = 0;
      let diagonalForwardStart = 0, diagonalForwardEnd = 0;
      let diagonalReverseStart = 0, diagonalReverseEnd = 0;
      originalStart--;
      modifiedStart--;
      midOriginalArr[0] = 0;
      midModifiedArr[0] = 0;
      this.m_forwardHistory = [];
      this.m_reverseHistory = [];
      const maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);
      const numDiagonals = maxDifferences + 1;
      const forwardPoints = new Int32Array(numDiagonals);
      const reversePoints = new Int32Array(numDiagonals);
      const diagonalForwardBase = modifiedEnd - modifiedStart;
      const diagonalReverseBase = originalEnd - originalStart;
      const diagonalForwardOffset = originalStart - modifiedStart;
      const diagonalReverseOffset = originalEnd - modifiedEnd;
      const delta = diagonalReverseBase - diagonalForwardBase;
      const deltaIsEven = delta % 2 === 0;
      forwardPoints[diagonalForwardBase] = originalStart;
      reversePoints[diagonalReverseBase] = originalEnd;
      quitEarlyArr[0] = false;
      for (let numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {
        let furthestOriginalIndex = 0;
        let furthestModifiedIndex = 0;
        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
        for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
          if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {
            originalIndex = forwardPoints[diagonal + 1];
          } else {
            originalIndex = forwardPoints[diagonal - 1] + 1;
          }
          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
            originalIndex++;
            modifiedIndex++;
          }
          forwardPoints[diagonal] = originalIndex;
          if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
            furthestOriginalIndex = originalIndex;
            furthestModifiedIndex = modifiedIndex;
          }
          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {
            if (originalIndex >= reversePoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex <= reversePoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        const matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
          quitEarlyArr[0] = true;
          midOriginalArr[0] = furthestOriginalIndex;
          midModifiedArr[0] = furthestModifiedIndex;
          if (matchLengthOfLongest > 0 && 1447 > 0 && numDifferences <= 1447 + 1) {
            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
          } else {
            originalStart++;
            modifiedStart++;
            return [
              new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
          }
        }
        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
        for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
          if (diagonal === diagonalReverseStart || diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1]) {
            originalIndex = reversePoints[diagonal + 1] - 1;
          } else {
            originalIndex = reversePoints[diagonal - 1];
          }
          modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
          const tempOriginalIndex = originalIndex;
          while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
            originalIndex--;
            modifiedIndex--;
          }
          reversePoints[diagonal] = originalIndex;
          if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
            if (originalIndex <= forwardPoints[diagonal]) {
              midOriginalArr[0] = originalIndex;
              midModifiedArr[0] = modifiedIndex;
              if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 > 0 && numDifferences <= 1447 + 1) {
                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
              } else {
                return null;
              }
            }
          }
        }
        if (numDifferences <= 1447) {
          let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
          temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
          MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
          this.m_forwardHistory.push(temp);
          temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
          temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
          MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
          this.m_reverseHistory.push(temp);
        }
      }
      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    }
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    PrettifyChanges(changes) {
      for (let i = 0; i < changes.length; i++) {
        const change = changes[i];
        const originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
        const modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
          const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);
          const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);
          if (endStrictEqual && !startStrictEqual) {
            break;
          }
          change.originalStart++;
          change.modifiedStart++;
        }
        const mergedChangeArr = [null];
        if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
          changes[i] = mergedChangeArr[0];
          changes.splice(i + 1, 1);
          i--;
          continue;
        }
      }
      for (let i = changes.length - 1; i >= 0; i--) {
        const change = changes[i];
        let originalStop = 0;
        let modifiedStop = 0;
        if (i > 0) {
          const prevChange = changes[i - 1];
          originalStop = prevChange.originalStart + prevChange.originalLength;
          modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
        }
        const checkOriginal = change.originalLength > 0;
        const checkModified = change.modifiedLength > 0;
        let bestDelta = 0;
        let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
        for (let delta = 1; ; delta++) {
          const originalStart = change.originalStart - delta;
          const modifiedStart = change.modifiedStart - delta;
          if (originalStart < originalStop || modifiedStart < modifiedStop) {
            break;
          }
          if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
            break;
          }
          if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
            break;
          }
          const touchingPreviousChange = originalStart === originalStop && modifiedStart === modifiedStop;
          const score2 = (touchingPreviousChange ? 5 : 0) + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
          if (score2 > bestScore) {
            bestScore = score2;
            bestDelta = delta;
          }
        }
        change.originalStart -= bestDelta;
        change.modifiedStart -= bestDelta;
        const mergedChangeArr = [null];
        if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {
          changes[i - 1] = mergedChangeArr[0];
          changes.splice(i, 1);
          i++;
          continue;
        }
      }
      if (this._hasStrings) {
        for (let i = 1, len = changes.length; i < len; i++) {
          const aChange = changes[i - 1];
          const bChange = changes[i];
          const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;
          const aOriginalStart = aChange.originalStart;
          const bOriginalEnd = bChange.originalStart + bChange.originalLength;
          const abOriginalLength = bOriginalEnd - aOriginalStart;
          const aModifiedStart = aChange.modifiedStart;
          const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;
          const abModifiedLength = bModifiedEnd - aModifiedStart;
          if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {
            const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);
            if (t) {
              const [originalMatchStart, modifiedMatchStart] = t;
              if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {
                aChange.originalLength = originalMatchStart - aChange.originalStart;
                aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;
                bChange.originalStart = originalMatchStart + matchedLength;
                bChange.modifiedStart = modifiedMatchStart + matchedLength;
                bChange.originalLength = bOriginalEnd - bChange.originalStart;
                bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;
              }
            }
          }
        }
      }
      return changes;
    }
    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {
      if (originalLength < desiredLength || modifiedLength < desiredLength) {
        return null;
      }
      const originalMax = originalStart + originalLength - desiredLength + 1;
      const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;
      let bestScore = 0;
      let bestOriginalStart = 0;
      let bestModifiedStart = 0;
      for (let i = originalStart; i < originalMax; i++) {
        for (let j = modifiedStart; j < modifiedMax; j++) {
          const score2 = this._contiguousSequenceScore(i, j, desiredLength);
          if (score2 > 0 && score2 > bestScore) {
            bestScore = score2;
            bestOriginalStart = i;
            bestModifiedStart = j;
          }
        }
      }
      if (bestScore > 0) {
        return [bestOriginalStart, bestModifiedStart];
      }
      return null;
    }
    _contiguousSequenceScore(originalStart, modifiedStart, length) {
      let score2 = 0;
      for (let l = 0; l < length; l++) {
        if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {
          return 0;
        }
        score2 += this._originalStringElements[originalStart + l].length;
      }
      return score2;
    }
    _OriginalIsBoundary(index) {
      if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._originalStringElements[index]);
    }
    _OriginalRegionIsBoundary(originalStart, originalLength) {
      if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
        return true;
      }
      if (originalLength > 0) {
        const originalEnd = originalStart + originalLength;
        if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
          return true;
        }
      }
      return false;
    }
    _ModifiedIsBoundary(index) {
      if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
        return true;
      }
      return this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]);
    }
    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {
      if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
        return true;
      }
      if (modifiedLength > 0) {
        const modifiedEnd = modifiedStart + modifiedLength;
        if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
          return true;
        }
      }
      return false;
    }
    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {
      const originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;
      const modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;
      return originalScore + modifiedScore;
    }
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    ConcatenateChanges(left, right) {
      const mergedChangeArr = [];
      if (left.length === 0 || right.length === 0) {
        return right.length > 0 ? right : left;
      } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
        const result = new Array(left.length + right.length - 1);
        MyArray.Copy(left, 0, result, 0, left.length - 1);
        result[left.length - 1] = mergedChangeArr[0];
        MyArray.Copy(right, 1, result, left.length, right.length - 1);
        return result;
      } else {
        const result = new Array(left.length + right.length);
        MyArray.Copy(left, 0, result, 0, left.length);
        MyArray.Copy(right, 0, result, left.length, right.length);
        return result;
      }
    }
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    ChangesOverlap(left, right, mergedChangeArr) {
      Debug.Assert(left.originalStart <= right.originalStart, "Left change is not less than or equal to right change");
      Debug.Assert(left.modifiedStart <= right.modifiedStart, "Left change is not less than or equal to right change");
      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
        const originalStart = left.originalStart;
        let originalLength = left.originalLength;
        const modifiedStart = left.modifiedStart;
        let modifiedLength = left.modifiedLength;
        if (left.originalStart + left.originalLength >= right.originalStart) {
          originalLength = right.originalStart + right.originalLength - left.originalStart;
        }
        if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
          modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
        }
        mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
        return true;
      } else {
        mergedChangeArr[0] = null;
        return false;
      }
    }
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
      if (diagonal >= 0 && diagonal < numDiagonals) {
        return diagonal;
      }
      const diagonalsBelow = diagonalBaseIndex;
      const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
      const diffEven = numDifferences % 2 === 0;
      if (diagonal < 0) {
        const lowerBoundEven = diagonalsBelow % 2 === 0;
        return diffEven === lowerBoundEven ? 0 : 1;
      } else {
        const upperBoundEven = diagonalsAbove % 2 === 0;
        return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/process.js
  var safeProcess;
  if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") {
    const sandboxProcess = globals.vscode.process;
    safeProcess = {
      get platform() {
        return sandboxProcess.platform;
      },
      get arch() {
        return sandboxProcess.arch;
      },
      get env() {
        return sandboxProcess.env;
      },
      cwd() {
        return sandboxProcess.cwd();
      }
    };
  } else if (typeof process !== "undefined") {
    safeProcess = {
      get platform() {
        return process.platform;
      },
      get arch() {
        return process.arch;
      },
      get env() {
        return process.env;
      },
      cwd() {
        return process.env["VSCODE_CWD"] || process.cwd();
      }
    };
  } else {
    safeProcess = {
      // Supported
      get platform() {
        return isWindows ? "win32" : isMacintosh ? "darwin" : "linux";
      },
      get arch() {
        return void 0;
      },
      // Unsupported
      get env() {
        return {};
      },
      cwd() {
        return "/";
      }
    };
  }
  var cwd = safeProcess.cwd;
  var env = safeProcess.env;
  var platform = safeProcess.platform;

  // node_modules/monaco-editor/esm/vs/base/common/path.js
  var CHAR_UPPERCASE_A = 65;
  var CHAR_LOWERCASE_A = 97;
  var CHAR_UPPERCASE_Z = 90;
  var CHAR_LOWERCASE_Z = 122;
  var CHAR_DOT = 46;
  var CHAR_FORWARD_SLASH = 47;
  var CHAR_BACKWARD_SLASH = 92;
  var CHAR_COLON = 58;
  var CHAR_QUESTION_MARK = 63;
  var ErrorInvalidArgType = class extends Error {
    constructor(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && expected.indexOf("not ") === 0) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      const type = name.indexOf(".") !== -1 ? "property" : "argument";
      let msg = `The "${name}" ${type} ${determiner} of type ${expected}`;
      msg += `. Received type ${typeof actual}`;
      super(msg);
      this.code = "ERR_INVALID_ARG_TYPE";
    }
  };
  function validateObject(pathObject, name) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new ErrorInvalidArgType(name, "Object", pathObject);
    }
  }
  function validateString(value, name) {
    if (typeof value !== "string") {
      throw new ErrorInvalidArgType(name, "string", value);
    }
  }
  var platformIsWin32 = platform === "win32";
  function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  }
  function isPosixPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH;
  }
  function isWindowsDeviceRoot(code) {
    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;
  }
  function normalizeString(path5, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code = 0;
    for (let i = 0; i <= path5.length; ++i) {
      if (i < path5.length) {
        code = path5.charCodeAt(i);
      } else if (isPathSeparator2(code)) {
        break;
      } else {
        code = CHAR_FORWARD_SLASH;
      }
      if (isPathSeparator2(code)) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i;
              dots = 0;
              continue;
            } else if (res.length !== 0) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            res += res.length > 0 ? `${separator}..` : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += `${separator}${path5.slice(lastSlash + 1, i)}`;
          } else {
            res = path5.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format2(sep2, pathObject) {
    validateObject(pathObject, "pathObject");
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || `${pathObject.name || ""}${pathObject.ext || ""}`;
    if (!dir) {
      return base;
    }
    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep2}${base}`;
  }
  var win32 = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedDevice = "";
      let resolvedTail = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1; i--) {
        let path5;
        if (i >= 0) {
          path5 = pathSegments[i];
          validateString(path5, "path");
          if (path5.length === 0) {
            continue;
          }
        } else if (resolvedDevice.length === 0) {
          path5 = cwd();
        } else {
          path5 = env[`=${resolvedDevice}`] || cwd();
          if (path5 === void 0 || path5.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path5.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
            path5 = `${resolvedDevice}\\`;
          }
        }
        const len = path5.length;
        let rootEnd = 0;
        let device = "";
        let isAbsolute2 = false;
        const code = path5.charCodeAt(0);
        if (len === 1) {
          if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute2 = true;
          }
        } else if (isPathSeparator(code)) {
          isAbsolute2 = true;
          if (isPathSeparator(path5.charCodeAt(1))) {
            let j = 2;
            let last = j;
            while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              const firstPart = path5.slice(last, j);
              last = j;
              while (j < len && isPathSeparator(path5.charCodeAt(j))) {
                j++;
              }
              if (j < len && j !== last) {
                last = j;
                while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
                  j++;
                }
                if (j === len || j !== last) {
                  device = `\\\\${firstPart}\\${path5.slice(last, j)}`;
                  rootEnd = j;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
          device = path5.slice(0, 2);
          rootEnd = 2;
          if (len > 2 && isPathSeparator(path5.charCodeAt(2))) {
            isAbsolute2 = true;
            rootEnd = 3;
          }
        }
        if (device.length > 0) {
          if (resolvedDevice.length > 0) {
            if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {
              continue;
            }
          } else {
            resolvedDevice = device;
          }
        }
        if (resolvedAbsolute) {
          if (resolvedDevice.length > 0) {
            break;
          }
        } else {
          resolvedTail = `${path5.slice(rootEnd)}\\${resolvedTail}`;
          resolvedAbsolute = isAbsolute2;
          if (isAbsolute2 && resolvedDevice.length > 0) {
            break;
          }
        }
      }
      resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
      return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || ".";
    },
    normalize(path5) {
      validateString(path5, "path");
      const len = path5.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = 0;
      let device;
      let isAbsolute2 = false;
      const code = path5.charCodeAt(0);
      if (len === 1) {
        return isPosixPathSeparator(code) ? "\\" : path5;
      }
      if (isPathSeparator(code)) {
        isAbsolute2 = true;
        if (isPathSeparator(path5.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path5.slice(last, j);
            last = j;
            while (j < len && isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                return `\\\\${firstPart}\\${path5.slice(last)}\\`;
              }
              if (j !== last) {
                device = `\\\\${firstPart}\\${path5.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
        device = path5.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path5.charCodeAt(2))) {
          isAbsolute2 = true;
          rootEnd = 3;
        }
      }
      let tail = rootEnd < len ? normalizeString(path5.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator) : "";
      if (tail.length === 0 && !isAbsolute2) {
        tail = ".";
      }
      if (tail.length > 0 && isPathSeparator(path5.charCodeAt(len - 1))) {
        tail += "\\";
      }
      if (device === void 0) {
        return isAbsolute2 ? `\\${tail}` : tail;
      }
      return isAbsolute2 ? `${device}\\${tail}` : `${device}${tail}`;
    },
    isAbsolute(path5) {
      validateString(path5, "path");
      const len = path5.length;
      if (len === 0) {
        return false;
      }
      const code = path5.charCodeAt(0);
      return isPathSeparator(code) || // Possible device root
      len > 2 && isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON && isPathSeparator(path5.charCodeAt(2));
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      let firstPart;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = firstPart = arg;
          } else {
            joined += `\\${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      let needsReplace = true;
      let slashCount = 0;
      if (typeof firstPart === "string" && isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {
          ++slashCount;
          if (firstLen > 2) {
            if (isPathSeparator(firstPart.charCodeAt(2))) {
              ++slashCount;
            } else {
              needsReplace = false;
            }
          }
        }
      }
      if (needsReplace) {
        while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {
          slashCount++;
        }
        if (slashCount >= 2) {
          joined = `\\${joined.slice(slashCount)}`;
        }
      }
      return win32.normalize(joined);
    },
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      const fromOrig = win32.resolve(from);
      const toOrig = win32.resolve(to);
      if (fromOrig === toOrig) {
        return "";
      }
      from = fromOrig.toLowerCase();
      to = toOrig.toLowerCase();
      if (from === to) {
        return "";
      }
      let fromStart = 0;
      while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
        fromStart++;
      }
      let fromEnd = from.length;
      while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
        fromEnd--;
      }
      const fromLen = fromEnd - fromStart;
      let toStart = 0;
      while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        toStart++;
      }
      let toEnd = to.length;
      while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
        toEnd--;
      }
      const toLen = toEnd - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i !== length) {
        if (lastCommonSep === -1) {
          return toOrig;
        }
      } else {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
            return toOrig.slice(toStart + i + 1);
          }
          if (i === 2) {
            return toOrig.slice(toStart + i);
          }
        }
        if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 2) {
            lastCommonSep = 3;
          }
        }
        if (lastCommonSep === -1) {
          lastCommonSep = 0;
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
          out += out.length === 0 ? ".." : "\\..";
        }
      }
      toStart += lastCommonSep;
      if (out.length > 0) {
        return `${out}${toOrig.slice(toStart, toEnd)}`;
      }
      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
        ++toStart;
      }
      return toOrig.slice(toStart, toEnd);
    },
    toNamespacedPath(path5) {
      if (typeof path5 !== "string" || path5.length === 0) {
        return path5;
      }
      const resolvedPath = win32.resolve(path5);
      if (resolvedPath.length <= 2) {
        return path5;
      }
      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
          const code = resolvedPath.charCodeAt(2);
          if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
            return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
          }
        }
      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
      return path5;
    },
    dirname(path5) {
      validateString(path5, "path");
      const len = path5.length;
      if (len === 0) {
        return ".";
      }
      let rootEnd = -1;
      let offset = 0;
      const code = path5.charCodeAt(0);
      if (len === 1) {
        return isPathSeparator(code) ? path5 : ".";
      }
      if (isPathSeparator(code)) {
        rootEnd = offset = 1;
        if (isPathSeparator(path5.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                return path5;
              }
              if (j !== last) {
                rootEnd = offset = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
        rootEnd = len > 2 && isPathSeparator(path5.charCodeAt(2)) ? 3 : 2;
        offset = rootEnd;
      }
      let end = -1;
      let matchedSlash = true;
      for (let i = len - 1; i >= offset; --i) {
        if (isPathSeparator(path5.charCodeAt(i))) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        if (rootEnd === -1) {
          return ".";
        }
        end = rootEnd;
      }
      return path5.slice(0, end);
    },
    basename(path5, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path5, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (path5.length >= 2 && isWindowsDeviceRoot(path5.charCodeAt(0)) && path5.charCodeAt(1) === CHAR_COLON) {
        start = 2;
      }
      if (ext !== void 0 && ext.length > 0 && ext.length <= path5.length) {
        if (ext === path5) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path5.length - 1; i >= start; --i) {
          const code = path5.charCodeAt(i);
          if (isPathSeparator(code)) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path5.length;
        }
        return path5.slice(start, end);
      }
      for (i = path5.length - 1; i >= start; --i) {
        if (isPathSeparator(path5.charCodeAt(i))) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path5.slice(start, end);
    },
    extname(path5) {
      validateString(path5, "path");
      let start = 0;
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      if (path5.length >= 2 && path5.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path5.charCodeAt(0))) {
        start = startPart = 2;
      }
      for (let i = path5.length - 1; i >= start; --i) {
        const code = path5.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path5.slice(startDot, end);
    },
    format: _format2.bind(null, "\\"),
    parse(path5) {
      validateString(path5, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path5.length === 0) {
        return ret;
      }
      const len = path5.length;
      let rootEnd = 0;
      let code = path5.charCodeAt(0);
      if (len === 1) {
        if (isPathSeparator(code)) {
          ret.root = ret.dir = path5;
          return ret;
        }
        ret.base = ret.name = path5;
        return ret;
      }
      if (isPathSeparator(code)) {
        rootEnd = 1;
        if (isPathSeparator(path5.charCodeAt(1))) {
          let j = 2;
          let last = j;
          while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            last = j;
            while (j < len && isPathSeparator(path5.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              last = j;
              while (j < len && !isPathSeparator(path5.charCodeAt(j))) {
                j++;
              }
              if (j === len) {
                rootEnd = j;
              } else if (j !== last) {
                rootEnd = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code) && path5.charCodeAt(1) === CHAR_COLON) {
        if (len <= 2) {
          ret.root = ret.dir = path5;
          return ret;
        }
        rootEnd = 2;
        if (isPathSeparator(path5.charCodeAt(2))) {
          if (len === 3) {
            ret.root = ret.dir = path5;
            return ret;
          }
          rootEnd = 3;
        }
      }
      if (rootEnd > 0) {
        ret.root = path5.slice(0, rootEnd);
      }
      let startDot = -1;
      let startPart = rootEnd;
      let end = -1;
      let matchedSlash = true;
      let i = path5.length - 1;
      let preDotState = 0;
      for (; i >= rootEnd; --i) {
        code = path5.charCodeAt(i);
        if (isPathSeparator(code)) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path5.slice(startPart, end);
        } else {
          ret.name = path5.slice(startPart, startDot);
          ret.base = path5.slice(startPart, end);
          ret.ext = path5.slice(startDot, end);
        }
      }
      if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path5.slice(0, startPart - 1);
      } else {
        ret.dir = ret.root;
      }
      return ret;
    },
    sep: "\\",
    delimiter: ";",
    win32: null,
    posix: null
  };
  var posixCwd = (() => {
    if (platformIsWin32) {
      const regexp = /\\/g;
      return () => {
        const cwd2 = cwd().replace(regexp, "/");
        return cwd2.slice(cwd2.indexOf("/"));
      };
    }
    return () => cwd();
  })();
  var posix = {
    // path.resolve([from ...], to)
    resolve(...pathSegments) {
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        const path5 = i >= 0 ? pathSegments[i] : posixCwd();
        validateString(path5, "path");
        if (path5.length === 0) {
          continue;
        }
        resolvedPath = `${path5}/${resolvedPath}`;
        resolvedAbsolute = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
      if (resolvedAbsolute) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    },
    normalize(path5) {
      validateString(path5, "path");
      if (path5.length === 0) {
        return ".";
      }
      const isAbsolute2 = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
      const trailingSeparator = path5.charCodeAt(path5.length - 1) === CHAR_FORWARD_SLASH;
      path5 = normalizeString(path5, !isAbsolute2, "/", isPosixPathSeparator);
      if (path5.length === 0) {
        if (isAbsolute2) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path5 += "/";
      }
      return isAbsolute2 ? `/${path5}` : path5;
    },
    isAbsolute(path5) {
      validateString(path5, "path");
      return path5.length > 0 && path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
    },
    join(...paths) {
      if (paths.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0; i < paths.length; ++i) {
        const arg = paths[i];
        validateString(arg, "path");
        if (arg.length > 0) {
          if (joined === void 0) {
            joined = arg;
          } else {
            joined += `/${arg}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return posix.normalize(joined);
    },
    relative(from, to) {
      validateString(from, "from");
      validateString(to, "to");
      if (from === to) {
        return "";
      }
      from = posix.resolve(from);
      to = posix.resolve(to);
      if (from === to) {
        return "";
      }
      const fromStart = 1;
      const fromEnd = from.length;
      const fromLen = fromEnd - fromStart;
      const toStart = 1;
      const toLen = to.length - toStart;
      const length = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (; i < length; i++) {
        const fromCode = from.charCodeAt(fromStart + i);
        if (fromCode !== to.charCodeAt(toStart + i)) {
          break;
        } else if (fromCode === CHAR_FORWARD_SLASH) {
          lastCommonSep = i;
        }
      }
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
            return to.slice(toStart + i + 1);
          }
          if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          out += out.length === 0 ? ".." : "/..";
        }
      }
      return `${out}${to.slice(toStart + lastCommonSep)}`;
    },
    toNamespacedPath(path5) {
      return path5;
    },
    dirname(path5) {
      validateString(path5, "path");
      if (path5.length === 0) {
        return ".";
      }
      const hasRoot = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let end = -1;
      let matchedSlash = true;
      for (let i = path5.length - 1; i >= 1; --i) {
        if (path5.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) {
        return hasRoot ? "/" : ".";
      }
      if (hasRoot && end === 1) {
        return "//";
      }
      return path5.slice(0, end);
    },
    basename(path5, ext) {
      if (ext !== void 0) {
        validateString(ext, "ext");
      }
      validateString(path5, "path");
      let start = 0;
      let end = -1;
      let matchedSlash = true;
      let i;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path5.length) {
        if (ext === path5) {
          return "";
        }
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path5.length - 1; i >= 0; --i) {
          const code = path5.charCodeAt(i);
          if (code === CHAR_FORWARD_SLASH) {
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) {
          end = firstNonSlashEnd;
        } else if (end === -1) {
          end = path5.length;
        }
        return path5.slice(start, end);
      }
      for (i = path5.length - 1; i >= 0; --i) {
        if (path5.charCodeAt(i) === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) {
        return "";
      }
      return path5.slice(start, end);
    },
    extname(path5) {
      validateString(path5, "path");
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path5.length - 1; i >= 0; --i) {
        const code = path5.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path5.slice(startDot, end);
    },
    format: _format2.bind(null, "/"),
    parse(path5) {
      validateString(path5, "path");
      const ret = { root: "", dir: "", base: "", ext: "", name: "" };
      if (path5.length === 0) {
        return ret;
      }
      const isAbsolute2 = path5.charCodeAt(0) === CHAR_FORWARD_SLASH;
      let start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end = -1;
      let matchedSlash = true;
      let i = path5.length - 1;
      let preDotState = 0;
      for (; i >= start; --i) {
        const code = path5.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
        if (code === CHAR_DOT) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (end !== -1) {
        const start2 = startPart === 0 && isAbsolute2 ? 1 : startPart;
        if (startDot === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          ret.base = ret.name = path5.slice(start2, end);
        } else {
          ret.name = path5.slice(start2, startDot);
          ret.base = path5.slice(start2, end);
          ret.ext = path5.slice(startDot, end);
        }
      }
      if (startPart > 0) {
        ret.dir = path5.slice(0, startPart - 1);
      } else if (isAbsolute2) {
        ret.dir = "/";
      }
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix.win32 = win32.win32 = win32;
  posix.posix = win32.posix = posix;
  var normalize = platformIsWin32 ? win32.normalize : posix.normalize;
  var resolve = platformIsWin32 ? win32.resolve : posix.resolve;
  var relative = platformIsWin32 ? win32.relative : posix.relative;
  var dirname = platformIsWin32 ? win32.dirname : posix.dirname;
  var basename = platformIsWin32 ? win32.basename : posix.basename;
  var extname = platformIsWin32 ? win32.extname : posix.extname;
  var sep = platformIsWin32 ? win32.sep : posix.sep;

  // node_modules/monaco-editor/esm/vs/base/common/uri.js
  var _schemePattern = /^\w[\w\d+.-]*$/;
  var _singleSlashStart = /^\//;
  var _doubleSlashStart = /^\/\//;
  function _validateUri(ret, _strict) {
    if (!ret.scheme && _strict) {
      throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
    }
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
      throw new Error("[UriError]: Scheme contains illegal characters.");
    }
    if (ret.path) {
      if (ret.authority) {
        if (!_singleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        }
      } else {
        if (_doubleSlashStart.test(ret.path)) {
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
    }
  }
  function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
      return "file";
    }
    return scheme;
  }
  function _referenceResolution(scheme, path5) {
    switch (scheme) {
      case "https":
      case "http":
      case "file":
        if (!path5) {
          path5 = _slash;
        } else if (path5[0] !== _slash) {
          path5 = _slash + path5;
        }
        break;
    }
    return path5;
  }
  var _empty = "";
  var _slash = "/";
  var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  var URI = class _URI {
    static isUri(thing) {
      if (thing instanceof _URI) {
        return true;
      }
      if (!thing) {
        return false;
      }
      return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "string" && typeof thing.with === "function" && typeof thing.toString === "function";
    }
    /**
     * @internal
     */
    constructor(schemeOrData, authority, path5, query, fragment, _strict = false) {
      if (typeof schemeOrData === "object") {
        this.scheme = schemeOrData.scheme || _empty;
        this.authority = schemeOrData.authority || _empty;
        this.path = schemeOrData.path || _empty;
        this.query = schemeOrData.query || _empty;
        this.fragment = schemeOrData.fragment || _empty;
      } else {
        this.scheme = _schemeFix(schemeOrData, _strict);
        this.authority = authority || _empty;
        this.path = _referenceResolution(this.scheme, path5 || _empty);
        this.query = query || _empty;
        this.fragment = fragment || _empty;
        _validateUri(this, _strict);
      }
    }
    // ---- filesystem path -----------------------
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath() {
      return uriToFsPath(this, false);
    }
    // ---- modify to new -------------------------
    with(change) {
      if (!change) {
        return this;
      }
      let { scheme, authority, path: path5, query, fragment } = change;
      if (scheme === void 0) {
        scheme = this.scheme;
      } else if (scheme === null) {
        scheme = _empty;
      }
      if (authority === void 0) {
        authority = this.authority;
      } else if (authority === null) {
        authority = _empty;
      }
      if (path5 === void 0) {
        path5 = this.path;
      } else if (path5 === null) {
        path5 = _empty;
      }
      if (query === void 0) {
        query = this.query;
      } else if (query === null) {
        query = _empty;
      }
      if (fragment === void 0) {
        fragment = this.fragment;
      } else if (fragment === null) {
        fragment = _empty;
      }
      if (scheme === this.scheme && authority === this.authority && path5 === this.path && query === this.query && fragment === this.fragment) {
        return this;
      }
      return new Uri(scheme, authority, path5, query, fragment);
    }
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value, _strict = false) {
      const match = _regexp.exec(value);
      if (!match) {
        return new Uri(_empty, _empty, _empty, _empty, _empty);
      }
      return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    }
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path5) {
      let authority = _empty;
      if (isWindows) {
        path5 = path5.replace(/\\/g, _slash);
      }
      if (path5[0] === _slash && path5[1] === _slash) {
        const idx = path5.indexOf(_slash, 2);
        if (idx === -1) {
          authority = path5.substring(2);
          path5 = _slash;
        } else {
          authority = path5.substring(2, idx);
          path5 = path5.substring(idx) || _slash;
        }
      }
      return new Uri("file", authority, path5, _empty, _empty);
    }
    /**
     * Creates new URI from uri components.
     *
     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
     * validation and should be used for untrusted uri components retrieved from storage,
     * user input, command arguments etc
     */
    static from(components, strict) {
      const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);
      return result;
    }
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri, ...pathFragment) {
      if (!uri.path) {
        throw new Error(`[UriError]: cannot call joinPath on URI without path`);
      }
      let newPath;
      if (isWindows && uri.scheme === "file") {
        newPath = _URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;
      } else {
        newPath = posix.join(uri.path, ...pathFragment);
      }
      return uri.with({ path: newPath });
    }
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding = false) {
      return _asFormatted(this, skipEncoding);
    }
    toJSON() {
      return this;
    }
    static revive(data) {
      var _a3, _b;
      if (!data) {
        return data;
      } else if (data instanceof _URI) {
        return data;
      } else {
        const result = new Uri(data);
        result._formatted = (_a3 = data.external) !== null && _a3 !== void 0 ? _a3 : null;
        result._fsPath = data._sep === _pathSepMarker ? (_b = data.fsPath) !== null && _b !== void 0 ? _b : null : null;
        return result;
      }
    }
  };
  var _pathSepMarker = isWindows ? 1 : void 0;
  var Uri = class extends URI {
    constructor() {
      super(...arguments);
      this._formatted = null;
      this._fsPath = null;
    }
    get fsPath() {
      if (!this._fsPath) {
        this._fsPath = uriToFsPath(this, false);
      }
      return this._fsPath;
    }
    toString(skipEncoding = false) {
      if (!skipEncoding) {
        if (!this._formatted) {
          this._formatted = _asFormatted(this, false);
        }
        return this._formatted;
      } else {
        return _asFormatted(this, true);
      }
    }
    toJSON() {
      const res = {
        $mid: 1
        /* MarshalledId.Uri */
      };
      if (this._fsPath) {
        res.fsPath = this._fsPath;
        res._sep = _pathSepMarker;
      }
      if (this._formatted) {
        res.external = this._formatted;
      }
      if (this.path) {
        res.path = this.path;
      }
      if (this.scheme) {
        res.scheme = this.scheme;
      }
      if (this.authority) {
        res.authority = this.authority;
      }
      if (this.query) {
        res.query = this.query;
      }
      if (this.fragment) {
        res.fragment = this.fragment;
      }
      return res;
    }
  };
  var encodeTable = {
    [
      58
      /* CharCode.Colon */
    ]: "%3A",
    [
      47
      /* CharCode.Slash */
    ]: "%2F",
    [
      63
      /* CharCode.QuestionMark */
    ]: "%3F",
    [
      35
      /* CharCode.Hash */
    ]: "%23",
    [
      91
      /* CharCode.OpenSquareBracket */
    ]: "%5B",
    [
      93
      /* CharCode.CloseSquareBracket */
    ]: "%5D",
    [
      64
      /* CharCode.AtSign */
    ]: "%40",
    [
      33
      /* CharCode.ExclamationMark */
    ]: "%21",
    [
      36
      /* CharCode.DollarSign */
    ]: "%24",
    [
      38
      /* CharCode.Ampersand */
    ]: "%26",
    [
      39
      /* CharCode.SingleQuote */
    ]: "%27",
    [
      40
      /* CharCode.OpenParen */
    ]: "%28",
    [
      41
      /* CharCode.CloseParen */
    ]: "%29",
    [
      42
      /* CharCode.Asterisk */
    ]: "%2A",
    [
      43
      /* CharCode.Plus */
    ]: "%2B",
    [
      44
      /* CharCode.Comma */
    ]: "%2C",
    [
      59
      /* CharCode.Semicolon */
    ]: "%3B",
    [
      61
      /* CharCode.Equals */
    ]: "%3D",
    [
      32
      /* CharCode.Space */
    ]: "%20"
  };
  function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
    let res = void 0;
    let nativeEncodePos = -1;
    for (let pos = 0; pos < uriComponent.length; pos++) {
      const code = uriComponent.charCodeAt(pos);
      if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        if (res !== void 0) {
          res += uriComponent.charAt(pos);
        }
      } else {
        if (res === void 0) {
          res = uriComponent.substr(0, pos);
        }
        const escaped = encodeTable[code];
        if (escaped !== void 0) {
          if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
            nativeEncodePos = -1;
          }
          res += escaped;
        } else if (nativeEncodePos === -1) {
          nativeEncodePos = pos;
        }
      }
    }
    if (nativeEncodePos !== -1) {
      res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== void 0 ? res : uriComponent;
  }
  function encodeURIComponentMinimal(path5) {
    let res = void 0;
    for (let pos = 0; pos < path5.length; pos++) {
      const code = path5.charCodeAt(pos);
      if (code === 35 || code === 63) {
        if (res === void 0) {
          res = path5.substr(0, pos);
        }
        res += encodeTable[code];
      } else {
        if (res !== void 0) {
          res += path5[pos];
        }
      }
    }
    return res !== void 0 ? res : path5;
  }
  function uriToFsPath(uri, keepDriveLetterCasing) {
    let value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
      value = `//${uri.authority}${uri.path}`;
    } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
      if (!keepDriveLetterCasing) {
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
      } else {
        value = uri.path.substr(1);
      }
    } else {
      value = uri.path;
    }
    if (isWindows) {
      value = value.replace(/\//g, "\\");
    }
    return value;
  }
  function _asFormatted(uri, skipEncoding) {
    const encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
    let res = "";
    let { scheme, authority, path: path5, query, fragment } = uri;
    if (scheme) {
      res += scheme;
      res += ":";
    }
    if (authority || scheme === "file") {
      res += _slash;
      res += _slash;
    }
    if (authority) {
      let idx = authority.indexOf("@");
      if (idx !== -1) {
        const userinfo = authority.substr(0, idx);
        authority = authority.substr(idx + 1);
        idx = userinfo.lastIndexOf(":");
        if (idx === -1) {
          res += encoder(userinfo, false, false);
        } else {
          res += encoder(userinfo.substr(0, idx), false, false);
          res += ":";
          res += encoder(userinfo.substr(idx + 1), false, true);
        }
        res += "@";
      }
      authority = authority.toLowerCase();
      idx = authority.lastIndexOf(":");
      if (idx === -1) {
        res += encoder(authority, false, true);
      } else {
        res += encoder(authority.substr(0, idx), false, true);
        res += authority.substr(idx);
      }
    }
    if (path5) {
      if (path5.length >= 3 && path5.charCodeAt(0) === 47 && path5.charCodeAt(2) === 58) {
        const code = path5.charCodeAt(1);
        if (code >= 65 && code <= 90) {
          path5 = `/${String.fromCharCode(code + 32)}:${path5.substr(3)}`;
        }
      } else if (path5.length >= 2 && path5.charCodeAt(1) === 58) {
        const code = path5.charCodeAt(0);
        if (code >= 65 && code <= 90) {
          path5 = `${String.fromCharCode(code + 32)}:${path5.substr(2)}`;
        }
      }
      res += encoder(path5, true, false);
    }
    if (query) {
      res += "?";
      res += encoder(query, false, false);
    }
    if (fragment) {
      res += "#";
      res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;
    }
    return res;
  }
  function decodeURIComponentGraceful(str) {
    try {
      return decodeURIComponent(str);
    } catch (_a3) {
      if (str.length > 3) {
        return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
      } else {
        return str;
      }
    }
  }
  var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
      return str;
    }
    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/position.js
  var Position = class _Position {
    constructor(lineNumber, column) {
      this.lineNumber = lineNumber;
      this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber = this.lineNumber, newColumn = this.column) {
      if (newLineNumber === this.lineNumber && newColumn === this.column) {
        return this;
      } else {
        return new _Position(newLineNumber, newColumn);
      }
    }
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber = 0, deltaColumn = 0) {
      return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    }
    /**
     * Test if this position equals other position
     */
    equals(other) {
      return _Position.equals(this, other);
    }
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a2, b) {
      if (!a2 && !b) {
        return true;
      }
      return !!a2 && !!b && a2.lineNumber === b.lineNumber && a2.column === b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other) {
      return _Position.isBefore(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a2, b) {
      if (a2.lineNumber < b.lineNumber) {
        return true;
      }
      if (b.lineNumber < a2.lineNumber) {
        return false;
      }
      return a2.column < b.column;
    }
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other) {
      return _Position.isBeforeOrEqual(this, other);
    }
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a2, b) {
      if (a2.lineNumber < b.lineNumber) {
        return true;
      }
      if (b.lineNumber < a2.lineNumber) {
        return false;
      }
      return a2.column <= b.column;
    }
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a2, b) {
      const aLineNumber = a2.lineNumber | 0;
      const bLineNumber = b.lineNumber | 0;
      if (aLineNumber === bLineNumber) {
        const aColumn = a2.column | 0;
        const bColumn = b.column | 0;
        return aColumn - bColumn;
      }
      return aLineNumber - bLineNumber;
    }
    /**
     * Clone this position.
     */
    clone() {
      return new _Position(this.lineNumber, this.column);
    }
    /**
     * Convert to a human-readable representation.
     */
    toString() {
      return "(" + this.lineNumber + "," + this.column + ")";
    }
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos) {
      return new _Position(pos.lineNumber, pos.column);
    }
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj) {
      return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/range.js
  var Range = class _Range {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
      if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
        this.startLineNumber = endLineNumber;
        this.startColumn = endColumn;
        this.endLineNumber = startLineNumber;
        this.endColumn = startColumn;
      } else {
        this.startLineNumber = startLineNumber;
        this.startColumn = startColumn;
        this.endLineNumber = endLineNumber;
        this.endColumn = endColumn;
      }
    }
    /**
     * Test if this range is empty.
     */
    isEmpty() {
      return _Range.isEmpty(this);
    }
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range) {
      return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
    }
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position) {
      return _Range.containsPosition(this, position);
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range, position) {
      if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
        return false;
      }
      if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range, position) {
      if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
        return false;
      }
      if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {
        return false;
      }
      if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range) {
      return _Range.containsRange(this, range);
    }
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range) {
      return _Range.strictContainsRange(this, range);
    }
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range, otherRange) {
      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
        return false;
      }
      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
        return false;
      }
      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
        return false;
      }
      return true;
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range) {
      return _Range.plusRange(this, range);
    }
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a2, b) {
      let startLineNumber;
      let startColumn;
      let endLineNumber;
      let endColumn;
      if (b.startLineNumber < a2.startLineNumber) {
        startLineNumber = b.startLineNumber;
        startColumn = b.startColumn;
      } else if (b.startLineNumber === a2.startLineNumber) {
        startLineNumber = b.startLineNumber;
        startColumn = Math.min(b.startColumn, a2.startColumn);
      } else {
        startLineNumber = a2.startLineNumber;
        startColumn = a2.startColumn;
      }
      if (b.endLineNumber > a2.endLineNumber) {
        endLineNumber = b.endLineNumber;
        endColumn = b.endColumn;
      } else if (b.endLineNumber === a2.endLineNumber) {
        endLineNumber = b.endLineNumber;
        endColumn = Math.max(b.endColumn, a2.endColumn);
      } else {
        endLineNumber = a2.endLineNumber;
        endColumn = a2.endColumn;
      }
      return new _Range(startLineNumber, startColumn, endLineNumber, endColumn);
    }
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range) {
      return _Range.intersectRanges(this, range);
    }
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a2, b) {
      let resultStartLineNumber = a2.startLineNumber;
      let resultStartColumn = a2.startColumn;
      let resultEndLineNumber = a2.endLineNumber;
      let resultEndColumn = a2.endColumn;
      const otherStartLineNumber = b.startLineNumber;
      const otherStartColumn = b.startColumn;
      const otherEndLineNumber = b.endLineNumber;
      const otherEndColumn = b.endColumn;
      if (resultStartLineNumber < otherStartLineNumber) {
        resultStartLineNumber = otherStartLineNumber;
        resultStartColumn = otherStartColumn;
      } else if (resultStartLineNumber === otherStartLineNumber) {
        resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
      }
      if (resultEndLineNumber > otherEndLineNumber) {
        resultEndLineNumber = otherEndLineNumber;
        resultEndColumn = otherEndColumn;
      } else if (resultEndLineNumber === otherEndLineNumber) {
        resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
      }
      if (resultStartLineNumber > resultEndLineNumber) {
        return null;
      }
      if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
        return null;
      }
      return new _Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    }
    /**
     * Test if this range equals other.
     */
    equalsRange(other) {
      return _Range.equalsRange(this, other);
    }
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a2, b) {
      if (!a2 && !b) {
        return true;
      }
      return !!a2 && !!b && a2.startLineNumber === b.startLineNumber && a2.startColumn === b.startColumn && a2.endLineNumber === b.endLineNumber && a2.endColumn === b.endColumn;
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition() {
      return _Range.getEndPosition(this);
    }
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range) {
      return new Position(range.endLineNumber, range.endColumn);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition() {
      return _Range.getStartPosition(this);
    }
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range) {
      return new Position(range.startLineNumber, range.startColumn);
    }
    /**
     * Transform to a user presentable string representation.
     */
    toString() {
      return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
    }
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber, endColumn) {
      return new _Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    }
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber, startColumn) {
      return new _Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart() {
      return _Range.collapseToStart(this);
    }
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range) {
      return new _Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd() {
      return _Range.collapseToEnd(this);
    }
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range) {
      return new _Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount) {
      return new _Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);
    }
    // ---
    static fromPositions(start, end = start) {
      return new _Range(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    static lift(range) {
      if (!range) {
        return null;
      }
      return new _Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj) {
      return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
    }
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a2, b) {
      if (a2.endLineNumber < b.startLineNumber || a2.endLineNumber === b.startLineNumber && a2.endColumn < b.startColumn) {
        return false;
      }
      if (b.endLineNumber < a2.startLineNumber || b.endLineNumber === a2.startLineNumber && b.endColumn < a2.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a2, b) {
      if (a2.endLineNumber < b.startLineNumber || a2.endLineNumber === b.startLineNumber && a2.endColumn <= b.startColumn) {
        return false;
      }
      if (b.endLineNumber < a2.startLineNumber || b.endLineNumber === a2.startLineNumber && b.endColumn <= a2.startColumn) {
        return false;
      }
      return true;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a2, b) {
      if (a2 && b) {
        const aStartLineNumber = a2.startLineNumber | 0;
        const bStartLineNumber = b.startLineNumber | 0;
        if (aStartLineNumber === bStartLineNumber) {
          const aStartColumn = a2.startColumn | 0;
          const bStartColumn = b.startColumn | 0;
          if (aStartColumn === bStartColumn) {
            const aEndLineNumber = a2.endLineNumber | 0;
            const bEndLineNumber = b.endLineNumber | 0;
            if (aEndLineNumber === bEndLineNumber) {
              const aEndColumn = a2.endColumn | 0;
              const bEndColumn = b.endColumn | 0;
              return aEndColumn - bEndColumn;
            }
            return aEndLineNumber - bEndLineNumber;
          }
          return aStartColumn - bStartColumn;
        }
        return aStartLineNumber - bStartLineNumber;
      }
      const aExists = a2 ? 1 : 0;
      const bExists = b ? 1 : 0;
      return aExists - bExists;
    }
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a2, b) {
      if (a2.endLineNumber === b.endLineNumber) {
        if (a2.endColumn === b.endColumn) {
          if (a2.startLineNumber === b.startLineNumber) {
            return a2.startColumn - b.startColumn;
          }
          return a2.startLineNumber - b.startLineNumber;
        }
        return a2.endColumn - b.endColumn;
      }
      return a2.endLineNumber - b.endLineNumber;
    }
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range) {
      return range.endLineNumber > range.startLineNumber;
    }
    toJSON() {
      return this;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/arrays.js
  var CompareResult;
  (function(CompareResult2) {
    function isLessThan(result) {
      return result < 0;
    }
    CompareResult2.isLessThan = isLessThan;
    function isGreaterThan(result) {
      return result > 0;
    }
    CompareResult2.isGreaterThan = isGreaterThan;
    function isNeitherLessOrGreaterThan(result) {
      return result === 0;
    }
    CompareResult2.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;
    CompareResult2.greaterThan = 1;
    CompareResult2.lessThan = -1;
    CompareResult2.neitherLessOrGreaterThan = 0;
  })(CompareResult || (CompareResult = {}));
  var CallbackIterable = class _CallbackIterable {
    constructor(iterate) {
      this.iterate = iterate;
    }
    toArray() {
      const result = [];
      this.iterate((item) => {
        result.push(item);
        return true;
      });
      return result;
    }
    filter(predicate) {
      return new _CallbackIterable((cb) => this.iterate((item) => predicate(item) ? cb(item) : true));
    }
    map(mapFn) {
      return new _CallbackIterable((cb) => this.iterate((item) => cb(mapFn(item))));
    }
    findLast(predicate) {
      let result;
      this.iterate((item) => {
        if (predicate(item)) {
          result = item;
        }
        return true;
      });
      return result;
    }
    findLastMaxBy(comparator) {
      let result;
      let first = true;
      this.iterate((item) => {
        if (first || CompareResult.isGreaterThan(comparator(item, result))) {
          first = false;
          result = item;
        }
        return true;
      });
      return result;
    }
  };
  CallbackIterable.empty = new CallbackIterable((_callback) => {
  });

  // node_modules/monaco-editor/esm/vs/base/common/uint.js
  function toUint8(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 255) {
      return 255;
    }
    return v | 0;
  }
  function toUint32(v) {
    if (v < 0) {
      return 0;
    }
    if (v > 4294967295) {
      return 4294967295;
    }
    return v | 0;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js
  var PrefixSumComputer = class {
    constructor(values) {
      this.values = values;
      this.prefixSum = new Uint32Array(values.length);
      this.prefixSumValidIndex = new Int32Array(1);
      this.prefixSumValidIndex[0] = -1;
    }
    insertValues(insertIndex, insertValues) {
      insertIndex = toUint32(insertIndex);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      const insertValuesLen = insertValues.length;
      if (insertValuesLen === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length + insertValuesLen);
      this.values.set(oldValues.subarray(0, insertIndex), 0);
      this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
      this.values.set(insertValues, insertIndex);
      if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = insertIndex - 1;
      }
      this.prefixSum = new Uint32Array(this.values.length);
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    setValue(index, value) {
      index = toUint32(index);
      value = toUint32(value);
      if (this.values[index] === value) {
        return false;
      }
      this.values[index] = value;
      if (index - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = index - 1;
      }
      return true;
    }
    removeValues(startIndex, count) {
      startIndex = toUint32(startIndex);
      count = toUint32(count);
      const oldValues = this.values;
      const oldPrefixSum = this.prefixSum;
      if (startIndex >= oldValues.length) {
        return false;
      }
      const maxCount = oldValues.length - startIndex;
      if (count >= maxCount) {
        count = maxCount;
      }
      if (count === 0) {
        return false;
      }
      this.values = new Uint32Array(oldValues.length - count);
      this.values.set(oldValues.subarray(0, startIndex), 0);
      this.values.set(oldValues.subarray(startIndex + count), startIndex);
      this.prefixSum = new Uint32Array(this.values.length);
      if (startIndex - 1 < this.prefixSumValidIndex[0]) {
        this.prefixSumValidIndex[0] = startIndex - 1;
      }
      if (this.prefixSumValidIndex[0] >= 0) {
        this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
      }
      return true;
    }
    getTotalSum() {
      if (this.values.length === 0) {
        return 0;
      }
      return this._getPrefixSum(this.values.length - 1);
    }
    /**
     * Returns the sum of the first `index + 1` many items.
     * @returns `SUM(0 <= j <= index, values[j])`.
     */
    getPrefixSum(index) {
      if (index < 0) {
        return 0;
      }
      index = toUint32(index);
      return this._getPrefixSum(index);
    }
    _getPrefixSum(index) {
      if (index <= this.prefixSumValidIndex[0]) {
        return this.prefixSum[index];
      }
      let startIndex = this.prefixSumValidIndex[0] + 1;
      if (startIndex === 0) {
        this.prefixSum[0] = this.values[0];
        startIndex++;
      }
      if (index >= this.values.length) {
        index = this.values.length - 1;
      }
      for (let i = startIndex; i <= index; i++) {
        this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
      }
      this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
      return this.prefixSum[index];
    }
    getIndexOf(sum) {
      sum = Math.floor(sum);
      this.getTotalSum();
      let low = 0;
      let high = this.values.length - 1;
      let mid = 0;
      let midStop = 0;
      let midStart = 0;
      while (low <= high) {
        mid = low + (high - low) / 2 | 0;
        midStop = this.prefixSum[mid];
        midStart = midStop - this.values[mid];
        if (sum < midStart) {
          high = mid - 1;
        } else if (sum >= midStop) {
          low = mid + 1;
        } else {
          break;
        }
      }
      return new PrefixSumIndexOfResult(mid, sum - midStart);
    }
  };
  var PrefixSumIndexOfResult = class {
    constructor(index, remainder) {
      this.index = index;
      this.remainder = remainder;
      this._prefixSumIndexOfResultBrand = void 0;
      this.index = index;
      this.remainder = remainder;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
  var MirrorTextModel = class {
    constructor(uri, lines, eol, versionId) {
      this._uri = uri;
      this._lines = lines;
      this._eol = eol;
      this._versionId = versionId;
      this._lineStarts = null;
      this._cachedTextValue = null;
    }
    dispose() {
      this._lines.length = 0;
    }
    get version() {
      return this._versionId;
    }
    getText() {
      if (this._cachedTextValue === null) {
        this._cachedTextValue = this._lines.join(this._eol);
      }
      return this._cachedTextValue;
    }
    onEvents(e) {
      if (e.eol && e.eol !== this._eol) {
        this._eol = e.eol;
        this._lineStarts = null;
      }
      const changes = e.changes;
      for (const change of changes) {
        this._acceptDeleteRange(change.range);
        this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
      }
      this._versionId = e.versionId;
      this._cachedTextValue = null;
    }
    _ensureLineStarts() {
      if (!this._lineStarts) {
        const eolLength = this._eol.length;
        const linesLength = this._lines.length;
        const lineStartValues = new Uint32Array(linesLength);
        for (let i = 0; i < linesLength; i++) {
          lineStartValues[i] = this._lines[i].length + eolLength;
        }
        this._lineStarts = new PrefixSumComputer(lineStartValues);
      }
    }
    /**
     * All changes to a line's text go through this method
     */
    _setLineText(lineIndex, newValue) {
      this._lines[lineIndex] = newValue;
      if (this._lineStarts) {
        this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
      }
    }
    _acceptDeleteRange(range) {
      if (range.startLineNumber === range.endLineNumber) {
        if (range.startColumn === range.endColumn) {
          return;
        }
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
        return;
      }
      this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1) + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
      this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      if (this._lineStarts) {
        this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
      }
    }
    _acceptInsertText(position, insertText) {
      if (insertText.length === 0) {
        return;
      }
      const insertLines = splitLines(insertText);
      if (insertLines.length === 1) {
        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0] + this._lines[position.lineNumber - 1].substring(position.column - 1));
        return;
      }
      insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
      this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1) + insertLines[0]);
      const newLengths = new Uint32Array(insertLines.length - 1);
      for (let i = 1; i < insertLines.length; i++) {
        this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
        newLengths[i - 1] = insertLines[i].length + this._eol.length;
      }
      if (this._lineStarts) {
        this._lineStarts.insertValues(position.lineNumber, newLengths);
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
  var USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
  function createWordRegExp(allowInWords = "") {
    let source = "(-?\\d*\\.\\d\\w*)|([^";
    for (const sep2 of USUAL_WORD_SEPARATORS) {
      if (allowInWords.indexOf(sep2) >= 0) {
        continue;
      }
      source += "\\" + sep2;
    }
    source += "\\s]+)";
    return new RegExp(source, "g");
  }
  var DEFAULT_WORD_REGEXP = createWordRegExp();
  function ensureValidWordDefinition(wordDefinition) {
    let result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && wordDefinition instanceof RegExp) {
      if (!wordDefinition.global) {
        let flags = "g";
        if (wordDefinition.ignoreCase) {
          flags += "i";
        }
        if (wordDefinition.multiline) {
          flags += "m";
        }
        if (wordDefinition.unicode) {
          flags += "u";
        }
        result = new RegExp(wordDefinition.source, flags);
      } else {
        result = wordDefinition;
      }
    }
    result.lastIndex = 0;
    return result;
  }
  var _defaultConfig = new LinkedList();
  _defaultConfig.unshift({
    maxLen: 1e3,
    windowSize: 15,
    timeBudget: 150
  });
  function getWordAtText(column, wordDefinition, text, textOffset, config) {
    if (!config) {
      config = Iterable.first(_defaultConfig);
    }
    if (text.length > config.maxLen) {
      let start = column - config.maxLen / 2;
      if (start < 0) {
        start = 0;
      } else {
        textOffset += start;
      }
      text = text.substring(start, column + config.maxLen / 2);
      return getWordAtText(column, wordDefinition, text, textOffset, config);
    }
    const t1 = Date.now();
    const pos = column - 1 - textOffset;
    let prevRegexIndex = -1;
    let match = null;
    for (let i = 1; ; i++) {
      if (Date.now() - t1 >= config.timeBudget) {
        break;
      }
      const regexIndex = pos - config.windowSize * i;
      wordDefinition.lastIndex = Math.max(0, regexIndex);
      const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);
      if (!thisMatch && match) {
        break;
      }
      match = thisMatch;
      if (regexIndex <= 0) {
        break;
      }
      prevRegexIndex = regexIndex;
    }
    if (match) {
      const result = {
        word: match[0],
        startColumn: textOffset + 1 + match.index,
        endColumn: textOffset + 1 + match.index + match[0].length
      };
      wordDefinition.lastIndex = 0;
      return result;
    }
    return null;
  }
  function _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {
    let match;
    while (match = wordDefinition.exec(text)) {
      const matchIndex = match.index || 0;
      if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
        return match;
      } else if (stopPos > 0 && matchIndex > stopPos) {
        return null;
      }
    }
    return null;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
  var CharacterClassifier = class _CharacterClassifier {
    constructor(_defaultValue) {
      const defaultValue = toUint8(_defaultValue);
      this._defaultValue = defaultValue;
      this._asciiMap = _CharacterClassifier._createAsciiMap(defaultValue);
      this._map = /* @__PURE__ */ new Map();
    }
    static _createAsciiMap(defaultValue) {
      const asciiMap = new Uint8Array(256);
      asciiMap.fill(defaultValue);
      return asciiMap;
    }
    set(charCode, _value) {
      const value = toUint8(_value);
      if (charCode >= 0 && charCode < 256) {
        this._asciiMap[charCode] = value;
      } else {
        this._map.set(charCode, value);
      }
    }
    get(charCode) {
      if (charCode >= 0 && charCode < 256) {
        return this._asciiMap[charCode];
      } else {
        return this._map.get(charCode) || this._defaultValue;
      }
    }
    clear() {
      this._asciiMap.fill(this._defaultValue);
      this._map.clear();
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js
  var Uint8Matrix = class {
    constructor(rows, cols, defaultValue) {
      const data = new Uint8Array(rows * cols);
      for (let i = 0, len = rows * cols; i < len; i++) {
        data[i] = defaultValue;
      }
      this._data = data;
      this.rows = rows;
      this.cols = cols;
    }
    get(row, col) {
      return this._data[row * this.cols + col];
    }
    set(row, col, value) {
      this._data[row * this.cols + col] = value;
    }
  };
  var StateMachine = class {
    constructor(edges) {
      let maxCharCode = 0;
      let maxState = 0;
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to] = edges[i];
        if (chCode > maxCharCode) {
          maxCharCode = chCode;
        }
        if (from > maxState) {
          maxState = from;
        }
        if (to > maxState) {
          maxState = to;
        }
      }
      maxCharCode++;
      maxState++;
      const states = new Uint8Matrix(
        maxState,
        maxCharCode,
        0
        /* State.Invalid */
      );
      for (let i = 0, len = edges.length; i < len; i++) {
        const [from, chCode, to] = edges[i];
        states.set(from, chCode, to);
      }
      this._states = states;
      this._maxCharCode = maxCharCode;
    }
    nextState(currentState, chCode) {
      if (chCode < 0 || chCode >= this._maxCharCode) {
        return 0;
      }
      return this._states.get(currentState, chCode);
    }
  };
  var _stateMachine = null;
  function getStateMachine() {
    if (_stateMachine === null) {
      _stateMachine = new StateMachine([
        [
          1,
          104,
          2
          /* State.H */
        ],
        [
          1,
          72,
          2
          /* State.H */
        ],
        [
          1,
          102,
          6
          /* State.F */
        ],
        [
          1,
          70,
          6
          /* State.F */
        ],
        [
          2,
          116,
          3
          /* State.HT */
        ],
        [
          2,
          84,
          3
          /* State.HT */
        ],
        [
          3,
          116,
          4
          /* State.HTT */
        ],
        [
          3,
          84,
          4
          /* State.HTT */
        ],
        [
          4,
          112,
          5
          /* State.HTTP */
        ],
        [
          4,
          80,
          5
          /* State.HTTP */
        ],
        [
          5,
          115,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          83,
          9
          /* State.BeforeColon */
        ],
        [
          5,
          58,
          10
          /* State.AfterColon */
        ],
        [
          6,
          105,
          7
          /* State.FI */
        ],
        [
          6,
          73,
          7
          /* State.FI */
        ],
        [
          7,
          108,
          8
          /* State.FIL */
        ],
        [
          7,
          76,
          8
          /* State.FIL */
        ],
        [
          8,
          101,
          9
          /* State.BeforeColon */
        ],
        [
          8,
          69,
          9
          /* State.BeforeColon */
        ],
        [
          9,
          58,
          10
          /* State.AfterColon */
        ],
        [
          10,
          47,
          11
          /* State.AlmostThere */
        ],
        [
          11,
          47,
          12
          /* State.End */
        ]
      ]);
    }
    return _stateMachine;
  }
  var _classifier = null;
  function getClassifier() {
    if (_classifier === null) {
      _classifier = new CharacterClassifier(
        0
        /* CharacterClass.None */
      );
      const FORCE_TERMINATION_CHARACTERS = ` 	<>'"\u3001\u3002\uFF61\uFF64\uFF0C\uFF0E\uFF1A\uFF1B\u2018\u3008\u300C\u300E\u3014\uFF08\uFF3B\uFF5B\uFF62\uFF63\uFF5D\uFF3D\uFF09\u3015\u300F\u300D\u3009\u2019\uFF40\uFF5E\u2026`;
      for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
        _classifier.set(
          FORCE_TERMINATION_CHARACTERS.charCodeAt(i),
          1
          /* CharacterClass.ForceTermination */
        );
      }
      const CANNOT_END_WITH_CHARACTERS = ".,;:";
      for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
        _classifier.set(
          CANNOT_END_WITH_CHARACTERS.charCodeAt(i),
          2
          /* CharacterClass.CannotEndIn */
        );
      }
    }
    return _classifier;
  }
  var LinkComputer = class _LinkComputer {
    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
      let lastIncludedCharIndex = linkEndIndex - 1;
      do {
        const chCode = line.charCodeAt(lastIncludedCharIndex);
        const chClass = classifier.get(chCode);
        if (chClass !== 2) {
          break;
        }
        lastIncludedCharIndex--;
      } while (lastIncludedCharIndex > linkBeginIndex);
      if (linkBeginIndex > 0) {
        const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
        const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
        if (charCodeBeforeLink === 40 && lastCharCodeInLink === 41 || charCodeBeforeLink === 91 && lastCharCodeInLink === 93 || charCodeBeforeLink === 123 && lastCharCodeInLink === 125) {
          lastIncludedCharIndex--;
        }
      }
      return {
        range: {
          startLineNumber: lineNumber,
          startColumn: linkBeginIndex + 1,
          endLineNumber: lineNumber,
          endColumn: lastIncludedCharIndex + 2
        },
        url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
      };
    }
    static computeLinks(model, stateMachine = getStateMachine()) {
      const classifier = getClassifier();
      const result = [];
      for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
        const line = model.getLineContent(i);
        const len = line.length;
        let j = 0;
        let linkBeginIndex = 0;
        let linkBeginChCode = 0;
        let state = 1;
        let hasOpenParens = false;
        let hasOpenSquareBracket = false;
        let inSquareBrackets = false;
        let hasOpenCurlyBracket = false;
        while (j < len) {
          let resetStateMachine = false;
          const chCode = line.charCodeAt(j);
          if (state === 13) {
            let chClass;
            switch (chCode) {
              case 40:
                hasOpenParens = true;
                chClass = 0;
                break;
              case 41:
                chClass = hasOpenParens ? 0 : 1;
                break;
              case 91:
                inSquareBrackets = true;
                hasOpenSquareBracket = true;
                chClass = 0;
                break;
              case 93:
                inSquareBrackets = false;
                chClass = hasOpenSquareBracket ? 0 : 1;
                break;
              case 123:
                hasOpenCurlyBracket = true;
                chClass = 0;
                break;
              case 125:
                chClass = hasOpenCurlyBracket ? 0 : 1;
                break;
              case 39:
              case 34:
              case 96:
                if (linkBeginChCode === chCode) {
                  chClass = 1;
                } else if (linkBeginChCode === 39 || linkBeginChCode === 34 || linkBeginChCode === 96) {
                  chClass = 0;
                } else {
                  chClass = 1;
                }
                break;
              case 42:
                chClass = linkBeginChCode === 42 ? 1 : 0;
                break;
              case 124:
                chClass = linkBeginChCode === 124 ? 1 : 0;
                break;
              case 32:
                chClass = inSquareBrackets ? 0 : 1;
                break;
              default:
                chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
              resetStateMachine = true;
            }
          } else if (state === 12) {
            let chClass;
            if (chCode === 91) {
              hasOpenSquareBracket = true;
              chClass = 0;
            } else {
              chClass = classifier.get(chCode);
            }
            if (chClass === 1) {
              resetStateMachine = true;
            } else {
              state = 13;
            }
          } else {
            state = stateMachine.nextState(state, chCode);
            if (state === 0) {
              resetStateMachine = true;
            }
          }
          if (resetStateMachine) {
            state = 1;
            hasOpenParens = false;
            hasOpenSquareBracket = false;
            hasOpenCurlyBracket = false;
            linkBeginIndex = j + 1;
            linkBeginChCode = chCode;
          }
          j++;
        }
        if (state === 13) {
          result.push(_LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
        }
      }
      return result;
    }
  };
  function computeLinks(model) {
    if (!model || typeof model.getLineCount !== "function" || typeof model.getLineContent !== "function") {
      return [];
    }
    return LinkComputer.computeLinks(model);
  }

  // node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js
  var BasicInplaceReplace = class {
    constructor() {
      this._defaultValueSet = [
        ["true", "false"],
        ["True", "False"],
        ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
        ["public", "protected", "private"]
      ];
    }
    navigateValueSet(range1, text1, range2, text2, up) {
      if (range1 && text1) {
        const result = this.doNavigateValueSet(text1, up);
        if (result) {
          return {
            range: range1,
            value: result
          };
        }
      }
      if (range2 && text2) {
        const result = this.doNavigateValueSet(text2, up);
        if (result) {
          return {
            range: range2,
            value: result
          };
        }
      }
      return null;
    }
    doNavigateValueSet(text, up) {
      const numberResult = this.numberReplace(text, up);
      if (numberResult !== null) {
        return numberResult;
      }
      return this.textReplace(text, up);
    }
    numberReplace(value, up) {
      const precision = Math.pow(10, value.length - (value.lastIndexOf(".") + 1));
      let n1 = Number(value);
      const n2 = parseFloat(value);
      if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
        if (n1 === 0 && !up) {
          return null;
        } else {
          n1 = Math.floor(n1 * precision);
          n1 += up ? precision : -precision;
          return String(n1 / precision);
        }
      }
      return null;
    }
    textReplace(value, up) {
      return this.valueSetsReplace(this._defaultValueSet, value, up);
    }
    valueSetsReplace(valueSets, value, up) {
      let result = null;
      for (let i = 0, len = valueSets.length; result === null && i < len; i++) {
        result = this.valueSetReplace(valueSets[i], value, up);
      }
      return result;
    }
    valueSetReplace(valueSet, value, up) {
      let idx = valueSet.indexOf(value);
      if (idx >= 0) {
        idx += up ? 1 : -1;
        if (idx < 0) {
          idx = valueSet.length - 1;
        } else {
          idx %= valueSet.length;
        }
        return valueSet[idx];
      }
      return null;
    }
  };
  BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();

  // node_modules/monaco-editor/esm/vs/base/common/cancellation.js
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle = setTimeout(callback.bind(context), 0);
    return { dispose() {
      clearTimeout(handle);
    } };
  });
  var CancellationToken;
  (function(CancellationToken2) {
    function isCancellationToken(thing) {
      if (thing === CancellationToken2.None || thing === CancellationToken2.Cancelled) {
        return true;
      }
      if (thing instanceof MutableToken) {
        return true;
      }
      if (!thing || typeof thing !== "object") {
        return false;
      }
      return typeof thing.isCancellationRequested === "boolean" && typeof thing.onCancellationRequested === "function";
    }
    CancellationToken2.isCancellationToken = isCancellationToken;
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: shortcutEvent
    });
  })(CancellationToken || (CancellationToken = {}));
  var MutableToken = class {
    constructor() {
      this._isCancelled = false;
      this._emitter = null;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(void 0);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new Emitter();
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = null;
      }
    }
  };
  var CancellationTokenSource = class {
    constructor(parent) {
      this._token = void 0;
      this._parentListener = void 0;
      this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    get token() {
      if (!this._token) {
        this._token = new MutableToken();
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else if (this._token instanceof MutableToken) {
        this._token.cancel();
      }
    }
    dispose(cancel = false) {
      var _a3;
      if (cancel) {
        this.cancel();
      }
      (_a3 = this._parentListener) === null || _a3 === void 0 ? void 0 : _a3.dispose();
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
  var KeyCodeStrMap = class {
    constructor() {
      this._keyCodeToStr = [];
      this._strToKeyCode = /* @__PURE__ */ Object.create(null);
    }
    define(keyCode, str) {
      this._keyCodeToStr[keyCode] = str;
      this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
      return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
      return this._strToKeyCode[str.toLowerCase()] || 0;
    }
  };
  var uiMap = new KeyCodeStrMap();
  var userSettingsUSMap = new KeyCodeStrMap();
  var userSettingsGeneralMap = new KeyCodeStrMap();
  var EVENT_KEY_CODE_MAP = new Array(230);
  var NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};
  var scanCodeIntToStr = [];
  var scanCodeStrToInt = /* @__PURE__ */ Object.create(null);
  var scanCodeLowerCaseStrToInt = /* @__PURE__ */ Object.create(null);
  var IMMUTABLE_CODE_TO_KEY_CODE = [];
  var IMMUTABLE_KEY_CODE_TO_CODE = [];
  for (let i = 0; i <= 193; i++) {
    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
  }
  for (let i = 0; i <= 132; i++) {
    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
  }
  (function() {
    const empty = "";
    const mappings = [
      // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
      [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", empty, empty],
      [1, 1, "Hyper", 0, empty, 0, empty, empty, empty],
      [1, 2, "Super", 0, empty, 0, empty, empty, empty],
      [1, 3, "Fn", 0, empty, 0, empty, empty, empty],
      [1, 4, "FnLock", 0, empty, 0, empty, empty, empty],
      [1, 5, "Suspend", 0, empty, 0, empty, empty, empty],
      [1, 6, "Resume", 0, empty, 0, empty, empty, empty],
      [1, 7, "Turbo", 0, empty, 0, empty, empty, empty],
      [1, 8, "Sleep", 0, empty, 0, "VK_SLEEP", empty, empty],
      [1, 9, "WakeUp", 0, empty, 0, empty, empty, empty],
      [0, 10, "KeyA", 31, "A", 65, "VK_A", empty, empty],
      [0, 11, "KeyB", 32, "B", 66, "VK_B", empty, empty],
      [0, 12, "KeyC", 33, "C", 67, "VK_C", empty, empty],
      [0, 13, "KeyD", 34, "D", 68, "VK_D", empty, empty],
      [0, 14, "KeyE", 35, "E", 69, "VK_E", empty, empty],
      [0, 15, "KeyF", 36, "F", 70, "VK_F", empty, empty],
      [0, 16, "KeyG", 37, "G", 71, "VK_G", empty, empty],
      [0, 17, "KeyH", 38, "H", 72, "VK_H", empty, empty],
      [0, 18, "KeyI", 39, "I", 73, "VK_I", empty, empty],
      [0, 19, "KeyJ", 40, "J", 74, "VK_J", empty, empty],
      [0, 20, "KeyK", 41, "K", 75, "VK_K", empty, empty],
      [0, 21, "KeyL", 42, "L", 76, "VK_L", empty, empty],
      [0, 22, "KeyM", 43, "M", 77, "VK_M", empty, empty],
      [0, 23, "KeyN", 44, "N", 78, "VK_N", empty, empty],
      [0, 24, "KeyO", 45, "O", 79, "VK_O", empty, empty],
      [0, 25, "KeyP", 46, "P", 80, "VK_P", empty, empty],
      [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", empty, empty],
      [0, 27, "KeyR", 48, "R", 82, "VK_R", empty, empty],
      [0, 28, "KeyS", 49, "S", 83, "VK_S", empty, empty],
      [0, 29, "KeyT", 50, "T", 84, "VK_T", empty, empty],
      [0, 30, "KeyU", 51, "U", 85, "VK_U", empty, empty],
      [0, 31, "KeyV", 52, "V", 86, "VK_V", empty, empty],
      [0, 32, "KeyW", 53, "W", 87, "VK_W", empty, empty],
      [0, 33, "KeyX", 54, "X", 88, "VK_X", empty, empty],
      [0, 34, "KeyY", 55, "Y", 89, "VK_Y", empty, empty],
      [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", empty, empty],
      [0, 36, "Digit1", 22, "1", 49, "VK_1", empty, empty],
      [0, 37, "Digit2", 23, "2", 50, "VK_2", empty, empty],
      [0, 38, "Digit3", 24, "3", 51, "VK_3", empty, empty],
      [0, 39, "Digit4", 25, "4", 52, "VK_4", empty, empty],
      [0, 40, "Digit5", 26, "5", 53, "VK_5", empty, empty],
      [0, 41, "Digit6", 27, "6", 54, "VK_6", empty, empty],
      [0, 42, "Digit7", 28, "7", 55, "VK_7", empty, empty],
      [0, 43, "Digit8", 29, "8", 56, "VK_8", empty, empty],
      [0, 44, "Digit9", 30, "9", 57, "VK_9", empty, empty],
      [0, 45, "Digit0", 21, "0", 48, "VK_0", empty, empty],
      [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", empty, empty],
      [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", empty, empty],
      [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", empty, empty],
      [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", empty, empty],
      [1, 50, "Space", 10, "Space", 32, "VK_SPACE", empty, empty],
      [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
      [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
      [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
      [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
      [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
      [0, 56, "IntlHash", 0, empty, 0, empty, empty, empty],
      [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
      [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
      [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
      [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
      [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
      [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
      [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", empty, empty],
      [1, 64, "F1", 59, "F1", 112, "VK_F1", empty, empty],
      [1, 65, "F2", 60, "F2", 113, "VK_F2", empty, empty],
      [1, 66, "F3", 61, "F3", 114, "VK_F3", empty, empty],
      [1, 67, "F4", 62, "F4", 115, "VK_F4", empty, empty],
      [1, 68, "F5", 63, "F5", 116, "VK_F5", empty, empty],
      [1, 69, "F6", 64, "F6", 117, "VK_F6", empty, empty],
      [1, 70, "F7", 65, "F7", 118, "VK_F7", empty, empty],
      [1, 71, "F8", 66, "F8", 119, "VK_F8", empty, empty],
      [1, 72, "F9", 67, "F9", 120, "VK_F9", empty, empty],
      [1, 73, "F10", 68, "F10", 121, "VK_F10", empty, empty],
      [1, 74, "F11", 69, "F11", 122, "VK_F11", empty, empty],
      [1, 75, "F12", 70, "F12", 123, "VK_F12", empty, empty],
      [1, 76, "PrintScreen", 0, empty, 0, empty, empty, empty],
      [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", empty, empty],
      [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", empty, empty],
      [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", empty, empty],
      [1, 80, "Home", 14, "Home", 36, "VK_HOME", empty, empty],
      [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", empty, empty],
      [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", empty, empty],
      [1, 83, "End", 13, "End", 35, "VK_END", empty, empty],
      [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", empty, empty],
      [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", empty],
      [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", empty],
      [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", empty],
      [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", empty],
      [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", empty, empty],
      [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", empty, empty],
      [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", empty, empty],
      [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", empty, empty],
      [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", empty, empty],
      [1, 94, "NumpadEnter", 3, empty, 0, empty, empty, empty],
      [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", empty, empty],
      [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", empty, empty],
      [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", empty, empty],
      [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", empty, empty],
      [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", empty, empty],
      [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", empty, empty],
      [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", empty, empty],
      [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", empty, empty],
      [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", empty, empty],
      [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", empty, empty],
      [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", empty, empty],
      [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", empty, empty],
      [1, 107, "ContextMenu", 58, "ContextMenu", 93, empty, empty, empty],
      [1, 108, "Power", 0, empty, 0, empty, empty, empty],
      [1, 109, "NumpadEqual", 0, empty, 0, empty, empty, empty],
      [1, 110, "F13", 71, "F13", 124, "VK_F13", empty, empty],
      [1, 111, "F14", 72, "F14", 125, "VK_F14", empty, empty],
      [1, 112, "F15", 73, "F15", 126, "VK_F15", empty, empty],
      [1, 113, "F16", 74, "F16", 127, "VK_F16", empty, empty],
      [1, 114, "F17", 75, "F17", 128, "VK_F17", empty, empty],
      [1, 115, "F18", 76, "F18", 129, "VK_F18", empty, empty],
      [1, 116, "F19", 77, "F19", 130, "VK_F19", empty, empty],
      [1, 117, "F20", 78, "F20", 131, "VK_F20", empty, empty],
      [1, 118, "F21", 79, "F21", 132, "VK_F21", empty, empty],
      [1, 119, "F22", 80, "F22", 133, "VK_F22", empty, empty],
      [1, 120, "F23", 81, "F23", 134, "VK_F23", empty, empty],
      [1, 121, "F24", 82, "F24", 135, "VK_F24", empty, empty],
      [1, 122, "Open", 0, empty, 0, empty, empty, empty],
      [1, 123, "Help", 0, empty, 0, empty, empty, empty],
      [1, 124, "Select", 0, empty, 0, empty, empty, empty],
      [1, 125, "Again", 0, empty, 0, empty, empty, empty],
      [1, 126, "Undo", 0, empty, 0, empty, empty, empty],
      [1, 127, "Cut", 0, empty, 0, empty, empty, empty],
      [1, 128, "Copy", 0, empty, 0, empty, empty, empty],
      [1, 129, "Paste", 0, empty, 0, empty, empty, empty],
      [1, 130, "Find", 0, empty, 0, empty, empty, empty],
      [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", empty, empty],
      [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", empty, empty],
      [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", empty, empty],
      [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", empty, empty],
      [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", empty, empty],
      [1, 136, "KanaMode", 0, empty, 0, empty, empty, empty],
      [0, 137, "IntlYen", 0, empty, 0, empty, empty, empty],
      [1, 138, "Convert", 0, empty, 0, empty, empty, empty],
      [1, 139, "NonConvert", 0, empty, 0, empty, empty, empty],
      [1, 140, "Lang1", 0, empty, 0, empty, empty, empty],
      [1, 141, "Lang2", 0, empty, 0, empty, empty, empty],
      [1, 142, "Lang3", 0, empty, 0, empty, empty, empty],
      [1, 143, "Lang4", 0, empty, 0, empty, empty, empty],
      [1, 144, "Lang5", 0, empty, 0, empty, empty, empty],
      [1, 145, "Abort", 0, empty, 0, empty, empty, empty],
      [1, 146, "Props", 0, empty, 0, empty, empty, empty],
      [1, 147, "NumpadParenLeft", 0, empty, 0, empty, empty, empty],
      [1, 148, "NumpadParenRight", 0, empty, 0, empty, empty, empty],
      [1, 149, "NumpadBackspace", 0, empty, 0, empty, empty, empty],
      [1, 150, "NumpadMemoryStore", 0, empty, 0, empty, empty, empty],
      [1, 151, "NumpadMemoryRecall", 0, empty, 0, empty, empty, empty],
      [1, 152, "NumpadMemoryClear", 0, empty, 0, empty, empty, empty],
      [1, 153, "NumpadMemoryAdd", 0, empty, 0, empty, empty, empty],
      [1, 154, "NumpadMemorySubtract", 0, empty, 0, empty, empty, empty],
      [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", empty, empty],
      [1, 156, "NumpadClearEntry", 0, empty, 0, empty, empty, empty],
      [1, 0, empty, 5, "Ctrl", 17, "VK_CONTROL", empty, empty],
      [1, 0, empty, 4, "Shift", 16, "VK_SHIFT", empty, empty],
      [1, 0, empty, 6, "Alt", 18, "VK_MENU", empty, empty],
      [1, 0, empty, 57, "Meta", 91, "VK_COMMAND", empty, empty],
      [1, 157, "ControlLeft", 5, empty, 0, "VK_LCONTROL", empty, empty],
      [1, 158, "ShiftLeft", 4, empty, 0, "VK_LSHIFT", empty, empty],
      [1, 159, "AltLeft", 6, empty, 0, "VK_LMENU", empty, empty],
      [1, 160, "MetaLeft", 57, empty, 0, "VK_LWIN", empty, empty],
      [1, 161, "ControlRight", 5, empty, 0, "VK_RCONTROL", empty, empty],
      [1, 162, "ShiftRight", 4, empty, 0, "VK_RSHIFT", empty, empty],
      [1, 163, "AltRight", 6, empty, 0, "VK_RMENU", empty, empty],
      [1, 164, "MetaRight", 57, empty, 0, "VK_RWIN", empty, empty],
      [1, 165, "BrightnessUp", 0, empty, 0, empty, empty, empty],
      [1, 166, "BrightnessDown", 0, empty, 0, empty, empty, empty],
      [1, 167, "MediaPlay", 0, empty, 0, empty, empty, empty],
      [1, 168, "MediaRecord", 0, empty, 0, empty, empty, empty],
      [1, 169, "MediaFastForward", 0, empty, 0, empty, empty, empty],
      [1, 170, "MediaRewind", 0, empty, 0, empty, empty, empty],
      [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", empty, empty],
      [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", empty, empty],
      [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", empty, empty],
      [1, 174, "Eject", 0, empty, 0, empty, empty, empty],
      [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", empty, empty],
      [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", empty, empty],
      [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", empty, empty],
      [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", empty, empty],
      [1, 179, "LaunchApp1", 0, empty, 0, "VK_MEDIA_LAUNCH_APP1", empty, empty],
      [1, 180, "SelectTask", 0, empty, 0, empty, empty, empty],
      [1, 181, "LaunchScreenSaver", 0, empty, 0, empty, empty, empty],
      [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", empty, empty],
      [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", empty, empty],
      [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", empty, empty],
      [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", empty, empty],
      [1, 186, "BrowserStop", 0, empty, 0, "VK_BROWSER_STOP", empty, empty],
      [1, 187, "BrowserRefresh", 0, empty, 0, "VK_BROWSER_REFRESH", empty, empty],
      [1, 188, "BrowserFavorites", 0, empty, 0, "VK_BROWSER_FAVORITES", empty, empty],
      [1, 189, "ZoomToggle", 0, empty, 0, empty, empty, empty],
      [1, 190, "MailReply", 0, empty, 0, empty, empty, empty],
      [1, 191, "MailForward", 0, empty, 0, empty, empty, empty],
      [1, 192, "MailSend", 0, empty, 0, empty, empty, empty],
      // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
      // If an Input Method Editor is processing key input and the event is keydown, return 229.
      [1, 0, empty, 114, "KeyInComposition", 229, empty, empty, empty],
      [1, 0, empty, 116, "ABNT_C2", 194, "VK_ABNT_C2", empty, empty],
      [1, 0, empty, 96, "OEM_8", 223, "VK_OEM_8", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANGUL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_JUNJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_FINAL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HANJA", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_KANJI", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONCONVERT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ACCEPT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_MODECHANGE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SELECT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PRINT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXECUTE", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_SNAPSHOT", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_HELP", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_APPS", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PROCESSKEY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PACKET", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_SBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_DBE_DBCSCHAR", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ATTN", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_CRSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EXSEL", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_EREOF", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PLAY", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_ZOOM", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_NONAME", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_PA1", empty, empty],
      [1, 0, empty, 0, empty, 0, "VK_OEM_CLEAR", empty, empty]
    ];
    const seenKeyCode = [];
    const seenScanCode = [];
    for (const mapping of mappings) {
      const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
      if (!seenScanCode[scanCode]) {
        seenScanCode[scanCode] = true;
        scanCodeIntToStr[scanCode] = scanCodeStr;
        scanCodeStrToInt[scanCodeStr] = scanCode;
        scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
        if (immutable) {
          IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;
          if (keyCode !== 0 && keyCode !== 3 && keyCode !== 5 && keyCode !== 4 && keyCode !== 6 && keyCode !== 57) {
            IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;
          }
        }
      }
      if (!seenKeyCode[keyCode]) {
        seenKeyCode[keyCode] = true;
        if (!keyCodeStr) {
          throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
        }
        uiMap.define(keyCode, keyCodeStr);
        userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
      }
      if (eventKeyCode) {
        EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
      }
      if (vkey) {
        NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;
      }
    }
    IMMUTABLE_KEY_CODE_TO_CODE[
      3
      /* KeyCode.Enter */
    ] = 46;
  })();
  var KeyCodeUtils;
  (function(KeyCodeUtils2) {
    function toString(keyCode) {
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toString = toString;
    function fromString(key) {
      return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromString = fromString;
    function toUserSettingsUS(keyCode) {
      return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
      return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
      return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils2.fromUserSettings = fromUserSettings;
    function toElectronAccelerator(keyCode) {
      if (keyCode >= 98 && keyCode <= 113) {
        return null;
      }
      switch (keyCode) {
        case 16:
          return "Up";
        case 18:
          return "Down";
        case 15:
          return "Left";
        case 17:
          return "Right";
      }
      return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils2.toElectronAccelerator = toElectronAccelerator;
  })(KeyCodeUtils || (KeyCodeUtils = {}));
  function KeyChord(firstPart, secondPart) {
    const chordPart = (secondPart & 65535) << 16 >>> 0;
    return (firstPart | chordPart) >>> 0;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
  var Selection = class _Selection extends Range {
    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
      super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
      this.selectionStartLineNumber = selectionStartLineNumber;
      this.selectionStartColumn = selectionStartColumn;
      this.positionLineNumber = positionLineNumber;
      this.positionColumn = positionColumn;
    }
    /**
     * Transform to a human-readable representation.
     */
    toString() {
      return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
    }
    /**
     * Test if equals other selection.
     */
    equalsSelection(other) {
      return _Selection.selectionsEqual(this, other);
    }
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a2, b) {
      return a2.selectionStartLineNumber === b.selectionStartLineNumber && a2.selectionStartColumn === b.selectionStartColumn && a2.positionLineNumber === b.positionLineNumber && a2.positionColumn === b.positionColumn;
    }
    /**
     * Get directions (LTR or RTL).
     */
    getDirection() {
      if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
        return 0;
      }
      return 1;
    }
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber, endColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    }
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition() {
      return new Position(this.positionLineNumber, this.positionColumn);
    }
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart() {
      return new Position(this.selectionStartLineNumber, this.selectionStartColumn);
    }
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber, startColumn) {
      if (this.getDirection() === 0) {
        return new _Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
      }
      return new _Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    }
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start, end = start) {
      return new _Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    }
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range, direction) {
      if (direction === 0) {
        return new _Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
      } else {
        return new _Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
      }
    }
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel) {
      return new _Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    }
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a2, b) {
      if (a2 && !b || !a2 && b) {
        return false;
      }
      if (!a2 && !b) {
        return true;
      }
      if (a2.length !== b.length) {
        return false;
      }
      for (let i = 0, len = a2.length; i < len; i++) {
        if (!this.selectionsEqual(a2[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj) {
      return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
    }
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
      if (direction === 0) {
        return new _Selection(startLineNumber, startColumn, endLineNumber, endColumn);
      }
      return new _Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/codicons.js
  var _codiconFontCharacters = /* @__PURE__ */ Object.create(null);
  function register(id, fontCharacter) {
    if (isString(fontCharacter)) {
      const val = _codiconFontCharacters[fontCharacter];
      if (val === void 0) {
        throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);
      }
      fontCharacter = val;
    }
    _codiconFontCharacters[id] = fontCharacter;
    return { id };
  }
  var Codicon = {
    // built-in icons, with image name
    add: register("add", 6e4),
    plus: register("plus", 6e4),
    gistNew: register("gist-new", 6e4),
    repoCreate: register("repo-create", 6e4),
    lightbulb: register("lightbulb", 60001),
    lightBulb: register("light-bulb", 60001),
    repo: register("repo", 60002),
    repoDelete: register("repo-delete", 60002),
    gistFork: register("gist-fork", 60003),
    repoForked: register("repo-forked", 60003),
    gitPullRequest: register("git-pull-request", 60004),
    gitPullRequestAbandoned: register("git-pull-request-abandoned", 60004),
    recordKeys: register("record-keys", 60005),
    keyboard: register("keyboard", 60005),
    tag: register("tag", 60006),
    tagAdd: register("tag-add", 60006),
    tagRemove: register("tag-remove", 60006),
    person: register("person", 60007),
    personFollow: register("person-follow", 60007),
    personOutline: register("person-outline", 60007),
    personFilled: register("person-filled", 60007),
    gitBranch: register("git-branch", 60008),
    gitBranchCreate: register("git-branch-create", 60008),
    gitBranchDelete: register("git-branch-delete", 60008),
    sourceControl: register("source-control", 60008),
    mirror: register("mirror", 60009),
    mirrorPublic: register("mirror-public", 60009),
    star: register("star", 60010),
    starAdd: register("star-add", 60010),
    starDelete: register("star-delete", 60010),
    starEmpty: register("star-empty", 60010),
    comment: register("comment", 60011),
    commentAdd: register("comment-add", 60011),
    alert: register("alert", 60012),
    warning: register("warning", 60012),
    search: register("search", 60013),
    searchSave: register("search-save", 60013),
    logOut: register("log-out", 60014),
    signOut: register("sign-out", 60014),
    logIn: register("log-in", 60015),
    signIn: register("sign-in", 60015),
    eye: register("eye", 60016),
    eyeUnwatch: register("eye-unwatch", 60016),
    eyeWatch: register("eye-watch", 60016),
    circleFilled: register("circle-filled", 60017),
    primitiveDot: register("primitive-dot", 60017),
    closeDirty: register("close-dirty", 60017),
    debugBreakpoint: register("debug-breakpoint", 60017),
    debugBreakpointDisabled: register("debug-breakpoint-disabled", 60017),
    debugHint: register("debug-hint", 60017),
    primitiveSquare: register("primitive-square", 60018),
    edit: register("edit", 60019),
    pencil: register("pencil", 60019),
    info: register("info", 60020),
    issueOpened: register("issue-opened", 60020),
    gistPrivate: register("gist-private", 60021),
    gitForkPrivate: register("git-fork-private", 60021),
    lock: register("lock", 60021),
    mirrorPrivate: register("mirror-private", 60021),
    close: register("close", 60022),
    removeClose: register("remove-close", 60022),
    x: register("x", 60022),
    repoSync: register("repo-sync", 60023),
    sync: register("sync", 60023),
    clone: register("clone", 60024),
    desktopDownload: register("desktop-download", 60024),
    beaker: register("beaker", 60025),
    microscope: register("microscope", 60025),
    vm: register("vm", 60026),
    deviceDesktop: register("device-desktop", 60026),
    file: register("file", 60027),
    fileText: register("file-text", 60027),
    more: register("more", 60028),
    ellipsis: register("ellipsis", 60028),
    kebabHorizontal: register("kebab-horizontal", 60028),
    mailReply: register("mail-reply", 60029),
    reply: register("reply", 60029),
    organization: register("organization", 60030),
    organizationFilled: register("organization-filled", 60030),
    organizationOutline: register("organization-outline", 60030),
    newFile: register("new-file", 60031),
    fileAdd: register("file-add", 60031),
    newFolder: register("new-folder", 60032),
    fileDirectoryCreate: register("file-directory-create", 60032),
    trash: register("trash", 60033),
    trashcan: register("trashcan", 60033),
    history: register("history", 60034),
    clock: register("clock", 60034),
    folder: register("folder", 60035),
    fileDirectory: register("file-directory", 60035),
    symbolFolder: register("symbol-folder", 60035),
    logoGithub: register("logo-github", 60036),
    markGithub: register("mark-github", 60036),
    github: register("github", 60036),
    terminal: register("terminal", 60037),
    console: register("console", 60037),
    repl: register("repl", 60037),
    zap: register("zap", 60038),
    symbolEvent: register("symbol-event", 60038),
    error: register("error", 60039),
    stop: register("stop", 60039),
    variable: register("variable", 60040),
    symbolVariable: register("symbol-variable", 60040),
    array: register("array", 60042),
    symbolArray: register("symbol-array", 60042),
    symbolModule: register("symbol-module", 60043),
    symbolPackage: register("symbol-package", 60043),
    symbolNamespace: register("symbol-namespace", 60043),
    symbolObject: register("symbol-object", 60043),
    symbolMethod: register("symbol-method", 60044),
    symbolFunction: register("symbol-function", 60044),
    symbolConstructor: register("symbol-constructor", 60044),
    symbolBoolean: register("symbol-boolean", 60047),
    symbolNull: register("symbol-null", 60047),
    symbolNumeric: register("symbol-numeric", 60048),
    symbolNumber: register("symbol-number", 60048),
    symbolStructure: register("symbol-structure", 60049),
    symbolStruct: register("symbol-struct", 60049),
    symbolParameter: register("symbol-parameter", 60050),
    symbolTypeParameter: register("symbol-type-parameter", 60050),
    symbolKey: register("symbol-key", 60051),
    symbolText: register("symbol-text", 60051),
    symbolReference: register("symbol-reference", 60052),
    goToFile: register("go-to-file", 60052),
    symbolEnum: register("symbol-enum", 60053),
    symbolValue: register("symbol-value", 60053),
    symbolRuler: register("symbol-ruler", 60054),
    symbolUnit: register("symbol-unit", 60054),
    activateBreakpoints: register("activate-breakpoints", 60055),
    archive: register("archive", 60056),
    arrowBoth: register("arrow-both", 60057),
    arrowDown: register("arrow-down", 60058),
    arrowLeft: register("arrow-left", 60059),
    arrowRight: register("arrow-right", 60060),
    arrowSmallDown: register("arrow-small-down", 60061),
    arrowSmallLeft: register("arrow-small-left", 60062),
    arrowSmallRight: register("arrow-small-right", 60063),
    arrowSmallUp: register("arrow-small-up", 60064),
    arrowUp: register("arrow-up", 60065),
    bell: register("bell", 60066),
    bold: register("bold", 60067),
    book: register("book", 60068),
    bookmark: register("bookmark", 60069),
    debugBreakpointConditionalUnverified: register("debug-breakpoint-conditional-unverified", 60070),
    debugBreakpointConditional: register("debug-breakpoint-conditional", 60071),
    debugBreakpointConditionalDisabled: register("debug-breakpoint-conditional-disabled", 60071),
    debugBreakpointDataUnverified: register("debug-breakpoint-data-unverified", 60072),
    debugBreakpointData: register("debug-breakpoint-data", 60073),
    debugBreakpointDataDisabled: register("debug-breakpoint-data-disabled", 60073),
    debugBreakpointLogUnverified: register("debug-breakpoint-log-unverified", 60074),
    debugBreakpointLog: register("debug-breakpoint-log", 60075),
    debugBreakpointLogDisabled: register("debug-breakpoint-log-disabled", 60075),
    briefcase: register("briefcase", 60076),
    broadcast: register("broadcast", 60077),
    browser: register("browser", 60078),
    bug: register("bug", 60079),
    calendar: register("calendar", 60080),
    caseSensitive: register("case-sensitive", 60081),
    check: register("check", 60082),
    checklist: register("checklist", 60083),
    chevronDown: register("chevron-down", 60084),
    dropDownButton: register("drop-down-button", 60084),
    chevronLeft: register("chevron-left", 60085),
    chevronRight: register("chevron-right", 60086),
    chevronUp: register("chevron-up", 60087),
    chromeClose: register("chrome-close", 60088),
    chromeMaximize: register("chrome-maximize", 60089),
    chromeMinimize: register("chrome-minimize", 60090),
    chromeRestore: register("chrome-restore", 60091),
    circle: register("circle", 60092),
    circleOutline: register("circle-outline", 60092),
    debugBreakpointUnverified: register("debug-breakpoint-unverified", 60092),
    circleSlash: register("circle-slash", 60093),
    circuitBoard: register("circuit-board", 60094),
    clearAll: register("clear-all", 60095),
    clippy: register("clippy", 60096),
    closeAll: register("close-all", 60097),
    cloudDownload: register("cloud-download", 60098),
    cloudUpload: register("cloud-upload", 60099),
    code: register("code", 60100),
    collapseAll: register("collapse-all", 60101),
    colorMode: register("color-mode", 60102),
    commentDiscussion: register("comment-discussion", 60103),
    compareChanges: register("compare-changes", 60157),
    creditCard: register("credit-card", 60105),
    dash: register("dash", 60108),
    dashboard: register("dashboard", 60109),
    database: register("database", 60110),
    debugContinue: register("debug-continue", 60111),
    debugDisconnect: register("debug-disconnect", 60112),
    debugPause: register("debug-pause", 60113),
    debugRestart: register("debug-restart", 60114),
    debugStart: register("debug-start", 60115),
    debugStepInto: register("debug-step-into", 60116),
    debugStepOut: register("debug-step-out", 60117),
    debugStepOver: register("debug-step-over", 60118),
    debugStop: register("debug-stop", 60119),
    debug: register("debug", 60120),
    deviceCameraVideo: register("device-camera-video", 60121),
    deviceCamera: register("device-camera", 60122),
    deviceMobile: register("device-mobile", 60123),
    diffAdded: register("diff-added", 60124),
    diffIgnored: register("diff-ignored", 60125),
    diffModified: register("diff-modified", 60126),
    diffRemoved: register("diff-removed", 60127),
    diffRenamed: register("diff-renamed", 60128),
    diff: register("diff", 60129),
    discard: register("discard", 60130),
    editorLayout: register("editor-layout", 60131),
    emptyWindow: register("empty-window", 60132),
    exclude: register("exclude", 60133),
    extensions: register("extensions", 60134),
    eyeClosed: register("eye-closed", 60135),
    fileBinary: register("file-binary", 60136),
    fileCode: register("file-code", 60137),
    fileMedia: register("file-media", 60138),
    filePdf: register("file-pdf", 60139),
    fileSubmodule: register("file-submodule", 60140),
    fileSymlinkDirectory: register("file-symlink-directory", 60141),
    fileSymlinkFile: register("file-symlink-file", 60142),
    fileZip: register("file-zip", 60143),
    files: register("files", 60144),
    filter: register("filter", 60145),
    flame: register("flame", 60146),
    foldDown: register("fold-down", 60147),
    foldUp: register("fold-up", 60148),
    fold: register("fold", 60149),
    folderActive: register("folder-active", 60150),
    folderOpened: register("folder-opened", 60151),
    gear: register("gear", 60152),
    gift: register("gift", 60153),
    gistSecret: register("gist-secret", 60154),
    gist: register("gist", 60155),
    gitCommit: register("git-commit", 60156),
    gitCompare: register("git-compare", 60157),
    gitMerge: register("git-merge", 60158),
    githubAction: register("github-action", 60159),
    githubAlt: register("github-alt", 60160),
    globe: register("globe", 60161),
    grabber: register("grabber", 60162),
    graph: register("graph", 60163),
    gripper: register("gripper", 60164),
    heart: register("heart", 60165),
    home: register("home", 60166),
    horizontalRule: register("horizontal-rule", 60167),
    hubot: register("hubot", 60168),
    inbox: register("inbox", 60169),
    issueClosed: register("issue-closed", 60324),
    issueReopened: register("issue-reopened", 60171),
    issues: register("issues", 60172),
    italic: register("italic", 60173),
    jersey: register("jersey", 60174),
    json: register("json", 60175),
    bracket: register("bracket", 60175),
    kebabVertical: register("kebab-vertical", 60176),
    key: register("key", 60177),
    law: register("law", 60178),
    lightbulbAutofix: register("lightbulb-autofix", 60179),
    linkExternal: register("link-external", 60180),
    link: register("link", 60181),
    listOrdered: register("list-ordered", 60182),
    listUnordered: register("list-unordered", 60183),
    liveShare: register("live-share", 60184),
    loading: register("loading", 60185),
    location: register("location", 60186),
    mailRead: register("mail-read", 60187),
    mail: register("mail", 60188),
    markdown: register("markdown", 60189),
    megaphone: register("megaphone", 60190),
    mention: register("mention", 60191),
    milestone: register("milestone", 60192),
    mortarBoard: register("mortar-board", 60193),
    move: register("move", 60194),
    multipleWindows: register("multiple-windows", 60195),
    mute: register("mute", 60196),
    noNewline: register("no-newline", 60197),
    note: register("note", 60198),
    octoface: register("octoface", 60199),
    openPreview: register("open-preview", 60200),
    package_: register("package", 60201),
    paintcan: register("paintcan", 60202),
    pin: register("pin", 60203),
    play: register("play", 60204),
    run: register("run", 60204),
    plug: register("plug", 60205),
    preserveCase: register("preserve-case", 60206),
    preview: register("preview", 60207),
    project: register("project", 60208),
    pulse: register("pulse", 60209),
    question: register("question", 60210),
    quote: register("quote", 60211),
    radioTower: register("radio-tower", 60212),
    reactions: register("reactions", 60213),
    references: register("references", 60214),
    refresh: register("refresh", 60215),
    regex: register("regex", 60216),
    remoteExplorer: register("remote-explorer", 60217),
    remote: register("remote", 60218),
    remove: register("remove", 60219),
    replaceAll: register("replace-all", 60220),
    replace: register("replace", 60221),
    repoClone: register("repo-clone", 60222),
    repoForcePush: register("repo-force-push", 60223),
    repoPull: register("repo-pull", 60224),
    repoPush: register("repo-push", 60225),
    report: register("report", 60226),
    requestChanges: register("request-changes", 60227),
    rocket: register("rocket", 60228),
    rootFolderOpened: register("root-folder-opened", 60229),
    rootFolder: register("root-folder", 60230),
    rss: register("rss", 60231),
    ruby: register("ruby", 60232),
    saveAll: register("save-all", 60233),
    saveAs: register("save-as", 60234),
    save: register("save", 60235),
    screenFull: register("screen-full", 60236),
    screenNormal: register("screen-normal", 60237),
    searchStop: register("search-stop", 60238),
    server: register("server", 60240),
    settingsGear: register("settings-gear", 60241),
    settings: register("settings", 60242),
    shield: register("shield", 60243),
    smiley: register("smiley", 60244),
    sortPrecedence: register("sort-precedence", 60245),
    splitHorizontal: register("split-horizontal", 60246),
    splitVertical: register("split-vertical", 60247),
    squirrel: register("squirrel", 60248),
    starFull: register("star-full", 60249),
    starHalf: register("star-half", 60250),
    symbolClass: register("symbol-class", 60251),
    symbolColor: register("symbol-color", 60252),
    symbolCustomColor: register("symbol-customcolor", 60252),
    symbolConstant: register("symbol-constant", 60253),
    symbolEnumMember: register("symbol-enum-member", 60254),
    symbolField: register("symbol-field", 60255),
    symbolFile: register("symbol-file", 60256),
    symbolInterface: register("symbol-interface", 60257),
    symbolKeyword: register("symbol-keyword", 60258),
    symbolMisc: register("symbol-misc", 60259),
    symbolOperator: register("symbol-operator", 60260),
    symbolProperty: register("symbol-property", 60261),
    wrench: register("wrench", 60261),
    wrenchSubaction: register("wrench-subaction", 60261),
    symbolSnippet: register("symbol-snippet", 60262),
    tasklist: register("tasklist", 60263),
    telescope: register("telescope", 60264),
    textSize: register("text-size", 60265),
    threeBars: register("three-bars", 60266),
    thumbsdown: register("thumbsdown", 60267),
    thumbsup: register("thumbsup", 60268),
    tools: register("tools", 60269),
    triangleDown: register("triangle-down", 60270),
    triangleLeft: register("triangle-left", 60271),
    triangleRight: register("triangle-right", 60272),
    triangleUp: register("triangle-up", 60273),
    twitter: register("twitter", 60274),
    unfold: register("unfold", 60275),
    unlock: register("unlock", 60276),
    unmute: register("unmute", 60277),
    unverified: register("unverified", 60278),
    verified: register("verified", 60279),
    versions: register("versions", 60280),
    vmActive: register("vm-active", 60281),
    vmOutline: register("vm-outline", 60282),
    vmRunning: register("vm-running", 60283),
    watch: register("watch", 60284),
    whitespace: register("whitespace", 60285),
    wholeWord: register("whole-word", 60286),
    window: register("window", 60287),
    wordWrap: register("word-wrap", 60288),
    zoomIn: register("zoom-in", 60289),
    zoomOut: register("zoom-out", 60290),
    listFilter: register("list-filter", 60291),
    listFlat: register("list-flat", 60292),
    listSelection: register("list-selection", 60293),
    selection: register("selection", 60293),
    listTree: register("list-tree", 60294),
    debugBreakpointFunctionUnverified: register("debug-breakpoint-function-unverified", 60295),
    debugBreakpointFunction: register("debug-breakpoint-function", 60296),
    debugBreakpointFunctionDisabled: register("debug-breakpoint-function-disabled", 60296),
    debugStackframeActive: register("debug-stackframe-active", 60297),
    circleSmallFilled: register("circle-small-filled", 60298),
    debugStackframeDot: register("debug-stackframe-dot", 60298),
    debugStackframe: register("debug-stackframe", 60299),
    debugStackframeFocused: register("debug-stackframe-focused", 60299),
    debugBreakpointUnsupported: register("debug-breakpoint-unsupported", 60300),
    symbolString: register("symbol-string", 60301),
    debugReverseContinue: register("debug-reverse-continue", 60302),
    debugStepBack: register("debug-step-back", 60303),
    debugRestartFrame: register("debug-restart-frame", 60304),
    callIncoming: register("call-incoming", 60306),
    callOutgoing: register("call-outgoing", 60307),
    menu: register("menu", 60308),
    expandAll: register("expand-all", 60309),
    feedback: register("feedback", 60310),
    groupByRefType: register("group-by-ref-type", 60311),
    ungroupByRefType: register("ungroup-by-ref-type", 60312),
    account: register("account", 60313),
    bellDot: register("bell-dot", 60314),
    debugConsole: register("debug-console", 60315),
    library: register("library", 60316),
    output: register("output", 60317),
    runAll: register("run-all", 60318),
    syncIgnored: register("sync-ignored", 60319),
    pinned: register("pinned", 60320),
    githubInverted: register("github-inverted", 60321),
    debugAlt: register("debug-alt", 60305),
    serverProcess: register("server-process", 60322),
    serverEnvironment: register("server-environment", 60323),
    pass: register("pass", 60324),
    stopCircle: register("stop-circle", 60325),
    playCircle: register("play-circle", 60326),
    record: register("record", 60327),
    debugAltSmall: register("debug-alt-small", 60328),
    vmConnect: register("vm-connect", 60329),
    cloud: register("cloud", 60330),
    merge: register("merge", 60331),
    exportIcon: register("export", 60332),
    graphLeft: register("graph-left", 60333),
    magnet: register("magnet", 60334),
    notebook: register("notebook", 60335),
    redo: register("redo", 60336),
    checkAll: register("check-all", 60337),
    pinnedDirty: register("pinned-dirty", 60338),
    passFilled: register("pass-filled", 60339),
    circleLargeFilled: register("circle-large-filled", 60340),
    circleLarge: register("circle-large", 60341),
    circleLargeOutline: register("circle-large-outline", 60341),
    combine: register("combine", 60342),
    gather: register("gather", 60342),
    table: register("table", 60343),
    variableGroup: register("variable-group", 60344),
    typeHierarchy: register("type-hierarchy", 60345),
    typeHierarchySub: register("type-hierarchy-sub", 60346),
    typeHierarchySuper: register("type-hierarchy-super", 60347),
    gitPullRequestCreate: register("git-pull-request-create", 60348),
    runAbove: register("run-above", 60349),
    runBelow: register("run-below", 60350),
    notebookTemplate: register("notebook-template", 60351),
    debugRerun: register("debug-rerun", 60352),
    workspaceTrusted: register("workspace-trusted", 60353),
    workspaceUntrusted: register("workspace-untrusted", 60354),
    workspaceUnspecified: register("workspace-unspecified", 60355),
    terminalCmd: register("terminal-cmd", 60356),
    terminalDebian: register("terminal-debian", 60357),
    terminalLinux: register("terminal-linux", 60358),
    terminalPowershell: register("terminal-powershell", 60359),
    terminalTmux: register("terminal-tmux", 60360),
    terminalUbuntu: register("terminal-ubuntu", 60361),
    terminalBash: register("terminal-bash", 60362),
    arrowSwap: register("arrow-swap", 60363),
    copy: register("copy", 60364),
    personAdd: register("person-add", 60365),
    filterFilled: register("filter-filled", 60366),
    wand: register("wand", 60367),
    debugLineByLine: register("debug-line-by-line", 60368),
    inspect: register("inspect", 60369),
    layers: register("layers", 60370),
    layersDot: register("layers-dot", 60371),
    layersActive: register("layers-active", 60372),
    compass: register("compass", 60373),
    compassDot: register("compass-dot", 60374),
    compassActive: register("compass-active", 60375),
    azure: register("azure", 60376),
    issueDraft: register("issue-draft", 60377),
    gitPullRequestClosed: register("git-pull-request-closed", 60378),
    gitPullRequestDraft: register("git-pull-request-draft", 60379),
    debugAll: register("debug-all", 60380),
    debugCoverage: register("debug-coverage", 60381),
    runErrors: register("run-errors", 60382),
    folderLibrary: register("folder-library", 60383),
    debugContinueSmall: register("debug-continue-small", 60384),
    beakerStop: register("beaker-stop", 60385),
    graphLine: register("graph-line", 60386),
    graphScatter: register("graph-scatter", 60387),
    pieChart: register("pie-chart", 60388),
    bracketDot: register("bracket-dot", 60389),
    bracketError: register("bracket-error", 60390),
    lockSmall: register("lock-small", 60391),
    azureDevops: register("azure-devops", 60392),
    verifiedFilled: register("verified-filled", 60393),
    newLine: register("newline", 60394),
    layout: register("layout", 60395),
    layoutActivitybarLeft: register("layout-activitybar-left", 60396),
    layoutActivitybarRight: register("layout-activitybar-right", 60397),
    layoutPanelLeft: register("layout-panel-left", 60398),
    layoutPanelCenter: register("layout-panel-center", 60399),
    layoutPanelJustify: register("layout-panel-justify", 60400),
    layoutPanelRight: register("layout-panel-right", 60401),
    layoutPanel: register("layout-panel", 60402),
    layoutSidebarLeft: register("layout-sidebar-left", 60403),
    layoutSidebarRight: register("layout-sidebar-right", 60404),
    layoutStatusbar: register("layout-statusbar", 60405),
    layoutMenubar: register("layout-menubar", 60406),
    layoutCentered: register("layout-centered", 60407),
    layoutSidebarRightOff: register("layout-sidebar-right-off", 60416),
    layoutPanelOff: register("layout-panel-off", 60417),
    layoutSidebarLeftOff: register("layout-sidebar-left-off", 60418),
    target: register("target", 60408),
    indent: register("indent", 60409),
    recordSmall: register("record-small", 60410),
    errorSmall: register("error-small", 60411),
    arrowCircleDown: register("arrow-circle-down", 60412),
    arrowCircleLeft: register("arrow-circle-left", 60413),
    arrowCircleRight: register("arrow-circle-right", 60414),
    arrowCircleUp: register("arrow-circle-up", 60415),
    heartFilled: register("heart-filled", 60420),
    map: register("map", 60421),
    mapFilled: register("map-filled", 60422),
    circleSmall: register("circle-small", 60423),
    bellSlash: register("bell-slash", 60424),
    bellSlashDot: register("bell-slash-dot", 60425),
    commentUnresolved: register("comment-unresolved", 60426),
    gitPullRequestGoToChanges: register("git-pull-request-go-to-changes", 60427),
    gitPullRequestNewChanges: register("git-pull-request-new-changes", 60428),
    searchFuzzy: register("search-fuzzy", 60429),
    commentDraft: register("comment-draft", 60430),
    send: register("send", 60431),
    sparkle: register("sparkle", 60432),
    insert: register("insert", 60433),
    // derived icons, that could become separate icons
    dialogError: register("dialog-error", "error"),
    dialogWarning: register("dialog-warning", "warning"),
    dialogInfo: register("dialog-info", "info"),
    dialogClose: register("dialog-close", "close"),
    treeItemExpanded: register("tree-item-expanded", "chevron-down"),
    treeFilterOnTypeOn: register("tree-filter-on-type-on", "list-filter"),
    treeFilterOnTypeOff: register("tree-filter-on-type-off", "list-selection"),
    treeFilterClear: register("tree-filter-clear", "close"),
    treeItemLoading: register("tree-item-loading", "loading"),
    menuSelection: register("menu-selection", "check"),
    menuSubmenu: register("menu-submenu", "chevron-right"),
    menuBarMore: register("menubar-more", "more"),
    scrollbarButtonLeft: register("scrollbar-button-left", "triangle-left"),
    scrollbarButtonRight: register("scrollbar-button-right", "triangle-right"),
    scrollbarButtonUp: register("scrollbar-button-up", "triangle-up"),
    scrollbarButtonDown: register("scrollbar-button-down", "triangle-down"),
    toolBarMore: register("toolbar-more", "more"),
    quickInputBack: register("quick-input-back", "arrow-left")
  };

  // node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve3) {
        resolve3(value);
      });
    }
    return new (P || (P = Promise))(function(resolve3, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var TokenizationRegistry = class {
    constructor() {
      this._tokenizationSupports = /* @__PURE__ */ new Map();
      this._factories = /* @__PURE__ */ new Map();
      this._onDidChange = new Emitter();
      this.onDidChange = this._onDidChange.event;
      this._colorMap = null;
    }
    handleChange(languageIds) {
      this._onDidChange.fire({
        changedLanguages: languageIds,
        changedColorMap: false
      });
    }
    register(languageId2, support) {
      this._tokenizationSupports.set(languageId2, support);
      this.handleChange([languageId2]);
      return toDisposable(() => {
        if (this._tokenizationSupports.get(languageId2) !== support) {
          return;
        }
        this._tokenizationSupports.delete(languageId2);
        this.handleChange([languageId2]);
      });
    }
    get(languageId2) {
      return this._tokenizationSupports.get(languageId2) || null;
    }
    registerFactory(languageId2, factory) {
      var _a3;
      (_a3 = this._factories.get(languageId2)) === null || _a3 === void 0 ? void 0 : _a3.dispose();
      const myData = new TokenizationSupportFactoryData(this, languageId2, factory);
      this._factories.set(languageId2, myData);
      return toDisposable(() => {
        const v = this._factories.get(languageId2);
        if (!v || v !== myData) {
          return;
        }
        this._factories.delete(languageId2);
        v.dispose();
      });
    }
    getOrCreate(languageId2) {
      return __awaiter(this, void 0, void 0, function* () {
        const tokenizationSupport = this.get(languageId2);
        if (tokenizationSupport) {
          return tokenizationSupport;
        }
        const factory = this._factories.get(languageId2);
        if (!factory || factory.isResolved) {
          return null;
        }
        yield factory.resolve();
        return this.get(languageId2);
      });
    }
    isResolved(languageId2) {
      const tokenizationSupport = this.get(languageId2);
      if (tokenizationSupport) {
        return true;
      }
      const factory = this._factories.get(languageId2);
      if (!factory || factory.isResolved) {
        return true;
      }
      return false;
    }
    setColorMap(colorMap) {
      this._colorMap = colorMap;
      this._onDidChange.fire({
        changedLanguages: Array.from(this._tokenizationSupports.keys()),
        changedColorMap: true
      });
    }
    getColorMap() {
      return this._colorMap;
    }
    getDefaultBackground() {
      if (this._colorMap && this._colorMap.length > 2) {
        return this._colorMap[
          2
          /* ColorId.DefaultBackground */
        ];
      }
      return null;
    }
  };
  var TokenizationSupportFactoryData = class extends Disposable {
    get isResolved() {
      return this._isResolved;
    }
    constructor(_registry, _languageId, _factory) {
      super();
      this._registry = _registry;
      this._languageId = _languageId;
      this._factory = _factory;
      this._isDisposed = false;
      this._resolvePromise = null;
      this._isResolved = false;
    }
    dispose() {
      this._isDisposed = true;
      super.dispose();
    }
    resolve() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this._resolvePromise) {
          this._resolvePromise = this._create();
        }
        return this._resolvePromise;
      });
    }
    _create() {
      return __awaiter(this, void 0, void 0, function* () {
        const value = yield this._factory.tokenizationSupport;
        this._isResolved = true;
        if (value && !this._isDisposed) {
          this._register(this._registry.register(this._languageId, value));
        }
      });
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/languages.js
  var Token = class {
    constructor(offset, type, language) {
      this.offset = offset;
      this.type = type;
      this.language = language;
      this._tokenBrand = void 0;
    }
    toString() {
      return "(" + this.offset + ", " + this.type + ")";
    }
  };
  var CompletionItemKinds;
  (function(CompletionItemKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolMethod);
    byKind.set(1, Codicon.symbolFunction);
    byKind.set(2, Codicon.symbolConstructor);
    byKind.set(3, Codicon.symbolField);
    byKind.set(4, Codicon.symbolVariable);
    byKind.set(5, Codicon.symbolClass);
    byKind.set(6, Codicon.symbolStruct);
    byKind.set(7, Codicon.symbolInterface);
    byKind.set(8, Codicon.symbolModule);
    byKind.set(9, Codicon.symbolProperty);
    byKind.set(10, Codicon.symbolEvent);
    byKind.set(11, Codicon.symbolOperator);
    byKind.set(12, Codicon.symbolUnit);
    byKind.set(13, Codicon.symbolValue);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(14, Codicon.symbolConstant);
    byKind.set(15, Codicon.symbolEnum);
    byKind.set(16, Codicon.symbolEnumMember);
    byKind.set(17, Codicon.symbolKeyword);
    byKind.set(27, Codicon.symbolSnippet);
    byKind.set(18, Codicon.symbolText);
    byKind.set(19, Codicon.symbolColor);
    byKind.set(20, Codicon.symbolFile);
    byKind.set(21, Codicon.symbolReference);
    byKind.set(22, Codicon.symbolCustomColor);
    byKind.set(23, Codicon.symbolFolder);
    byKind.set(24, Codicon.symbolTypeParameter);
    byKind.set(25, Codicon.account);
    byKind.set(26, Codicon.issues);
    function toIcon(kind) {
      let codicon = byKind.get(kind);
      if (!codicon) {
        console.info("No codicon found for CompletionItemKind " + kind);
        codicon = Codicon.symbolProperty;
      }
      return codicon;
    }
    CompletionItemKinds2.toIcon = toIcon;
    const data = /* @__PURE__ */ new Map();
    data.set(
      "method",
      0
      /* CompletionItemKind.Method */
    );
    data.set(
      "function",
      1
      /* CompletionItemKind.Function */
    );
    data.set(
      "constructor",
      2
      /* CompletionItemKind.Constructor */
    );
    data.set(
      "field",
      3
      /* CompletionItemKind.Field */
    );
    data.set(
      "variable",
      4
      /* CompletionItemKind.Variable */
    );
    data.set(
      "class",
      5
      /* CompletionItemKind.Class */
    );
    data.set(
      "struct",
      6
      /* CompletionItemKind.Struct */
    );
    data.set(
      "interface",
      7
      /* CompletionItemKind.Interface */
    );
    data.set(
      "module",
      8
      /* CompletionItemKind.Module */
    );
    data.set(
      "property",
      9
      /* CompletionItemKind.Property */
    );
    data.set(
      "event",
      10
      /* CompletionItemKind.Event */
    );
    data.set(
      "operator",
      11
      /* CompletionItemKind.Operator */
    );
    data.set(
      "unit",
      12
      /* CompletionItemKind.Unit */
    );
    data.set(
      "value",
      13
      /* CompletionItemKind.Value */
    );
    data.set(
      "constant",
      14
      /* CompletionItemKind.Constant */
    );
    data.set(
      "enum",
      15
      /* CompletionItemKind.Enum */
    );
    data.set(
      "enum-member",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "enumMember",
      16
      /* CompletionItemKind.EnumMember */
    );
    data.set(
      "keyword",
      17
      /* CompletionItemKind.Keyword */
    );
    data.set(
      "snippet",
      27
      /* CompletionItemKind.Snippet */
    );
    data.set(
      "text",
      18
      /* CompletionItemKind.Text */
    );
    data.set(
      "color",
      19
      /* CompletionItemKind.Color */
    );
    data.set(
      "file",
      20
      /* CompletionItemKind.File */
    );
    data.set(
      "reference",
      21
      /* CompletionItemKind.Reference */
    );
    data.set(
      "customcolor",
      22
      /* CompletionItemKind.Customcolor */
    );
    data.set(
      "folder",
      23
      /* CompletionItemKind.Folder */
    );
    data.set(
      "type-parameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "typeParameter",
      24
      /* CompletionItemKind.TypeParameter */
    );
    data.set(
      "account",
      25
      /* CompletionItemKind.User */
    );
    data.set(
      "issue",
      26
      /* CompletionItemKind.Issue */
    );
    function fromString(value, strict) {
      let res = data.get(value);
      if (typeof res === "undefined" && !strict) {
        res = 9;
      }
      return res;
    }
    CompletionItemKinds2.fromString = fromString;
  })(CompletionItemKinds || (CompletionItemKinds = {}));
  var InlineCompletionTriggerKind;
  (function(InlineCompletionTriggerKind3) {
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
  var DocumentHighlightKind;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
    DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
    DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
  })(DocumentHighlightKind || (DocumentHighlightKind = {}));
  var SymbolKinds;
  (function(SymbolKinds2) {
    const byKind = /* @__PURE__ */ new Map();
    byKind.set(0, Codicon.symbolFile);
    byKind.set(1, Codicon.symbolModule);
    byKind.set(2, Codicon.symbolNamespace);
    byKind.set(3, Codicon.symbolPackage);
    byKind.set(4, Codicon.symbolClass);
    byKind.set(5, Codicon.symbolMethod);
    byKind.set(6, Codicon.symbolProperty);
    byKind.set(7, Codicon.symbolField);
    byKind.set(8, Codicon.symbolConstructor);
    byKind.set(9, Codicon.symbolEnum);
    byKind.set(10, Codicon.symbolInterface);
    byKind.set(11, Codicon.symbolFunction);
    byKind.set(12, Codicon.symbolVariable);
    byKind.set(13, Codicon.symbolConstant);
    byKind.set(14, Codicon.symbolString);
    byKind.set(15, Codicon.symbolNumber);
    byKind.set(16, Codicon.symbolBoolean);
    byKind.set(17, Codicon.symbolArray);
    byKind.set(18, Codicon.symbolObject);
    byKind.set(19, Codicon.symbolKey);
    byKind.set(20, Codicon.symbolNull);
    byKind.set(21, Codicon.symbolEnumMember);
    byKind.set(22, Codicon.symbolStruct);
    byKind.set(23, Codicon.symbolEvent);
    byKind.set(24, Codicon.symbolOperator);
    byKind.set(25, Codicon.symbolTypeParameter);
    function toIcon(kind) {
      let icon = byKind.get(kind);
      if (!icon) {
        console.info("No codicon found for SymbolKind " + kind);
        icon = Codicon.symbolProperty;
      }
      return icon;
    }
    SymbolKinds2.toIcon = toIcon;
  })(SymbolKinds || (SymbolKinds = {}));
  var FoldingRangeKind = class _FoldingRangeKind {
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value) {
      switch (value) {
        case "comment":
          return _FoldingRangeKind.Comment;
        case "imports":
          return _FoldingRangeKind.Imports;
        case "region":
          return _FoldingRangeKind.Region;
      }
      return new _FoldingRangeKind(value);
    }
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value) {
      this.value = value;
    }
  };
  FoldingRangeKind.Comment = new FoldingRangeKind("comment");
  FoldingRangeKind.Imports = new FoldingRangeKind("imports");
  FoldingRangeKind.Region = new FoldingRangeKind("region");
  var Command;
  (function(Command3) {
    function is(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return typeof obj.id === "string" && typeof obj.title === "string";
    }
    Command3.is = is;
  })(Command || (Command = {}));
  var InlayHintKind;
  (function(InlayHintKind4) {
    InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
    InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
  })(InlayHintKind || (InlayHintKind = {}));
  var TokenizationRegistry2 = new TokenizationRegistry();

  // node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
  var AccessibilitySupport;
  (function(AccessibilitySupport2) {
    AccessibilitySupport2[AccessibilitySupport2["Unknown"] = 0] = "Unknown";
    AccessibilitySupport2[AccessibilitySupport2["Disabled"] = 1] = "Disabled";
    AccessibilitySupport2[AccessibilitySupport2["Enabled"] = 2] = "Enabled";
  })(AccessibilitySupport || (AccessibilitySupport = {}));
  var CodeActionTriggerType;
  (function(CodeActionTriggerType2) {
    CodeActionTriggerType2[CodeActionTriggerType2["Invoke"] = 1] = "Invoke";
    CodeActionTriggerType2[CodeActionTriggerType2["Auto"] = 2] = "Auto";
  })(CodeActionTriggerType || (CodeActionTriggerType = {}));
  var CompletionItemInsertTextRule;
  (function(CompletionItemInsertTextRule2) {
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["None"] = 0] = "None";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["KeepWhitespace"] = 1] = "KeepWhitespace";
    CompletionItemInsertTextRule2[CompletionItemInsertTextRule2["InsertAsSnippet"] = 4] = "InsertAsSnippet";
  })(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
  var CompletionItemKind;
  (function(CompletionItemKind3) {
    CompletionItemKind3[CompletionItemKind3["Method"] = 0] = "Method";
    CompletionItemKind3[CompletionItemKind3["Function"] = 1] = "Function";
    CompletionItemKind3[CompletionItemKind3["Constructor"] = 2] = "Constructor";
    CompletionItemKind3[CompletionItemKind3["Field"] = 3] = "Field";
    CompletionItemKind3[CompletionItemKind3["Variable"] = 4] = "Variable";
    CompletionItemKind3[CompletionItemKind3["Class"] = 5] = "Class";
    CompletionItemKind3[CompletionItemKind3["Struct"] = 6] = "Struct";
    CompletionItemKind3[CompletionItemKind3["Interface"] = 7] = "Interface";
    CompletionItemKind3[CompletionItemKind3["Module"] = 8] = "Module";
    CompletionItemKind3[CompletionItemKind3["Property"] = 9] = "Property";
    CompletionItemKind3[CompletionItemKind3["Event"] = 10] = "Event";
    CompletionItemKind3[CompletionItemKind3["Operator"] = 11] = "Operator";
    CompletionItemKind3[CompletionItemKind3["Unit"] = 12] = "Unit";
    CompletionItemKind3[CompletionItemKind3["Value"] = 13] = "Value";
    CompletionItemKind3[CompletionItemKind3["Constant"] = 14] = "Constant";
    CompletionItemKind3[CompletionItemKind3["Enum"] = 15] = "Enum";
    CompletionItemKind3[CompletionItemKind3["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind3[CompletionItemKind3["Keyword"] = 17] = "Keyword";
    CompletionItemKind3[CompletionItemKind3["Text"] = 18] = "Text";
    CompletionItemKind3[CompletionItemKind3["Color"] = 19] = "Color";
    CompletionItemKind3[CompletionItemKind3["File"] = 20] = "File";
    CompletionItemKind3[CompletionItemKind3["Reference"] = 21] = "Reference";
    CompletionItemKind3[CompletionItemKind3["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind3[CompletionItemKind3["Folder"] = 23] = "Folder";
    CompletionItemKind3[CompletionItemKind3["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind3[CompletionItemKind3["User"] = 25] = "User";
    CompletionItemKind3[CompletionItemKind3["Issue"] = 26] = "Issue";
    CompletionItemKind3[CompletionItemKind3["Snippet"] = 27] = "Snippet";
  })(CompletionItemKind || (CompletionItemKind = {}));
  var CompletionItemTag;
  (function(CompletionItemTag3) {
    CompletionItemTag3[CompletionItemTag3["Deprecated"] = 1] = "Deprecated";
  })(CompletionItemTag || (CompletionItemTag = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2[CompletionTriggerKind2["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind2[CompletionTriggerKind2["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
  })(CompletionTriggerKind || (CompletionTriggerKind = {}));
  var ContentWidgetPositionPreference;
  (function(ContentWidgetPositionPreference2) {
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["EXACT"] = 0] = "EXACT";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["ABOVE"] = 1] = "ABOVE";
    ContentWidgetPositionPreference2[ContentWidgetPositionPreference2["BELOW"] = 2] = "BELOW";
  })(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
  var CursorChangeReason;
  (function(CursorChangeReason2) {
    CursorChangeReason2[CursorChangeReason2["NotSet"] = 0] = "NotSet";
    CursorChangeReason2[CursorChangeReason2["ContentFlush"] = 1] = "ContentFlush";
    CursorChangeReason2[CursorChangeReason2["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    CursorChangeReason2[CursorChangeReason2["Explicit"] = 3] = "Explicit";
    CursorChangeReason2[CursorChangeReason2["Paste"] = 4] = "Paste";
    CursorChangeReason2[CursorChangeReason2["Undo"] = 5] = "Undo";
    CursorChangeReason2[CursorChangeReason2["Redo"] = 6] = "Redo";
  })(CursorChangeReason || (CursorChangeReason = {}));
  var DefaultEndOfLine;
  (function(DefaultEndOfLine2) {
    DefaultEndOfLine2[DefaultEndOfLine2["LF"] = 1] = "LF";
    DefaultEndOfLine2[DefaultEndOfLine2["CRLF"] = 2] = "CRLF";
  })(DefaultEndOfLine || (DefaultEndOfLine = {}));
  var DocumentHighlightKind2;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4[DocumentHighlightKind4["Text"] = 0] = "Text";
    DocumentHighlightKind4[DocumentHighlightKind4["Read"] = 1] = "Read";
    DocumentHighlightKind4[DocumentHighlightKind4["Write"] = 2] = "Write";
  })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
  var EditorAutoIndentStrategy;
  (function(EditorAutoIndentStrategy2) {
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["None"] = 0] = "None";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy2[EditorAutoIndentStrategy2["Full"] = 4] = "Full";
  })(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
  var EditorOption;
  (function(EditorOption2) {
    EditorOption2[EditorOption2["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption2[EditorOption2["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption2[EditorOption2["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption2[EditorOption2["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption2[EditorOption2["ariaLabel"] = 4] = "ariaLabel";
    EditorOption2[EditorOption2["autoClosingBrackets"] = 5] = "autoClosingBrackets";
    EditorOption2[EditorOption2["screenReaderAnnounceInlineSuggestion"] = 6] = "screenReaderAnnounceInlineSuggestion";
    EditorOption2[EditorOption2["autoClosingDelete"] = 7] = "autoClosingDelete";
    EditorOption2[EditorOption2["autoClosingOvertype"] = 8] = "autoClosingOvertype";
    EditorOption2[EditorOption2["autoClosingQuotes"] = 9] = "autoClosingQuotes";
    EditorOption2[EditorOption2["autoIndent"] = 10] = "autoIndent";
    EditorOption2[EditorOption2["automaticLayout"] = 11] = "automaticLayout";
    EditorOption2[EditorOption2["autoSurround"] = 12] = "autoSurround";
    EditorOption2[EditorOption2["bracketPairColorization"] = 13] = "bracketPairColorization";
    EditorOption2[EditorOption2["guides"] = 14] = "guides";
    EditorOption2[EditorOption2["codeLens"] = 15] = "codeLens";
    EditorOption2[EditorOption2["codeLensFontFamily"] = 16] = "codeLensFontFamily";
    EditorOption2[EditorOption2["codeLensFontSize"] = 17] = "codeLensFontSize";
    EditorOption2[EditorOption2["colorDecorators"] = 18] = "colorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsLimit"] = 19] = "colorDecoratorsLimit";
    EditorOption2[EditorOption2["columnSelection"] = 20] = "columnSelection";
    EditorOption2[EditorOption2["comments"] = 21] = "comments";
    EditorOption2[EditorOption2["contextmenu"] = 22] = "contextmenu";
    EditorOption2[EditorOption2["copyWithSyntaxHighlighting"] = 23] = "copyWithSyntaxHighlighting";
    EditorOption2[EditorOption2["cursorBlinking"] = 24] = "cursorBlinking";
    EditorOption2[EditorOption2["cursorSmoothCaretAnimation"] = 25] = "cursorSmoothCaretAnimation";
    EditorOption2[EditorOption2["cursorStyle"] = 26] = "cursorStyle";
    EditorOption2[EditorOption2["cursorSurroundingLines"] = 27] = "cursorSurroundingLines";
    EditorOption2[EditorOption2["cursorSurroundingLinesStyle"] = 28] = "cursorSurroundingLinesStyle";
    EditorOption2[EditorOption2["cursorWidth"] = 29] = "cursorWidth";
    EditorOption2[EditorOption2["disableLayerHinting"] = 30] = "disableLayerHinting";
    EditorOption2[EditorOption2["disableMonospaceOptimizations"] = 31] = "disableMonospaceOptimizations";
    EditorOption2[EditorOption2["domReadOnly"] = 32] = "domReadOnly";
    EditorOption2[EditorOption2["dragAndDrop"] = 33] = "dragAndDrop";
    EditorOption2[EditorOption2["dropIntoEditor"] = 34] = "dropIntoEditor";
    EditorOption2[EditorOption2["emptySelectionClipboard"] = 35] = "emptySelectionClipboard";
    EditorOption2[EditorOption2["experimentalWhitespaceRendering"] = 36] = "experimentalWhitespaceRendering";
    EditorOption2[EditorOption2["extraEditorClassName"] = 37] = "extraEditorClassName";
    EditorOption2[EditorOption2["fastScrollSensitivity"] = 38] = "fastScrollSensitivity";
    EditorOption2[EditorOption2["find"] = 39] = "find";
    EditorOption2[EditorOption2["fixedOverflowWidgets"] = 40] = "fixedOverflowWidgets";
    EditorOption2[EditorOption2["folding"] = 41] = "folding";
    EditorOption2[EditorOption2["foldingStrategy"] = 42] = "foldingStrategy";
    EditorOption2[EditorOption2["foldingHighlight"] = 43] = "foldingHighlight";
    EditorOption2[EditorOption2["foldingImportsByDefault"] = 44] = "foldingImportsByDefault";
    EditorOption2[EditorOption2["foldingMaximumRegions"] = 45] = "foldingMaximumRegions";
    EditorOption2[EditorOption2["unfoldOnClickAfterEndOfLine"] = 46] = "unfoldOnClickAfterEndOfLine";
    EditorOption2[EditorOption2["fontFamily"] = 47] = "fontFamily";
    EditorOption2[EditorOption2["fontInfo"] = 48] = "fontInfo";
    EditorOption2[EditorOption2["fontLigatures"] = 49] = "fontLigatures";
    EditorOption2[EditorOption2["fontSize"] = 50] = "fontSize";
    EditorOption2[EditorOption2["fontWeight"] = 51] = "fontWeight";
    EditorOption2[EditorOption2["fontVariations"] = 52] = "fontVariations";
    EditorOption2[EditorOption2["formatOnPaste"] = 53] = "formatOnPaste";
    EditorOption2[EditorOption2["formatOnType"] = 54] = "formatOnType";
    EditorOption2[EditorOption2["glyphMargin"] = 55] = "glyphMargin";
    EditorOption2[EditorOption2["gotoLocation"] = 56] = "gotoLocation";
    EditorOption2[EditorOption2["hideCursorInOverviewRuler"] = 57] = "hideCursorInOverviewRuler";
    EditorOption2[EditorOption2["hover"] = 58] = "hover";
    EditorOption2[EditorOption2["inDiffEditor"] = 59] = "inDiffEditor";
    EditorOption2[EditorOption2["inlineSuggest"] = 60] = "inlineSuggest";
    EditorOption2[EditorOption2["letterSpacing"] = 61] = "letterSpacing";
    EditorOption2[EditorOption2["lightbulb"] = 62] = "lightbulb";
    EditorOption2[EditorOption2["lineDecorationsWidth"] = 63] = "lineDecorationsWidth";
    EditorOption2[EditorOption2["lineHeight"] = 64] = "lineHeight";
    EditorOption2[EditorOption2["lineNumbers"] = 65] = "lineNumbers";
    EditorOption2[EditorOption2["lineNumbersMinChars"] = 66] = "lineNumbersMinChars";
    EditorOption2[EditorOption2["linkedEditing"] = 67] = "linkedEditing";
    EditorOption2[EditorOption2["links"] = 68] = "links";
    EditorOption2[EditorOption2["matchBrackets"] = 69] = "matchBrackets";
    EditorOption2[EditorOption2["minimap"] = 70] = "minimap";
    EditorOption2[EditorOption2["mouseStyle"] = 71] = "mouseStyle";
    EditorOption2[EditorOption2["mouseWheelScrollSensitivity"] = 72] = "mouseWheelScrollSensitivity";
    EditorOption2[EditorOption2["mouseWheelZoom"] = 73] = "mouseWheelZoom";
    EditorOption2[EditorOption2["multiCursorMergeOverlapping"] = 74] = "multiCursorMergeOverlapping";
    EditorOption2[EditorOption2["multiCursorModifier"] = 75] = "multiCursorModifier";
    EditorOption2[EditorOption2["multiCursorPaste"] = 76] = "multiCursorPaste";
    EditorOption2[EditorOption2["multiCursorLimit"] = 77] = "multiCursorLimit";
    EditorOption2[EditorOption2["occurrencesHighlight"] = 78] = "occurrencesHighlight";
    EditorOption2[EditorOption2["overviewRulerBorder"] = 79] = "overviewRulerBorder";
    EditorOption2[EditorOption2["overviewRulerLanes"] = 80] = "overviewRulerLanes";
    EditorOption2[EditorOption2["padding"] = 81] = "padding";
    EditorOption2[EditorOption2["pasteAs"] = 82] = "pasteAs";
    EditorOption2[EditorOption2["parameterHints"] = 83] = "parameterHints";
    EditorOption2[EditorOption2["peekWidgetDefaultFocus"] = 84] = "peekWidgetDefaultFocus";
    EditorOption2[EditorOption2["definitionLinkOpensInPeek"] = 85] = "definitionLinkOpensInPeek";
    EditorOption2[EditorOption2["quickSuggestions"] = 86] = "quickSuggestions";
    EditorOption2[EditorOption2["quickSuggestionsDelay"] = 87] = "quickSuggestionsDelay";
    EditorOption2[EditorOption2["readOnly"] = 88] = "readOnly";
    EditorOption2[EditorOption2["readOnlyMessage"] = 89] = "readOnlyMessage";
    EditorOption2[EditorOption2["renameOnType"] = 90] = "renameOnType";
    EditorOption2[EditorOption2["renderControlCharacters"] = 91] = "renderControlCharacters";
    EditorOption2[EditorOption2["renderFinalNewline"] = 92] = "renderFinalNewline";
    EditorOption2[EditorOption2["renderLineHighlight"] = 93] = "renderLineHighlight";
    EditorOption2[EditorOption2["renderLineHighlightOnlyWhenFocus"] = 94] = "renderLineHighlightOnlyWhenFocus";
    EditorOption2[EditorOption2["renderValidationDecorations"] = 95] = "renderValidationDecorations";
    EditorOption2[EditorOption2["renderWhitespace"] = 96] = "renderWhitespace";
    EditorOption2[EditorOption2["revealHorizontalRightPadding"] = 97] = "revealHorizontalRightPadding";
    EditorOption2[EditorOption2["roundedSelection"] = 98] = "roundedSelection";
    EditorOption2[EditorOption2["rulers"] = 99] = "rulers";
    EditorOption2[EditorOption2["scrollbar"] = 100] = "scrollbar";
    EditorOption2[EditorOption2["scrollBeyondLastColumn"] = 101] = "scrollBeyondLastColumn";
    EditorOption2[EditorOption2["scrollBeyondLastLine"] = 102] = "scrollBeyondLastLine";
    EditorOption2[EditorOption2["scrollPredominantAxis"] = 103] = "scrollPredominantAxis";
    EditorOption2[EditorOption2["selectionClipboard"] = 104] = "selectionClipboard";
    EditorOption2[EditorOption2["selectionHighlight"] = 105] = "selectionHighlight";
    EditorOption2[EditorOption2["selectOnLineNumbers"] = 106] = "selectOnLineNumbers";
    EditorOption2[EditorOption2["showFoldingControls"] = 107] = "showFoldingControls";
    EditorOption2[EditorOption2["showUnused"] = 108] = "showUnused";
    EditorOption2[EditorOption2["snippetSuggestions"] = 109] = "snippetSuggestions";
    EditorOption2[EditorOption2["smartSelect"] = 110] = "smartSelect";
    EditorOption2[EditorOption2["smoothScrolling"] = 111] = "smoothScrolling";
    EditorOption2[EditorOption2["stickyScroll"] = 112] = "stickyScroll";
    EditorOption2[EditorOption2["stickyTabStops"] = 113] = "stickyTabStops";
    EditorOption2[EditorOption2["stopRenderingLineAfter"] = 114] = "stopRenderingLineAfter";
    EditorOption2[EditorOption2["suggest"] = 115] = "suggest";
    EditorOption2[EditorOption2["suggestFontSize"] = 116] = "suggestFontSize";
    EditorOption2[EditorOption2["suggestLineHeight"] = 117] = "suggestLineHeight";
    EditorOption2[EditorOption2["suggestOnTriggerCharacters"] = 118] = "suggestOnTriggerCharacters";
    EditorOption2[EditorOption2["suggestSelection"] = 119] = "suggestSelection";
    EditorOption2[EditorOption2["tabCompletion"] = 120] = "tabCompletion";
    EditorOption2[EditorOption2["tabIndex"] = 121] = "tabIndex";
    EditorOption2[EditorOption2["unicodeHighlighting"] = 122] = "unicodeHighlighting";
    EditorOption2[EditorOption2["unusualLineTerminators"] = 123] = "unusualLineTerminators";
    EditorOption2[EditorOption2["useShadowDOM"] = 124] = "useShadowDOM";
    EditorOption2[EditorOption2["useTabStops"] = 125] = "useTabStops";
    EditorOption2[EditorOption2["wordBreak"] = 126] = "wordBreak";
    EditorOption2[EditorOption2["wordSeparators"] = 127] = "wordSeparators";
    EditorOption2[EditorOption2["wordWrap"] = 128] = "wordWrap";
    EditorOption2[EditorOption2["wordWrapBreakAfterCharacters"] = 129] = "wordWrapBreakAfterCharacters";
    EditorOption2[EditorOption2["wordWrapBreakBeforeCharacters"] = 130] = "wordWrapBreakBeforeCharacters";
    EditorOption2[EditorOption2["wordWrapColumn"] = 131] = "wordWrapColumn";
    EditorOption2[EditorOption2["wordWrapOverride1"] = 132] = "wordWrapOverride1";
    EditorOption2[EditorOption2["wordWrapOverride2"] = 133] = "wordWrapOverride2";
    EditorOption2[EditorOption2["wrappingIndent"] = 134] = "wrappingIndent";
    EditorOption2[EditorOption2["wrappingStrategy"] = 135] = "wrappingStrategy";
    EditorOption2[EditorOption2["showDeprecated"] = 136] = "showDeprecated";
    EditorOption2[EditorOption2["inlayHints"] = 137] = "inlayHints";
    EditorOption2[EditorOption2["editorClassName"] = 138] = "editorClassName";
    EditorOption2[EditorOption2["pixelRatio"] = 139] = "pixelRatio";
    EditorOption2[EditorOption2["tabFocusMode"] = 140] = "tabFocusMode";
    EditorOption2[EditorOption2["layoutInfo"] = 141] = "layoutInfo";
    EditorOption2[EditorOption2["wrappingInfo"] = 142] = "wrappingInfo";
    EditorOption2[EditorOption2["defaultColorDecorators"] = 143] = "defaultColorDecorators";
    EditorOption2[EditorOption2["colorDecoratorsActivatedOn"] = 144] = "colorDecoratorsActivatedOn";
  })(EditorOption || (EditorOption = {}));
  var EndOfLinePreference;
  (function(EndOfLinePreference2) {
    EndOfLinePreference2[EndOfLinePreference2["TextDefined"] = 0] = "TextDefined";
    EndOfLinePreference2[EndOfLinePreference2["LF"] = 1] = "LF";
    EndOfLinePreference2[EndOfLinePreference2["CRLF"] = 2] = "CRLF";
  })(EndOfLinePreference || (EndOfLinePreference = {}));
  var EndOfLineSequence;
  (function(EndOfLineSequence2) {
    EndOfLineSequence2[EndOfLineSequence2["LF"] = 0] = "LF";
    EndOfLineSequence2[EndOfLineSequence2["CRLF"] = 1] = "CRLF";
  })(EndOfLineSequence || (EndOfLineSequence = {}));
  var GlyphMarginLane;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 2] = "Right";
  })(GlyphMarginLane || (GlyphMarginLane = {}));
  var IndentAction;
  (function(IndentAction2) {
    IndentAction2[IndentAction2["None"] = 0] = "None";
    IndentAction2[IndentAction2["Indent"] = 1] = "Indent";
    IndentAction2[IndentAction2["IndentOutdent"] = 2] = "IndentOutdent";
    IndentAction2[IndentAction2["Outdent"] = 3] = "Outdent";
  })(IndentAction || (IndentAction = {}));
  var InjectedTextCursorStops;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops || (InjectedTextCursorStops = {}));
  var InlayHintKind2;
  (function(InlayHintKind4) {
    InlayHintKind4[InlayHintKind4["Type"] = 1] = "Type";
    InlayHintKind4[InlayHintKind4["Parameter"] = 2] = "Parameter";
  })(InlayHintKind2 || (InlayHintKind2 = {}));
  var InlineCompletionTriggerKind2;
  (function(InlineCompletionTriggerKind3) {
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Automatic"] = 0] = "Automatic";
    InlineCompletionTriggerKind3[InlineCompletionTriggerKind3["Explicit"] = 1] = "Explicit";
  })(InlineCompletionTriggerKind2 || (InlineCompletionTriggerKind2 = {}));
  var KeyCode;
  (function(KeyCode2) {
    KeyCode2[KeyCode2["DependsOnKbLayout"] = -1] = "DependsOnKbLayout";
    KeyCode2[KeyCode2["Unknown"] = 0] = "Unknown";
    KeyCode2[KeyCode2["Backspace"] = 1] = "Backspace";
    KeyCode2[KeyCode2["Tab"] = 2] = "Tab";
    KeyCode2[KeyCode2["Enter"] = 3] = "Enter";
    KeyCode2[KeyCode2["Shift"] = 4] = "Shift";
    KeyCode2[KeyCode2["Ctrl"] = 5] = "Ctrl";
    KeyCode2[KeyCode2["Alt"] = 6] = "Alt";
    KeyCode2[KeyCode2["PauseBreak"] = 7] = "PauseBreak";
    KeyCode2[KeyCode2["CapsLock"] = 8] = "CapsLock";
    KeyCode2[KeyCode2["Escape"] = 9] = "Escape";
    KeyCode2[KeyCode2["Space"] = 10] = "Space";
    KeyCode2[KeyCode2["PageUp"] = 11] = "PageUp";
    KeyCode2[KeyCode2["PageDown"] = 12] = "PageDown";
    KeyCode2[KeyCode2["End"] = 13] = "End";
    KeyCode2[KeyCode2["Home"] = 14] = "Home";
    KeyCode2[KeyCode2["LeftArrow"] = 15] = "LeftArrow";
    KeyCode2[KeyCode2["UpArrow"] = 16] = "UpArrow";
    KeyCode2[KeyCode2["RightArrow"] = 17] = "RightArrow";
    KeyCode2[KeyCode2["DownArrow"] = 18] = "DownArrow";
    KeyCode2[KeyCode2["Insert"] = 19] = "Insert";
    KeyCode2[KeyCode2["Delete"] = 20] = "Delete";
    KeyCode2[KeyCode2["Digit0"] = 21] = "Digit0";
    KeyCode2[KeyCode2["Digit1"] = 22] = "Digit1";
    KeyCode2[KeyCode2["Digit2"] = 23] = "Digit2";
    KeyCode2[KeyCode2["Digit3"] = 24] = "Digit3";
    KeyCode2[KeyCode2["Digit4"] = 25] = "Digit4";
    KeyCode2[KeyCode2["Digit5"] = 26] = "Digit5";
    KeyCode2[KeyCode2["Digit6"] = 27] = "Digit6";
    KeyCode2[KeyCode2["Digit7"] = 28] = "Digit7";
    KeyCode2[KeyCode2["Digit8"] = 29] = "Digit8";
    KeyCode2[KeyCode2["Digit9"] = 30] = "Digit9";
    KeyCode2[KeyCode2["KeyA"] = 31] = "KeyA";
    KeyCode2[KeyCode2["KeyB"] = 32] = "KeyB";
    KeyCode2[KeyCode2["KeyC"] = 33] = "KeyC";
    KeyCode2[KeyCode2["KeyD"] = 34] = "KeyD";
    KeyCode2[KeyCode2["KeyE"] = 35] = "KeyE";
    KeyCode2[KeyCode2["KeyF"] = 36] = "KeyF";
    KeyCode2[KeyCode2["KeyG"] = 37] = "KeyG";
    KeyCode2[KeyCode2["KeyH"] = 38] = "KeyH";
    KeyCode2[KeyCode2["KeyI"] = 39] = "KeyI";
    KeyCode2[KeyCode2["KeyJ"] = 40] = "KeyJ";
    KeyCode2[KeyCode2["KeyK"] = 41] = "KeyK";
    KeyCode2[KeyCode2["KeyL"] = 42] = "KeyL";
    KeyCode2[KeyCode2["KeyM"] = 43] = "KeyM";
    KeyCode2[KeyCode2["KeyN"] = 44] = "KeyN";
    KeyCode2[KeyCode2["KeyO"] = 45] = "KeyO";
    KeyCode2[KeyCode2["KeyP"] = 46] = "KeyP";
    KeyCode2[KeyCode2["KeyQ"] = 47] = "KeyQ";
    KeyCode2[KeyCode2["KeyR"] = 48] = "KeyR";
    KeyCode2[KeyCode2["KeyS"] = 49] = "KeyS";
    KeyCode2[KeyCode2["KeyT"] = 50] = "KeyT";
    KeyCode2[KeyCode2["KeyU"] = 51] = "KeyU";
    KeyCode2[KeyCode2["KeyV"] = 52] = "KeyV";
    KeyCode2[KeyCode2["KeyW"] = 53] = "KeyW";
    KeyCode2[KeyCode2["KeyX"] = 54] = "KeyX";
    KeyCode2[KeyCode2["KeyY"] = 55] = "KeyY";
    KeyCode2[KeyCode2["KeyZ"] = 56] = "KeyZ";
    KeyCode2[KeyCode2["Meta"] = 57] = "Meta";
    KeyCode2[KeyCode2["ContextMenu"] = 58] = "ContextMenu";
    KeyCode2[KeyCode2["F1"] = 59] = "F1";
    KeyCode2[KeyCode2["F2"] = 60] = "F2";
    KeyCode2[KeyCode2["F3"] = 61] = "F3";
    KeyCode2[KeyCode2["F4"] = 62] = "F4";
    KeyCode2[KeyCode2["F5"] = 63] = "F5";
    KeyCode2[KeyCode2["F6"] = 64] = "F6";
    KeyCode2[KeyCode2["F7"] = 65] = "F7";
    KeyCode2[KeyCode2["F8"] = 66] = "F8";
    KeyCode2[KeyCode2["F9"] = 67] = "F9";
    KeyCode2[KeyCode2["F10"] = 68] = "F10";
    KeyCode2[KeyCode2["F11"] = 69] = "F11";
    KeyCode2[KeyCode2["F12"] = 70] = "F12";
    KeyCode2[KeyCode2["F13"] = 71] = "F13";
    KeyCode2[KeyCode2["F14"] = 72] = "F14";
    KeyCode2[KeyCode2["F15"] = 73] = "F15";
    KeyCode2[KeyCode2["F16"] = 74] = "F16";
    KeyCode2[KeyCode2["F17"] = 75] = "F17";
    KeyCode2[KeyCode2["F18"] = 76] = "F18";
    KeyCode2[KeyCode2["F19"] = 77] = "F19";
    KeyCode2[KeyCode2["F20"] = 78] = "F20";
    KeyCode2[KeyCode2["F21"] = 79] = "F21";
    KeyCode2[KeyCode2["F22"] = 80] = "F22";
    KeyCode2[KeyCode2["F23"] = 81] = "F23";
    KeyCode2[KeyCode2["F24"] = 82] = "F24";
    KeyCode2[KeyCode2["NumLock"] = 83] = "NumLock";
    KeyCode2[KeyCode2["ScrollLock"] = 84] = "ScrollLock";
    KeyCode2[KeyCode2["Semicolon"] = 85] = "Semicolon";
    KeyCode2[KeyCode2["Equal"] = 86] = "Equal";
    KeyCode2[KeyCode2["Comma"] = 87] = "Comma";
    KeyCode2[KeyCode2["Minus"] = 88] = "Minus";
    KeyCode2[KeyCode2["Period"] = 89] = "Period";
    KeyCode2[KeyCode2["Slash"] = 90] = "Slash";
    KeyCode2[KeyCode2["Backquote"] = 91] = "Backquote";
    KeyCode2[KeyCode2["BracketLeft"] = 92] = "BracketLeft";
    KeyCode2[KeyCode2["Backslash"] = 93] = "Backslash";
    KeyCode2[KeyCode2["BracketRight"] = 94] = "BracketRight";
    KeyCode2[KeyCode2["Quote"] = 95] = "Quote";
    KeyCode2[KeyCode2["OEM_8"] = 96] = "OEM_8";
    KeyCode2[KeyCode2["IntlBackslash"] = 97] = "IntlBackslash";
    KeyCode2[KeyCode2["Numpad0"] = 98] = "Numpad0";
    KeyCode2[KeyCode2["Numpad1"] = 99] = "Numpad1";
    KeyCode2[KeyCode2["Numpad2"] = 100] = "Numpad2";
    KeyCode2[KeyCode2["Numpad3"] = 101] = "Numpad3";
    KeyCode2[KeyCode2["Numpad4"] = 102] = "Numpad4";
    KeyCode2[KeyCode2["Numpad5"] = 103] = "Numpad5";
    KeyCode2[KeyCode2["Numpad6"] = 104] = "Numpad6";
    KeyCode2[KeyCode2["Numpad7"] = 105] = "Numpad7";
    KeyCode2[KeyCode2["Numpad8"] = 106] = "Numpad8";
    KeyCode2[KeyCode2["Numpad9"] = 107] = "Numpad9";
    KeyCode2[KeyCode2["NumpadMultiply"] = 108] = "NumpadMultiply";
    KeyCode2[KeyCode2["NumpadAdd"] = 109] = "NumpadAdd";
    KeyCode2[KeyCode2["NUMPAD_SEPARATOR"] = 110] = "NUMPAD_SEPARATOR";
    KeyCode2[KeyCode2["NumpadSubtract"] = 111] = "NumpadSubtract";
    KeyCode2[KeyCode2["NumpadDecimal"] = 112] = "NumpadDecimal";
    KeyCode2[KeyCode2["NumpadDivide"] = 113] = "NumpadDivide";
    KeyCode2[KeyCode2["KEY_IN_COMPOSITION"] = 114] = "KEY_IN_COMPOSITION";
    KeyCode2[KeyCode2["ABNT_C1"] = 115] = "ABNT_C1";
    KeyCode2[KeyCode2["ABNT_C2"] = 116] = "ABNT_C2";
    KeyCode2[KeyCode2["AudioVolumeMute"] = 117] = "AudioVolumeMute";
    KeyCode2[KeyCode2["AudioVolumeUp"] = 118] = "AudioVolumeUp";
    KeyCode2[KeyCode2["AudioVolumeDown"] = 119] = "AudioVolumeDown";
    KeyCode2[KeyCode2["BrowserSearch"] = 120] = "BrowserSearch";
    KeyCode2[KeyCode2["BrowserHome"] = 121] = "BrowserHome";
    KeyCode2[KeyCode2["BrowserBack"] = 122] = "BrowserBack";
    KeyCode2[KeyCode2["BrowserForward"] = 123] = "BrowserForward";
    KeyCode2[KeyCode2["MediaTrackNext"] = 124] = "MediaTrackNext";
    KeyCode2[KeyCode2["MediaTrackPrevious"] = 125] = "MediaTrackPrevious";
    KeyCode2[KeyCode2["MediaStop"] = 126] = "MediaStop";
    KeyCode2[KeyCode2["MediaPlayPause"] = 127] = "MediaPlayPause";
    KeyCode2[KeyCode2["LaunchMediaPlayer"] = 128] = "LaunchMediaPlayer";
    KeyCode2[KeyCode2["LaunchMail"] = 129] = "LaunchMail";
    KeyCode2[KeyCode2["LaunchApp2"] = 130] = "LaunchApp2";
    KeyCode2[KeyCode2["Clear"] = 131] = "Clear";
    KeyCode2[KeyCode2["MAX_VALUE"] = 132] = "MAX_VALUE";
  })(KeyCode || (KeyCode = {}));
  var MarkerSeverity;
  (function(MarkerSeverity2) {
    MarkerSeverity2[MarkerSeverity2["Hint"] = 1] = "Hint";
    MarkerSeverity2[MarkerSeverity2["Info"] = 2] = "Info";
    MarkerSeverity2[MarkerSeverity2["Warning"] = 4] = "Warning";
    MarkerSeverity2[MarkerSeverity2["Error"] = 8] = "Error";
  })(MarkerSeverity || (MarkerSeverity = {}));
  var MarkerTag;
  (function(MarkerTag2) {
    MarkerTag2[MarkerTag2["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag2[MarkerTag2["Deprecated"] = 2] = "Deprecated";
  })(MarkerTag || (MarkerTag = {}));
  var MinimapPosition;
  (function(MinimapPosition3) {
    MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
    MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
  })(MinimapPosition || (MinimapPosition = {}));
  var MouseTargetType;
  (function(MouseTargetType2) {
    MouseTargetType2[MouseTargetType2["UNKNOWN"] = 0] = "UNKNOWN";
    MouseTargetType2[MouseTargetType2["TEXTAREA"] = 1] = "TEXTAREA";
    MouseTargetType2[MouseTargetType2["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    MouseTargetType2[MouseTargetType2["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    MouseTargetType2[MouseTargetType2["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    MouseTargetType2[MouseTargetType2["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    MouseTargetType2[MouseTargetType2["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    MouseTargetType2[MouseTargetType2["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    MouseTargetType2[MouseTargetType2["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    MouseTargetType2[MouseTargetType2["SCROLLBAR"] = 11] = "SCROLLBAR";
    MouseTargetType2[MouseTargetType2["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    MouseTargetType2[MouseTargetType2["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
  })(MouseTargetType || (MouseTargetType = {}));
  var OverlayWidgetPositionPreference;
  (function(OverlayWidgetPositionPreference2) {
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    OverlayWidgetPositionPreference2[OverlayWidgetPositionPreference2["TOP_CENTER"] = 2] = "TOP_CENTER";
  })(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
  var OverviewRulerLane;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane || (OverviewRulerLane = {}));
  var PositionAffinity;
  (function(PositionAffinity2) {
    PositionAffinity2[PositionAffinity2["Left"] = 0] = "Left";
    PositionAffinity2[PositionAffinity2["Right"] = 1] = "Right";
    PositionAffinity2[PositionAffinity2["None"] = 2] = "None";
    PositionAffinity2[PositionAffinity2["LeftOfInjectedText"] = 3] = "LeftOfInjectedText";
    PositionAffinity2[PositionAffinity2["RightOfInjectedText"] = 4] = "RightOfInjectedText";
  })(PositionAffinity || (PositionAffinity = {}));
  var RenderLineNumbersType;
  (function(RenderLineNumbersType2) {
    RenderLineNumbersType2[RenderLineNumbersType2["Off"] = 0] = "Off";
    RenderLineNumbersType2[RenderLineNumbersType2["On"] = 1] = "On";
    RenderLineNumbersType2[RenderLineNumbersType2["Relative"] = 2] = "Relative";
    RenderLineNumbersType2[RenderLineNumbersType2["Interval"] = 3] = "Interval";
    RenderLineNumbersType2[RenderLineNumbersType2["Custom"] = 4] = "Custom";
  })(RenderLineNumbersType || (RenderLineNumbersType = {}));
  var RenderMinimap;
  (function(RenderMinimap2) {
    RenderMinimap2[RenderMinimap2["None"] = 0] = "None";
    RenderMinimap2[RenderMinimap2["Text"] = 1] = "Text";
    RenderMinimap2[RenderMinimap2["Blocks"] = 2] = "Blocks";
  })(RenderMinimap || (RenderMinimap = {}));
  var ScrollType;
  (function(ScrollType2) {
    ScrollType2[ScrollType2["Smooth"] = 0] = "Smooth";
    ScrollType2[ScrollType2["Immediate"] = 1] = "Immediate";
  })(ScrollType || (ScrollType = {}));
  var ScrollbarVisibility;
  (function(ScrollbarVisibility2) {
    ScrollbarVisibility2[ScrollbarVisibility2["Auto"] = 1] = "Auto";
    ScrollbarVisibility2[ScrollbarVisibility2["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility2[ScrollbarVisibility2["Visible"] = 3] = "Visible";
  })(ScrollbarVisibility || (ScrollbarVisibility = {}));
  var SelectionDirection;
  (function(SelectionDirection2) {
    SelectionDirection2[SelectionDirection2["LTR"] = 0] = "LTR";
    SelectionDirection2[SelectionDirection2["RTL"] = 1] = "RTL";
  })(SelectionDirection || (SelectionDirection = {}));
  var SignatureHelpTriggerKind2;
  (function(SignatureHelpTriggerKind3) {
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
  })(SignatureHelpTriggerKind2 || (SignatureHelpTriggerKind2 = {}));
  var SymbolKind;
  (function(SymbolKind3) {
    SymbolKind3[SymbolKind3["File"] = 0] = "File";
    SymbolKind3[SymbolKind3["Module"] = 1] = "Module";
    SymbolKind3[SymbolKind3["Namespace"] = 2] = "Namespace";
    SymbolKind3[SymbolKind3["Package"] = 3] = "Package";
    SymbolKind3[SymbolKind3["Class"] = 4] = "Class";
    SymbolKind3[SymbolKind3["Method"] = 5] = "Method";
    SymbolKind3[SymbolKind3["Property"] = 6] = "Property";
    SymbolKind3[SymbolKind3["Field"] = 7] = "Field";
    SymbolKind3[SymbolKind3["Constructor"] = 8] = "Constructor";
    SymbolKind3[SymbolKind3["Enum"] = 9] = "Enum";
    SymbolKind3[SymbolKind3["Interface"] = 10] = "Interface";
    SymbolKind3[SymbolKind3["Function"] = 11] = "Function";
    SymbolKind3[SymbolKind3["Variable"] = 12] = "Variable";
    SymbolKind3[SymbolKind3["Constant"] = 13] = "Constant";
    SymbolKind3[SymbolKind3["String"] = 14] = "String";
    SymbolKind3[SymbolKind3["Number"] = 15] = "Number";
    SymbolKind3[SymbolKind3["Boolean"] = 16] = "Boolean";
    SymbolKind3[SymbolKind3["Array"] = 17] = "Array";
    SymbolKind3[SymbolKind3["Object"] = 18] = "Object";
    SymbolKind3[SymbolKind3["Key"] = 19] = "Key";
    SymbolKind3[SymbolKind3["Null"] = 20] = "Null";
    SymbolKind3[SymbolKind3["EnumMember"] = 21] = "EnumMember";
    SymbolKind3[SymbolKind3["Struct"] = 22] = "Struct";
    SymbolKind3[SymbolKind3["Event"] = 23] = "Event";
    SymbolKind3[SymbolKind3["Operator"] = 24] = "Operator";
    SymbolKind3[SymbolKind3["TypeParameter"] = 25] = "TypeParameter";
  })(SymbolKind || (SymbolKind = {}));
  var SymbolTag;
  (function(SymbolTag3) {
    SymbolTag3[SymbolTag3["Deprecated"] = 1] = "Deprecated";
  })(SymbolTag || (SymbolTag = {}));
  var TextEditorCursorBlinkingStyle;
  (function(TextEditorCursorBlinkingStyle2) {
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Hidden"] = 0] = "Hidden";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Blink"] = 1] = "Blink";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Smooth"] = 2] = "Smooth";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Phase"] = 3] = "Phase";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Expand"] = 4] = "Expand";
    TextEditorCursorBlinkingStyle2[TextEditorCursorBlinkingStyle2["Solid"] = 5] = "Solid";
  })(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
  var TextEditorCursorStyle;
  (function(TextEditorCursorStyle2) {
    TextEditorCursorStyle2[TextEditorCursorStyle2["Line"] = 1] = "Line";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Block"] = 2] = "Block";
    TextEditorCursorStyle2[TextEditorCursorStyle2["Underline"] = 3] = "Underline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["LineThin"] = 4] = "LineThin";
    TextEditorCursorStyle2[TextEditorCursorStyle2["BlockOutline"] = 5] = "BlockOutline";
    TextEditorCursorStyle2[TextEditorCursorStyle2["UnderlineThin"] = 6] = "UnderlineThin";
  })(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
  var TrackedRangeStickiness;
  (function(TrackedRangeStickiness2) {
    TrackedRangeStickiness2[TrackedRangeStickiness2["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness2[TrackedRangeStickiness2["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
  })(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
  var WrappingIndent;
  (function(WrappingIndent2) {
    WrappingIndent2[WrappingIndent2["None"] = 0] = "None";
    WrappingIndent2[WrappingIndent2["Same"] = 1] = "Same";
    WrappingIndent2[WrappingIndent2["Indent"] = 2] = "Indent";
    WrappingIndent2[WrappingIndent2["DeepIndent"] = 3] = "DeepIndent";
  })(WrappingIndent || (WrappingIndent = {}));

  // node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js
  var KeyMod = class {
    static chord(firstPart, secondPart) {
      return KeyChord(firstPart, secondPart);
    }
  };
  KeyMod.CtrlCmd = 2048;
  KeyMod.Shift = 1024;
  KeyMod.Alt = 512;
  KeyMod.WinCtrl = 256;
  function createMonacoBaseAPI() {
    return {
      editor: void 0,
      languages: void 0,
      CancellationTokenSource,
      Emitter,
      KeyCode,
      KeyMod,
      Position,
      Range,
      Selection,
      SelectionDirection,
      MarkerSeverity,
      MarkerTag,
      Uri: URI,
      Token
    };
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js
  var WordCharacterClassifier = class extends CharacterClassifier {
    constructor(wordSeparators) {
      super(
        0
        /* WordCharacterClass.Regular */
      );
      for (let i = 0, len = wordSeparators.length; i < len; i++) {
        this.set(
          wordSeparators.charCodeAt(i),
          2
          /* WordCharacterClass.WordSeparator */
        );
      }
      this.set(
        32,
        1
        /* WordCharacterClass.Whitespace */
      );
      this.set(
        9,
        1
        /* WordCharacterClass.Whitespace */
      );
    }
  };
  function once2(computeFn) {
    const cache = {};
    return (input) => {
      if (!cache.hasOwnProperty(input)) {
        cache[input] = computeFn(input);
      }
      return cache[input];
    };
  }
  var getMapForWordSeparators = once2((input) => new WordCharacterClassifier(input));

  // node_modules/monaco-editor/esm/vs/editor/common/model.js
  var OverviewRulerLane2;
  (function(OverviewRulerLane3) {
    OverviewRulerLane3[OverviewRulerLane3["Left"] = 1] = "Left";
    OverviewRulerLane3[OverviewRulerLane3["Center"] = 2] = "Center";
    OverviewRulerLane3[OverviewRulerLane3["Right"] = 4] = "Right";
    OverviewRulerLane3[OverviewRulerLane3["Full"] = 7] = "Full";
  })(OverviewRulerLane2 || (OverviewRulerLane2 = {}));
  var GlyphMarginLane2;
  (function(GlyphMarginLane3) {
    GlyphMarginLane3[GlyphMarginLane3["Left"] = 1] = "Left";
    GlyphMarginLane3[GlyphMarginLane3["Right"] = 2] = "Right";
  })(GlyphMarginLane2 || (GlyphMarginLane2 = {}));
  var MinimapPosition2;
  (function(MinimapPosition3) {
    MinimapPosition3[MinimapPosition3["Inline"] = 1] = "Inline";
    MinimapPosition3[MinimapPosition3["Gutter"] = 2] = "Gutter";
  })(MinimapPosition2 || (MinimapPosition2 = {}));
  var InjectedTextCursorStops2;
  (function(InjectedTextCursorStops3) {
    InjectedTextCursorStops3[InjectedTextCursorStops3["Both"] = 0] = "Both";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Right"] = 1] = "Right";
    InjectedTextCursorStops3[InjectedTextCursorStops3["Left"] = 2] = "Left";
    InjectedTextCursorStops3[InjectedTextCursorStops3["None"] = 3] = "None";
  })(InjectedTextCursorStops2 || (InjectedTextCursorStops2 = {}));

  // node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js
  function leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex === 0) {
      return true;
    }
    const charBefore = text.charCodeAt(matchStartIndex - 1);
    if (wordSeparators.get(charBefore) !== 0) {
      return true;
    }
    if (charBefore === 13 || charBefore === 10) {
      return true;
    }
    if (matchLength > 0) {
      const firstCharInMatch = text.charCodeAt(matchStartIndex);
      if (wordSeparators.get(firstCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    if (matchStartIndex + matchLength === textLength) {
      return true;
    }
    const charAfter = text.charCodeAt(matchStartIndex + matchLength);
    if (wordSeparators.get(charAfter) !== 0) {
      return true;
    }
    if (charAfter === 13 || charAfter === 10) {
      return true;
    }
    if (matchLength > 0) {
      const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);
      if (wordSeparators.get(lastCharInMatch) !== 0) {
        return true;
      }
    }
    return false;
  }
  function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {
    return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);
  }
  var Searcher = class {
    constructor(wordSeparators, searchRegex) {
      this._wordSeparators = wordSeparators;
      this._searchRegex = searchRegex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    reset(lastIndex) {
      this._searchRegex.lastIndex = lastIndex;
      this._prevMatchStartIndex = -1;
      this._prevMatchLength = 0;
    }
    next(text) {
      const textLength = text.length;
      let m;
      do {
        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {
          return null;
        }
        m = this._searchRegex.exec(text);
        if (!m) {
          return null;
        }
        const matchStartIndex = m.index;
        const matchLength = m[0].length;
        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {
          if (matchLength === 0) {
            if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 65535) {
              this._searchRegex.lastIndex += 2;
            } else {
              this._searchRegex.lastIndex += 1;
            }
            continue;
          }
          return null;
        }
        this._prevMatchStartIndex = matchStartIndex;
        this._prevMatchLength = matchLength;
        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {
          return m;
        }
      } while (m);
      return null;
    }
  };

  // node_modules/monaco-editor/esm/vs/base/common/assert.js
  function assertNever(value, message = "Unreachable") {
    throw new Error(message);
  }
  function assertFn(condition) {
    if (!condition()) {
      debugger;
      condition();
      onUnexpectedError(new BugIndicatingError("Assertion Failed"));
    }
  }
  function checkAdjacentItems(items, predicate) {
    let i = 0;
    while (i < items.length - 1) {
      const a2 = items[i];
      const b = items[i + 1];
      if (!predicate(a2, b)) {
        return false;
      }
      i++;
    }
    return true;
  }

  // node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js
  var UnicodeTextModelHighlighter = class {
    static computeUnicodeHighlights(model, options, range) {
      const startLine = range ? range.startLineNumber : 1;
      const endLine = range ? range.endLineNumber : model.getLineCount();
      const codePointHighlighter = new CodePointHighlighter(options);
      const candidates = codePointHighlighter.getCandidateCodePoints();
      let regex;
      if (candidates === "allNonBasicAscii") {
        regex = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g");
      } else {
        regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, "g");
      }
      const searcher = new Searcher(null, regex);
      const ranges = [];
      let hasMore = false;
      let m;
      let ambiguousCharacterCount = 0;
      let invisibleCharacterCount = 0;
      let nonBasicAsciiCharacterCount = 0;
      forLoop:
        for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {
          const lineContent = model.getLineContent(lineNumber);
          const lineLength = lineContent.length;
          searcher.reset(0);
          do {
            m = searcher.next(lineContent);
            if (m) {
              let startIndex = m.index;
              let endIndex = m.index + m[0].length;
              if (startIndex > 0) {
                const charCodeBefore = lineContent.charCodeAt(startIndex - 1);
                if (isHighSurrogate(charCodeBefore)) {
                  startIndex--;
                }
              }
              if (endIndex + 1 < lineLength) {
                const charCodeBefore = lineContent.charCodeAt(endIndex - 1);
                if (isHighSurrogate(charCodeBefore)) {
                  endIndex++;
                }
              }
              const str = lineContent.substring(startIndex, endIndex);
              let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);
              if (word && word.endColumn <= startIndex + 1) {
                word = null;
              }
              const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);
              if (highlightReason !== 0) {
                if (highlightReason === 3) {
                  ambiguousCharacterCount++;
                } else if (highlightReason === 2) {
                  invisibleCharacterCount++;
                } else if (highlightReason === 1) {
                  nonBasicAsciiCharacterCount++;
                } else {
                  assertNever(highlightReason);
                }
                const MAX_RESULT_LENGTH = 1e3;
                if (ranges.length >= MAX_RESULT_LENGTH) {
                  hasMore = true;
                  break forLoop;
                }
                ranges.push(new Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));
              }
            }
          } while (m);
        }
      return {
        ranges,
        hasMore,
        ambiguousCharacterCount,
        invisibleCharacterCount,
        nonBasicAsciiCharacterCount
      };
    }
    static computeUnicodeHighlightReason(char, options) {
      const codePointHighlighter = new CodePointHighlighter(options);
      const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);
      switch (reason) {
        case 0:
          return null;
        case 2:
          return {
            kind: 1
            /* UnicodeHighlighterReasonKind.Invisible */
          };
        case 3: {
          const codePoint = char.codePointAt(0);
          const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);
          const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(/* @__PURE__ */ new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));
          return { kind: 0, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };
        }
        case 1:
          return {
            kind: 2
            /* UnicodeHighlighterReasonKind.NonBasicAscii */
          };
      }
    }
  };
  function buildRegExpCharClassExpr(codePoints, flags) {
    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(""))}]`;
    return src;
  }
  var CodePointHighlighter = class {
    constructor(options) {
      this.options = options;
      this.allowedCodePoints = new Set(options.allowedCodePoints);
      this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));
    }
    getCandidateCodePoints() {
      if (this.options.nonBasicASCII) {
        return "allNonBasicAscii";
      }
      const set2 = /* @__PURE__ */ new Set();
      if (this.options.invisibleCharacters) {
        for (const cp of InvisibleCharacters.codePoints) {
          if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {
            set2.add(cp);
          }
        }
      }
      if (this.options.ambiguousCharacters) {
        for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {
          set2.add(cp);
        }
      }
      for (const cp of this.allowedCodePoints) {
        set2.delete(cp);
      }
      return set2;
    }
    shouldHighlightNonBasicASCII(character, wordContext) {
      const codePoint = character.codePointAt(0);
      if (this.allowedCodePoints.has(codePoint)) {
        return 0;
      }
      if (this.options.nonBasicASCII) {
        return 1;
      }
      let hasBasicASCIICharacters = false;
      let hasNonConfusableNonBasicAsciiCharacter = false;
      if (wordContext) {
        for (const char of wordContext) {
          const codePoint2 = char.codePointAt(0);
          const isBasicASCII2 = isBasicASCII(char);
          hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII2;
          if (!isBasicASCII2 && !this.ambiguousCharacters.isAmbiguous(codePoint2) && !InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
            hasNonConfusableNonBasicAsciiCharacter = true;
          }
        }
      }
      if (
        /* Don't allow mixing weird looking characters with ASCII */
        !hasBasicASCIICharacters && /* Is there an obviously weird looking character? */
        hasNonConfusableNonBasicAsciiCharacter
      ) {
        return 0;
      }
      if (this.options.invisibleCharacters) {
        if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {
          return 2;
        }
      }
      if (this.options.ambiguousCharacters) {
        if (this.ambiguousCharacters.isAmbiguous(codePoint)) {
          return 3;
        }
      }
      return 0;
    }
  };
  function isAllowedInvisibleCharacter(character) {
    return character === " " || character === "\n" || character === "	";
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js
  var LineRange = class _LineRange {
    static fromRange(range) {
      return new _LineRange(range.startLineNumber, range.endLineNumber);
    }
    static subtract(a2, b) {
      if (!b) {
        return [a2];
      }
      if (a2.startLineNumber < b.startLineNumber && b.endLineNumberExclusive < a2.endLineNumberExclusive) {
        return [
          new _LineRange(a2.startLineNumber, b.startLineNumber),
          new _LineRange(b.endLineNumberExclusive, a2.endLineNumberExclusive)
        ];
      } else if (b.startLineNumber <= a2.startLineNumber && a2.endLineNumberExclusive <= b.endLineNumberExclusive) {
        return [];
      } else if (b.endLineNumberExclusive < a2.endLineNumberExclusive) {
        return [new _LineRange(Math.max(b.endLineNumberExclusive, a2.startLineNumber), a2.endLineNumberExclusive)];
      } else {
        return [new _LineRange(a2.startLineNumber, Math.min(b.startLineNumber, a2.endLineNumberExclusive))];
      }
    }
    /**
     * @param lineRanges An array of sorted line ranges.
     */
    static joinMany(lineRanges) {
      if (lineRanges.length === 0) {
        return [];
      }
      let result = lineRanges[0];
      for (let i = 1; i < lineRanges.length; i++) {
        result = this.join(result, lineRanges[i]);
      }
      return result;
    }
    /**
     * @param lineRanges1 Must be sorted.
     * @param lineRanges2 Must be sorted.
     */
    static join(lineRanges1, lineRanges2) {
      if (lineRanges1.length === 0) {
        return lineRanges2;
      }
      if (lineRanges2.length === 0) {
        return lineRanges1;
      }
      const result = [];
      let i1 = 0;
      let i2 = 0;
      let current = null;
      while (i1 < lineRanges1.length || i2 < lineRanges2.length) {
        let next = null;
        if (i1 < lineRanges1.length && i2 < lineRanges2.length) {
          const lineRange1 = lineRanges1[i1];
          const lineRange2 = lineRanges2[i2];
          if (lineRange1.startLineNumber < lineRange2.startLineNumber) {
            next = lineRange1;
            i1++;
          } else {
            next = lineRange2;
            i2++;
          }
        } else if (i1 < lineRanges1.length) {
          next = lineRanges1[i1];
          i1++;
        } else {
          next = lineRanges2[i2];
          i2++;
        }
        if (current === null) {
          current = next;
        } else {
          if (current.endLineNumberExclusive >= next.startLineNumber) {
            current = new _LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));
          } else {
            result.push(current);
            current = next;
          }
        }
      }
      if (current !== null) {
        result.push(current);
      }
      return result;
    }
    static ofLength(startLineNumber, length) {
      return new _LineRange(startLineNumber, startLineNumber + length);
    }
    /**
     * @internal
     */
    static deserialize(lineRange) {
      return new _LineRange(lineRange[0], lineRange[1]);
    }
    constructor(startLineNumber, endLineNumberExclusive) {
      if (startLineNumber > endLineNumberExclusive) {
        throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);
      }
      this.startLineNumber = startLineNumber;
      this.endLineNumberExclusive = endLineNumberExclusive;
    }
    /**
     * Indicates if this line range contains the given line number.
     */
    contains(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty() {
      return this.startLineNumber === this.endLineNumberExclusive;
    }
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset) {
      return new _LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);
    }
    /**
     * The number of lines this line range spans.
     */
    get length() {
      return this.endLineNumberExclusive - this.startLineNumber;
    }
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other) {
      return new _LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));
    }
    toString() {
      return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
    }
    /**
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);
      const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);
      if (startLineNumber <= endLineNumberExclusive) {
        return new _LineRange(startLineNumber, endLineNumberExclusive);
      }
      return void 0;
    }
    intersectsStrict(other) {
      return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;
    }
    overlapOrTouch(other) {
      return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;
    }
    equals(b) {
      return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;
    }
    toInclusiveRange() {
      if (this.isEmpty) {
        return null;
      }
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
    }
    toExclusiveRange() {
      return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
    }
    mapToLineArray(f2) {
      const result = [];
      for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {
        result.push(f2(lineNumber));
      }
      return result;
    }
    /**
     * @internal
     */
    serialize() {
      return [this.startLineNumber, this.endLineNumberExclusive];
    }
    includes(lineNumber) {
      return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js
  var LinesDiff = class {
    constructor(changes, moves, hitTimeout) {
      this.changes = changes;
      this.moves = moves;
      this.hitTimeout = hitTimeout;
    }
  };
  var LineRangeMapping = class _LineRangeMapping {
    static inverse(mapping, originalLineCount, modifiedLineCount) {
      const result = [];
      let lastOriginalEndLineNumber = 1;
      let lastModifiedEndLineNumber = 1;
      for (const m of mapping) {
        const r2 = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.originalRange.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modifiedRange.startLineNumber), void 0);
        if (!r2.modifiedRange.isEmpty) {
          result.push(r2);
        }
        lastOriginalEndLineNumber = m.originalRange.endLineNumberExclusive;
        lastModifiedEndLineNumber = m.modifiedRange.endLineNumberExclusive;
      }
      const r = new _LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), void 0);
      if (!r.modifiedRange.isEmpty) {
        result.push(r);
      }
      return result;
    }
    constructor(originalRange, modifiedRange, innerChanges) {
      this.originalRange = originalRange;
      this.modifiedRange = modifiedRange;
      this.innerChanges = innerChanges;
    }
    toString() {
      return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    get changedLineCount() {
      return Math.max(this.originalRange.length, this.modifiedRange.length);
    }
    flip() {
      var _a3;
      return new _LineRangeMapping(this.modifiedRange, this.originalRange, (_a3 = this.innerChanges) === null || _a3 === void 0 ? void 0 : _a3.map((c) => c.flip()));
    }
  };
  var RangeMapping = class _RangeMapping {
    constructor(originalRange, modifiedRange) {
      this.originalRange = originalRange;
      this.modifiedRange = modifiedRange;
    }
    toString() {
      return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    flip() {
      return new _RangeMapping(this.modifiedRange, this.originalRange);
    }
  };
  var SimpleLineRangeMapping = class _SimpleLineRangeMapping {
    constructor(originalRange, modifiedRange) {
      this.originalRange = originalRange;
      this.modifiedRange = modifiedRange;
    }
    toString() {
      return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
    }
    flip() {
      return new _SimpleLineRangeMapping(this.modifiedRange, this.originalRange);
    }
  };
  var MovedText = class _MovedText {
    constructor(lineRangeMapping, changes) {
      this.lineRangeMapping = lineRangeMapping;
      this.changes = changes;
    }
    flip() {
      return new _MovedText(this.lineRangeMapping.flip(), this.changes.map((c) => c.flip()));
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js
  var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
  var SmartLinesDiffComputer = class {
    computeDiff(originalLines, modifiedLines, options) {
      var _a3;
      const diffComputer = new DiffComputer(originalLines, modifiedLines, {
        maxComputationTime: options.maxComputationTimeMs,
        shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,
        shouldComputeCharChanges: true,
        shouldMakePrettyDiff: true,
        shouldPostProcessCharChanges: true
      });
      const result = diffComputer.computeDiff();
      const changes = [];
      let lastChange = null;
      for (const c of result.changes) {
        let originalRange;
        if (c.originalEndLineNumber === 0) {
          originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);
        } else {
          originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);
        }
        let modifiedRange;
        if (c.modifiedEndLineNumber === 0) {
          modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);
        } else {
          modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);
        }
        let change = new LineRangeMapping(originalRange, modifiedRange, (_a3 = c.charChanges) === null || _a3 === void 0 ? void 0 : _a3.map((c2) => new RangeMapping(new Range(c2.originalStartLineNumber, c2.originalStartColumn, c2.originalEndLineNumber, c2.originalEndColumn), new Range(c2.modifiedStartLineNumber, c2.modifiedStartColumn, c2.modifiedEndLineNumber, c2.modifiedEndColumn))));
        if (lastChange) {
          if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {
            change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ? lastChange.innerChanges.concat(change.innerChanges) : void 0);
            changes.pop();
          }
        }
        changes.push(change);
        lastChange = change;
      }
      assertFn(() => {
        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
        m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);
      });
      return new LinesDiff(changes, [], result.quitEarly);
    }
  };
  function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
  }
  var LineSequence = class {
    constructor(lines) {
      const startColumns = [];
      const endColumns = [];
      for (let i = 0, length = lines.length; i < length; i++) {
        startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
        endColumns[i] = getLastNonBlankColumn(lines[i], 1);
      }
      this.lines = lines;
      this._startColumns = startColumns;
      this._endColumns = endColumns;
    }
    getElements() {
      const elements = [];
      for (let i = 0, len = this.lines.length; i < len; i++) {
        elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
      }
      return elements;
    }
    getStrictElement(index) {
      return this.lines[index];
    }
    getStartLineNumber(i) {
      return i + 1;
    }
    getEndLineNumber(i) {
      return i + 1;
    }
    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {
      const charCodes = [];
      const lineNumbers = [];
      const columns = [];
      let len = 0;
      for (let index = startIndex; index <= endIndex; index++) {
        const lineContent = this.lines[index];
        const startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;
        const endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;
        for (let col = startColumn; col < endColumn; col++) {
          charCodes[len] = lineContent.charCodeAt(col - 1);
          lineNumbers[len] = index + 1;
          columns[len] = col;
          len++;
        }
        if (!shouldIgnoreTrimWhitespace && index < endIndex) {
          charCodes[len] = 10;
          lineNumbers[len] = index + 1;
          columns[len] = lineContent.length + 1;
          len++;
        }
      }
      return new CharSequence(charCodes, lineNumbers, columns);
    }
  };
  var CharSequence = class {
    constructor(charCodes, lineNumbers, columns) {
      this._charCodes = charCodes;
      this._lineNumbers = lineNumbers;
      this._columns = columns;
    }
    toString() {
      return "[" + this._charCodes.map((s, idx) => (s === 10 ? "\\n" : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(", ") + "]";
    }
    _assertIndex(index, arr) {
      if (index < 0 || index >= arr.length) {
        throw new Error(`Illegal index`);
      }
    }
    getElements() {
      return this._charCodes;
    }
    getStartLineNumber(i) {
      if (i > 0 && i === this._lineNumbers.length) {
        return this.getEndLineNumber(i - 1);
      }
      this._assertIndex(i, this._lineNumbers);
      return this._lineNumbers[i];
    }
    getEndLineNumber(i) {
      if (i === -1) {
        return this.getStartLineNumber(i + 1);
      }
      this._assertIndex(i, this._lineNumbers);
      if (this._charCodes[i] === 10) {
        return this._lineNumbers[i] + 1;
      }
      return this._lineNumbers[i];
    }
    getStartColumn(i) {
      if (i > 0 && i === this._columns.length) {
        return this.getEndColumn(i - 1);
      }
      this._assertIndex(i, this._columns);
      return this._columns[i];
    }
    getEndColumn(i) {
      if (i === -1) {
        return this.getStartColumn(i + 1);
      }
      this._assertIndex(i, this._columns);
      if (this._charCodes[i] === 10) {
        return 1;
      }
      return this._columns[i] + 1;
    }
  };
  var CharChange = class _CharChange {
    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalStartColumn = originalStartColumn;
      this.originalEndLineNumber = originalEndLineNumber;
      this.originalEndColumn = originalEndColumn;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedStartColumn = modifiedStartColumn;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.modifiedEndColumn = modifiedEndColumn;
    }
    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {
      const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
      const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
      const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
      const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
      const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
      const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      return new _CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    }
  };
  function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
      return rawChanges;
    }
    const result = [rawChanges[0]];
    let prevChange = result[0];
    for (let i = 1, len = rawChanges.length; i < len; i++) {
      const currChange = rawChanges[i];
      const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
      const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
      const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
      if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
        prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;
        prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;
      } else {
        result.push(currChange);
        prevChange = currChange;
      }
    }
    return result;
  }
  var LineChange = class _LineChange {
    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
      this.originalStartLineNumber = originalStartLineNumber;
      this.originalEndLineNumber = originalEndLineNumber;
      this.modifiedStartLineNumber = modifiedStartLineNumber;
      this.modifiedEndLineNumber = modifiedEndLineNumber;
      this.charChanges = charChanges;
    }
    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
      let originalStartLineNumber;
      let originalEndLineNumber;
      let modifiedStartLineNumber;
      let modifiedEndLineNumber;
      let charChanges = void 0;
      if (diffChange.originalLength === 0) {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
        originalEndLineNumber = 0;
      } else {
        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
        originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
      }
      if (diffChange.modifiedLength === 0) {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
        modifiedEndLineNumber = 0;
      } else {
        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
        modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
      }
      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
        const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
        const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
        if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {
          let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
          if (shouldPostProcessCharChanges) {
            rawChanges = postProcessCharChanges(rawChanges);
          }
          charChanges = [];
          for (let i = 0, length = rawChanges.length; i < length; i++) {
            charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
          }
        }
      }
      return new _LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    }
  };
  var DiffComputer = class {
    constructor(originalLines, modifiedLines, opts) {
      this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
      this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
      this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
      this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
      this.originalLines = originalLines;
      this.modifiedLines = modifiedLines;
      this.original = new LineSequence(originalLines);
      this.modified = new LineSequence(modifiedLines);
      this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
      this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5e3));
    }
    computeDiff() {
      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
          return {
            quitEarly: false,
            changes: []
          };
        }
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: 1,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: this.modified.lines.length,
            charChanges: void 0
          }]
        };
      }
      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
        return {
          quitEarly: false,
          changes: [{
            originalStartLineNumber: 1,
            originalEndLineNumber: this.original.lines.length,
            modifiedStartLineNumber: 1,
            modifiedEndLineNumber: 1,
            charChanges: void 0
          }]
        };
      }
      const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
      const rawChanges = diffResult.changes;
      const quitEarly = diffResult.quitEarly;
      if (this.shouldIgnoreTrimWhitespace) {
        const lineChanges = [];
        for (let i = 0, length = rawChanges.length; i < length; i++) {
          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
        }
        return {
          quitEarly,
          changes: lineChanges
        };
      }
      const result = [];
      let originalLineIndex = 0;
      let modifiedLineIndex = 0;
      for (let i = -1, len = rawChanges.length; i < len; i++) {
        const nextChange = i + 1 < len ? rawChanges[i + 1] : null;
        const originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;
        const modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;
        while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
          const originalLine = this.originalLines[originalLineIndex];
          const modifiedLine = this.modifiedLines[modifiedLineIndex];
          if (originalLine !== modifiedLine) {
            {
              let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
              let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
              while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                const originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalStartColumn--;
                modifiedStartColumn--;
              }
              if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
              }
            }
            {
              let originalEndColumn = getLastNonBlankColumn(originalLine, 1);
              let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
              const originalMaxColumn = originalLine.length + 1;
              const modifiedMaxColumn = modifiedLine.length + 1;
              while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                const originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                if (originalChar !== modifiedChar) {
                  break;
                }
                originalEndColumn++;
                modifiedEndColumn++;
              }
              if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
              }
            }
          }
          originalLineIndex++;
          modifiedLineIndex++;
        }
        if (nextChange) {
          result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
          originalLineIndex += nextChange.originalLength;
          modifiedLineIndex += nextChange.modifiedLength;
        }
      }
      return {
        quitEarly,
        changes: result
      };
    }
    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
        return;
      }
      let charChanges = void 0;
      if (this.shouldComputeCharChanges) {
        charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
      }
      result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    }
    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
      const len = result.length;
      if (len === 0) {
        return false;
      }
      const prevChange = result[len - 1];
      if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
        return false;
      }
      if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
        prevChange.originalEndLineNumber = originalLineNumber;
        prevChange.modifiedEndLineNumber = modifiedLineNumber;
        if (this.shouldComputeCharChanges && prevChange.charChanges) {
          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
        }
        return true;
      }
      return false;
    }
  };
  function getFirstNonBlankColumn(txt, defaultValue) {
    const r = firstNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 1;
  }
  function getLastNonBlankColumn(txt, defaultValue) {
    const r = lastNonWhitespaceIndex(txt);
    if (r === -1) {
      return defaultValue;
    }
    return r + 2;
  }
  function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
      return () => true;
    }
    const startTime = Date.now();
    return () => {
      return Date.now() - startTime < maximumRuntime;
    };
  }

  // node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js
  var OffsetRange = class _OffsetRange {
    static addRange(range, sortedRanges) {
      let i = 0;
      while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {
        i++;
      }
      let j = i;
      while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {
        j++;
      }
      if (i === j) {
        sortedRanges.splice(i, 0, range);
      } else {
        const start = Math.min(range.start, sortedRanges[i].start);
        const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);
        sortedRanges.splice(i, j - i, new _OffsetRange(start, end));
      }
    }
    static tryCreate(start, endExclusive) {
      if (start > endExclusive) {
        return void 0;
      }
      return new _OffsetRange(start, endExclusive);
    }
    constructor(start, endExclusive) {
      this.start = start;
      this.endExclusive = endExclusive;
      if (start > endExclusive) {
        throw new BugIndicatingError(`Invalid range: ${this.toString()}`);
      }
    }
    get isEmpty() {
      return this.start === this.endExclusive;
    }
    delta(offset) {
      return new _OffsetRange(this.start + offset, this.endExclusive + offset);
    }
    get length() {
      return this.endExclusive - this.start;
    }
    toString() {
      return `[${this.start}, ${this.endExclusive})`;
    }
    equals(other) {
      return this.start === other.start && this.endExclusive === other.endExclusive;
    }
    containsRange(other) {
      return this.start <= other.start && other.endExclusive <= this.endExclusive;
    }
    /**
     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
     * The joined range is the smallest range that contains both ranges.
     */
    join(other) {
      return new _OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));
    }
    /**
     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
     *
     * The resulting range is empty if the ranges do not intersect, but touch.
     * If the ranges don't even touch, the result is undefined.
     */
    intersect(other) {
      const start = Math.max(this.start, other.start);
      const end = Math.min(this.endExclusive, other.endExclusive);
      if (start <= end) {
        return new _OffsetRange(start, end);
      }
      return void 0;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js
  var DiffAlgorithmResult = class _DiffAlgorithmResult {
    static trivial(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], false);
    }
    static trivialTimedOut(seq1, seq2) {
      return new _DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], true);
    }
    constructor(diffs, hitTimeout) {
      this.diffs = diffs;
      this.hitTimeout = hitTimeout;
    }
  };
  var SequenceDiff = class _SequenceDiff {
    constructor(seq1Range, seq2Range) {
      this.seq1Range = seq1Range;
      this.seq2Range = seq2Range;
    }
    reverse() {
      return new _SequenceDiff(this.seq2Range, this.seq1Range);
    }
    toString() {
      return `${this.seq1Range} <-> ${this.seq2Range}`;
    }
    join(other) {
      return new _SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));
    }
    delta(offset) {
      if (offset === 0) {
        return this;
      }
      return new _SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));
    }
  };
  var InfiniteTimeout = class {
    isValid() {
      return true;
    }
  };
  InfiniteTimeout.instance = new InfiniteTimeout();
  var DateTimeout = class {
    constructor(timeout) {
      this.timeout = timeout;
      this.startTime = Date.now();
      this.valid = true;
      if (timeout <= 0) {
        throw new BugIndicatingError("timeout must be positive");
      }
    }
    // Recommendation: Set a log-point `{this.disable()}` in the body
    isValid() {
      const valid = Date.now() - this.startTime < this.timeout;
      if (!valid && this.valid) {
        this.valid = false;
        debugger;
      }
      return this.valid;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js
  var Array2D = class {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.array = [];
      this.array = new Array(width * height);
    }
    get(x, y) {
      return this.array[x + y * this.width];
    }
    set(x, y, value) {
      this.array[x + y * this.width] = value;
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js
  var DynamicProgrammingDiffing = class {
    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {
      if (sequence1.length === 0 || sequence2.length === 0) {
        return DiffAlgorithmResult.trivial(sequence1, sequence2);
      }
      const lcsLengths = new Array2D(sequence1.length, sequence2.length);
      const directions = new Array2D(sequence1.length, sequence2.length);
      const lengths = new Array2D(sequence1.length, sequence2.length);
      for (let s12 = 0; s12 < sequence1.length; s12++) {
        for (let s22 = 0; s22 < sequence2.length; s22++) {
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);
          }
          const horizontalLen = s12 === 0 ? 0 : lcsLengths.get(s12 - 1, s22);
          const verticalLen = s22 === 0 ? 0 : lcsLengths.get(s12, s22 - 1);
          let extendedSeqScore;
          if (sequence1.getElement(s12) === sequence2.getElement(s22)) {
            if (s12 === 0 || s22 === 0) {
              extendedSeqScore = 0;
            } else {
              extendedSeqScore = lcsLengths.get(s12 - 1, s22 - 1);
            }
            if (s12 > 0 && s22 > 0 && directions.get(s12 - 1, s22 - 1) === 3) {
              extendedSeqScore += lengths.get(s12 - 1, s22 - 1);
            }
            extendedSeqScore += equalityScore ? equalityScore(s12, s22) : 1;
          } else {
            extendedSeqScore = -1;
          }
          const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);
          if (newValue === extendedSeqScore) {
            const prevLen = s12 > 0 && s22 > 0 ? lengths.get(s12 - 1, s22 - 1) : 0;
            lengths.set(s12, s22, prevLen + 1);
            directions.set(s12, s22, 3);
          } else if (newValue === horizontalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 1);
          } else if (newValue === verticalLen) {
            lengths.set(s12, s22, 0);
            directions.set(s12, s22, 2);
          }
          lcsLengths.set(s12, s22, newValue);
        }
      }
      const result = [];
      let lastAligningPosS1 = sequence1.length;
      let lastAligningPosS2 = sequence2.length;
      function reportDecreasingAligningPositions(s12, s22) {
        if (s12 + 1 !== lastAligningPosS1 || s22 + 1 !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(s12 + 1, lastAligningPosS1), new OffsetRange(s22 + 1, lastAligningPosS2)));
        }
        lastAligningPosS1 = s12;
        lastAligningPosS2 = s22;
      }
      let s1 = sequence1.length - 1;
      let s2 = sequence2.length - 1;
      while (s1 >= 0 && s2 >= 0) {
        if (directions.get(s1, s2) === 3) {
          reportDecreasingAligningPositions(s1, s2);
          s1--;
          s2--;
        } else {
          if (directions.get(s1, s2) === 1) {
            s1--;
          } else {
            s2--;
          }
        }
      }
      reportDecreasingAligningPositions(-1, -1);
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js
  function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    let result = sequenceDiffs;
    result = joinSequenceDiffs(sequence1, sequence2, result);
    result = shiftSequenceDiffs(sequence1, sequence2, result);
    return result;
  }
  function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    for (const s of sequenceDiffs) {
      const last = result[result.length - 1];
      if (!last) {
        result.push(s);
        continue;
      }
      if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {
        result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));
      } else {
        result.push(s);
      }
    }
    return result;
  }
  function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    const result = [];
    if (sequenceDiffs.length > 0) {
      result.push(sequenceDiffs[0]);
    }
    for (let i = 1; i < sequenceDiffs.length; i++) {
      const prevResult = sequenceDiffs[i - 1];
      let cur = sequenceDiffs[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;
        let d;
        for (d = 1; d <= length; d++) {
          if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) || sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {
            break;
          }
        }
        d--;
        if (d === length) {
          result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));
          continue;
        }
        cur = cur.delta(-d);
      }
      result.push(cur);
    }
    const result2 = [];
    for (let i = 0; i < result.length - 1; i++) {
      const nextResult = result[i + 1];
      let cur = result[i];
      if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {
        const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;
        let d;
        for (d = 0; d < length; d++) {
          if (sequence1.getElement(cur.seq1Range.start + d) !== sequence1.getElement(cur.seq1Range.endExclusive + d) || sequence2.getElement(cur.seq2Range.start + d) !== sequence2.getElement(cur.seq2Range.endExclusive + d)) {
            break;
          }
        }
        if (d === length) {
          result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));
          continue;
        }
        if (d > 0) {
          cur = cur.delta(d);
        }
      }
      result2.push(cur);
    }
    if (result.length > 0) {
      result2.push(result[result.length - 1]);
    }
    return result2;
  }
  function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {
    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {
      return sequenceDiffs;
    }
    for (let i = 0; i < sequenceDiffs.length; i++) {
      const prevDiff = i > 0 ? sequenceDiffs[i - 1] : void 0;
      const diff = sequenceDiffs[i];
      const nextDiff = i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : void 0;
      const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.start + 1 : 0, nextDiff ? nextDiff.seq1Range.endExclusive - 1 : sequence1.length);
      const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.start + 1 : 0, nextDiff ? nextDiff.seq2Range.endExclusive - 1 : sequence2.length);
      if (diff.seq1Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);
      } else if (diff.seq2Range.isEmpty) {
        sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).reverse();
      }
    }
    return sequenceDiffs;
  }
  function shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {
    const maxShiftLimit = 100;
    let deltaBefore = 1;
    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start && diff.seq2Range.start - deltaBefore >= seq2ValidRange.start && sequence2.getElement(diff.seq2Range.start - deltaBefore) === sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {
      deltaBefore++;
    }
    deltaBefore--;
    let deltaAfter = 0;
    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive && diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive && sequence2.getElement(diff.seq2Range.start + deltaAfter) === sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {
      deltaAfter++;
    }
    if (deltaBefore === 0 && deltaAfter === 0) {
      return diff;
    }
    let bestDelta = 0;
    let bestScore = -1;
    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {
      const seq2OffsetStart = diff.seq2Range.start + delta;
      const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;
      const seq1Offset = diff.seq1Range.start + delta;
      const score2 = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);
      if (score2 > bestScore) {
        bestScore = score2;
        bestDelta = delta;
      }
    }
    return diff.delta(bestDelta);
  }

  // node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js
  var MyersDiffAlgorithm = class {
    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {
      if (seq1.length === 0 || seq2.length === 0) {
        return DiffAlgorithmResult.trivial(seq1, seq2);
      }
      function getXAfterSnake(x, y) {
        while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {
          x++;
          y++;
        }
        return x;
      }
      let d = 0;
      const V = new FastInt32Array();
      V.set(0, getXAfterSnake(0, 0));
      const paths = new FastArrayNegativeIndices();
      paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));
      let k = 0;
      loop:
        while (true) {
          d++;
          if (!timeout.isValid()) {
            return DiffAlgorithmResult.trivialTimedOut(seq1, seq2);
          }
          const lowerBound = -Math.min(d, seq2.length + d % 2);
          const upperBound = Math.min(d, seq1.length + d % 2);
          for (k = lowerBound; k <= upperBound; k += 2) {
            const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1);
            const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1;
            const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);
            const y = x - k;
            if (x > seq1.length || y > seq2.length) {
              continue;
            }
            const newMaxX = getXAfterSnake(x, y);
            V.set(k, newMaxX);
            const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);
            paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);
            if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {
              break loop;
            }
          }
        }
      let path5 = paths.get(k);
      const result = [];
      let lastAligningPosS1 = seq1.length;
      let lastAligningPosS2 = seq2.length;
      while (true) {
        const endX = path5 ? path5.x + path5.length : 0;
        const endY = path5 ? path5.y + path5.length : 0;
        if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {
          result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));
        }
        if (!path5) {
          break;
        }
        lastAligningPosS1 = path5.x;
        lastAligningPosS2 = path5.y;
        path5 = path5.prev;
      }
      result.reverse();
      return new DiffAlgorithmResult(result, false);
    }
  };
  var SnakePath = class {
    constructor(prev, x, y, length) {
      this.prev = prev;
      this.x = x;
      this.y = y;
      this.length = length;
    }
  };
  var FastInt32Array = class {
    constructor() {
      this.positiveArr = new Int32Array(10);
      this.negativeArr = new Int32Array(10);
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value) {
      if (idx < 0) {
        idx = -idx - 1;
        if (idx >= this.negativeArr.length) {
          const arr = this.negativeArr;
          this.negativeArr = new Int32Array(arr.length * 2);
          this.negativeArr.set(arr);
        }
        this.negativeArr[idx] = value;
      } else {
        if (idx >= this.positiveArr.length) {
          const arr = this.positiveArr;
          this.positiveArr = new Int32Array(arr.length * 2);
          this.positiveArr.set(arr);
        }
        this.positiveArr[idx] = value;
      }
    }
  };
  var FastArrayNegativeIndices = class {
    constructor() {
      this.positiveArr = [];
      this.negativeArr = [];
    }
    get(idx) {
      if (idx < 0) {
        idx = -idx - 1;
        return this.negativeArr[idx];
      } else {
        return this.positiveArr[idx];
      }
    }
    set(idx, value) {
      if (idx < 0) {
        idx = -idx - 1;
        this.negativeArr[idx] = value;
      } else {
        this.positiveArr[idx] = value;
      }
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js
  var StandardLinesDiffComputer = class {
    constructor() {
      this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();
      this.myersDiffingAlgorithm = new MyersDiffAlgorithm();
    }
    computeDiff(originalLines, modifiedLines, options) {
      const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);
      const considerWhitespaceChanges = !options.ignoreTrimWhitespace;
      const perfectHashes = /* @__PURE__ */ new Map();
      function getOrCreateHash(text) {
        let hash = perfectHashes.get(text);
        if (hash === void 0) {
          hash = perfectHashes.size;
          perfectHashes.set(text, hash);
        }
        return hash;
      }
      const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));
      const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));
      const sequence1 = new LineSequence2(srcDocLines, originalLines);
      const sequence2 = new LineSequence2(tgtDocLines, modifiedLines);
      const lineAlignmentResult = (() => {
        if (sequence1.length + sequence2.length < 1500) {
          return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2] ? modifiedLines[offset2].length === 0 ? 0.1 : 1 + Math.log(1 + modifiedLines[offset2].length) : 0.99);
        }
        return this.myersDiffingAlgorithm.compute(sequence1, sequence2);
      })();
      let lineAlignments = lineAlignmentResult.diffs;
      let hitTimeout = lineAlignmentResult.hitTimeout;
      lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);
      const alignments = [];
      const scanForWhitespaceChanges = (equalLinesCount) => {
        if (!considerWhitespaceChanges) {
          return;
        }
        for (let i = 0; i < equalLinesCount; i++) {
          const seq1Offset = seq1LastStart + i;
          const seq2Offset = seq2LastStart + i;
          if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {
            const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);
            for (const a2 of characterDiffs.mappings) {
              alignments.push(a2);
            }
            if (characterDiffs.hitTimeout) {
              hitTimeout = true;
            }
          }
        }
      };
      let seq1LastStart = 0;
      let seq2LastStart = 0;
      for (const diff of lineAlignments) {
        assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);
        const equalLinesCount = diff.seq1Range.start - seq1LastStart;
        scanForWhitespaceChanges(equalLinesCount);
        seq1LastStart = diff.seq1Range.endExclusive;
        seq2LastStart = diff.seq2Range.endExclusive;
        const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);
        if (characterDiffs.hitTimeout) {
          hitTimeout = true;
        }
        for (const a2 of characterDiffs.mappings) {
          alignments.push(a2);
        }
      }
      scanForWhitespaceChanges(originalLines.length - seq1LastStart);
      const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);
      const moves = [];
      if (options.computeMoves) {
        const deletions = changes.filter((c) => c.modifiedRange.isEmpty && c.originalRange.length >= 3).map((d) => new LineRangeFragment(d.originalRange, originalLines));
        const insertions = new Set(changes.filter((c) => c.originalRange.isEmpty && c.modifiedRange.length >= 3).map((d) => new LineRangeFragment(d.modifiedRange, modifiedLines)));
        for (const deletion of deletions) {
          let highestSimilarity = -1;
          let best;
          for (const insertion of insertions) {
            const similarity = deletion.computeSimilarity(insertion);
            if (similarity > highestSimilarity) {
              highestSimilarity = similarity;
              best = insertion;
            }
          }
          if (highestSimilarity > 0.9 && best) {
            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(deletion.range.startLineNumber - 1, deletion.range.endLineNumberExclusive - 1), new OffsetRange(best.range.startLineNumber - 1, best.range.endLineNumberExclusive - 1)), timeout, considerWhitespaceChanges);
            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);
            insertions.delete(best);
            moves.push(new MovedText(new SimpleLineRangeMapping(deletion.range, best.range), mappings));
          }
        }
      }
      return new LinesDiff(changes, moves, hitTimeout);
    }
    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {
      const slice1 = new Slice(originalLines, diff.seq1Range, considerWhitespaceChanges);
      const slice2 = new Slice(modifiedLines, diff.seq2Range, considerWhitespaceChanges);
      const diffResult = slice1.length + slice2.length < 500 ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout) : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);
      let diffs = diffResult.diffs;
      diffs = optimizeSequenceDiffs(slice1, slice2, diffs);
      diffs = coverFullWords(slice1, slice2, diffs);
      diffs = smoothenSequenceDiffs(slice1, slice2, diffs);
      const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));
      return {
        mappings: result,
        hitTimeout: diffResult.hitTimeout
      };
    }
  };
  function coverFullWords(sequence1, sequence2, sequenceDiffs) {
    const additional = [];
    let lastModifiedWord = void 0;
    function maybePushWordToAdditional() {
      if (!lastModifiedWord) {
        return;
      }
      const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;
      const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;
      if (originalLength1 !== originalLength2) {
      }
      if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {
        additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));
      }
      lastModifiedWord = void 0;
    }
    for (const s of sequenceDiffs) {
      let processWord = function(s1Range, s2Range) {
        var _a3, _b, _c, _d;
        if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {
          if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {
            const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);
            const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);
            lastModifiedWord.deleted += (_a3 = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a3 !== void 0 ? _a3 : 0;
            lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;
            lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);
            lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);
          } else {
            maybePushWordToAdditional();
            lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range, s2Range };
          }
        }
        const changedS1 = s1Range.intersect(s.seq1Range);
        const changedS2 = s2Range.intersect(s.seq2Range);
        lastModifiedWord.count++;
        lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;
        lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;
      };
      const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);
      const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);
      const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);
      const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);
      if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {
        processWord(w1Before, w2Before);
      } else {
        if (w1Before && w2Before) {
          processWord(w1Before, w2Before);
        }
        if (w1After && w2After) {
          processWord(w1After, w2After);
        }
      }
    }
    maybePushWordToAdditional();
    const merged = mergeSequenceDiffs(sequenceDiffs, additional);
    return merged;
  }
  function mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {
    const result = [];
    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {
      const sd1 = sequenceDiffs1[0];
      const sd2 = sequenceDiffs2[0];
      let next;
      if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {
        next = sequenceDiffs1.shift();
      } else {
        next = sequenceDiffs2.shift();
      }
      if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {
        result[result.length - 1] = result[result.length - 1].join(next);
      } else {
        result.push(next);
      }
    }
    return result;
  }
  function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {
    const changes = [];
    for (const g of group(alignments.map((a2) => getLineRangeMapping(a2, originalLines, modifiedLines)), (a1, a2) => a1.originalRange.overlapOrTouch(a2.originalRange) || a1.modifiedRange.overlapOrTouch(a2.modifiedRange))) {
      const first = g[0];
      const last = g[g.length - 1];
      changes.push(new LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map((a2) => a2.innerChanges[0])));
    }
    assertFn(() => {
      if (!dontAssertStartLine) {
        if (changes.length > 0 && changes[0].originalRange.startLineNumber !== changes[0].modifiedRange.startLineNumber) {
          return false;
        }
      }
      return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
      m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber && m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);
    });
    return changes;
  }
  function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {
    let lineStartDelta = 0;
    let lineEndDelta = 0;
    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1 && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {
      lineEndDelta = -1;
    }
    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {
      lineStartDelta = 1;
    }
    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);
    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);
    return new LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);
  }
  function* group(items, shouldBeGrouped) {
    let currentGroup;
    let last;
    for (const item of items) {
      if (last !== void 0 && shouldBeGrouped(last, item)) {
        currentGroup.push(item);
      } else {
        if (currentGroup) {
          yield currentGroup;
        }
        currentGroup = [item];
      }
      last = item;
    }
    if (currentGroup) {
      yield currentGroup;
    }
  }
  var LineSequence2 = class {
    constructor(trimmedHash, lines) {
      this.trimmedHash = trimmedHash;
      this.lines = lines;
    }
    getElement(offset) {
      return this.trimmedHash[offset];
    }
    get length() {
      return this.trimmedHash.length;
    }
    getBoundaryScore(length) {
      const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);
      const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);
      return 1e3 - (indentationBefore + indentationAfter);
    }
  };
  function getIndentation(str) {
    let i = 0;
    while (i < str.length && (str.charCodeAt(i) === 32 || str.charCodeAt(i) === 9)) {
      i++;
    }
    return i;
  }
  var Slice = class {
    constructor(lines, lineRange, considerWhitespaceChanges) {
      this.lines = lines;
      this.considerWhitespaceChanges = considerWhitespaceChanges;
      this.elements = [];
      this.firstCharOffsetByLineMinusOne = [];
      this.offsetByLine = [];
      let trimFirstLineFully = false;
      if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {
        lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);
        trimFirstLineFully = true;
      }
      this.lineRange = lineRange;
      for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {
        let line = lines[i];
        let offset = 0;
        if (trimFirstLineFully) {
          offset = line.length;
          line = "";
          trimFirstLineFully = false;
        } else if (!considerWhitespaceChanges) {
          const trimmedStartLine = line.trimStart();
          offset = line.length - trimmedStartLine.length;
          line = trimmedStartLine.trimEnd();
        }
        this.offsetByLine.push(offset);
        for (let i2 = 0; i2 < line.length; i2++) {
          this.elements.push(line.charCodeAt(i2));
        }
        if (i < lines.length - 1) {
          this.elements.push("\n".charCodeAt(0));
          this.firstCharOffsetByLineMinusOne[i - this.lineRange.start] = this.elements.length;
        }
      }
      this.offsetByLine.push(0);
    }
    toString() {
      return `Slice: "${this.text}"`;
    }
    get text() {
      return [...this.elements].map((e) => String.fromCharCode(e)).join("");
    }
    getElement(offset) {
      return this.elements[offset];
    }
    get length() {
      return this.elements.length;
    }
    getBoundaryScore(length) {
      const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);
      const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);
      if (prevCategory === 6 && nextCategory === 7) {
        return 0;
      }
      let score2 = 0;
      if (prevCategory !== nextCategory) {
        score2 += 10;
        if (nextCategory === 1) {
          score2 += 1;
        }
      }
      score2 += getCategoryBoundaryScore(prevCategory);
      score2 += getCategoryBoundaryScore(nextCategory);
      return score2;
    }
    translateOffset(offset) {
      if (this.lineRange.isEmpty) {
        return new Position(this.lineRange.start + 1, 1);
      }
      let i = 0;
      let j = this.firstCharOffsetByLineMinusOne.length;
      while (i < j) {
        const k = Math.floor((i + j) / 2);
        if (this.firstCharOffsetByLineMinusOne[k] > offset) {
          j = k;
        } else {
          i = k + 1;
        }
      }
      const offsetOfFirstCharInLine = i === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i - 1];
      return new Position(this.lineRange.start + i + 1, offset - offsetOfFirstCharInLine + 1 + this.offsetByLine[i]);
    }
    translateRange(range) {
      return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));
    }
    /**
     * Finds the word that contains the character at the given offset
     */
    findWordContaining(offset) {
      if (offset < 0 || offset >= this.elements.length) {
        return void 0;
      }
      if (!isWordChar(this.elements[offset])) {
        return void 0;
      }
      let start = offset;
      while (start > 0 && isWordChar(this.elements[start - 1])) {
        start--;
      }
      let end = offset;
      while (end < this.elements.length && isWordChar(this.elements[end])) {
        end++;
      }
      return new OffsetRange(start, end);
    }
  };
  function isWordChar(charCode) {
    return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90 || charCode >= 48 && charCode <= 57;
  }
  var score = {
    [
      0
      /* CharBoundaryCategory.WordLower */
    ]: 0,
    [
      1
      /* CharBoundaryCategory.WordUpper */
    ]: 0,
    [
      2
      /* CharBoundaryCategory.WordNumber */
    ]: 0,
    [
      3
      /* CharBoundaryCategory.End */
    ]: 10,
    [
      4
      /* CharBoundaryCategory.Other */
    ]: 2,
    [
      5
      /* CharBoundaryCategory.Space */
    ]: 3,
    [
      6
      /* CharBoundaryCategory.LineBreakCR */
    ]: 10,
    [
      7
      /* CharBoundaryCategory.LineBreakLF */
    ]: 10
  };
  function getCategoryBoundaryScore(category) {
    return score[category];
  }
  function getCategory(charCode) {
    if (charCode === 10) {
      return 7;
    } else if (charCode === 13) {
      return 6;
    } else if (isSpace(charCode)) {
      return 5;
    } else if (charCode >= 97 && charCode <= 122) {
      return 0;
    } else if (charCode >= 65 && charCode <= 90) {
      return 1;
    } else if (charCode >= 48 && charCode <= 57) {
      return 2;
    } else if (charCode === -1) {
      return 3;
    } else {
      return 4;
    }
  }
  function isSpace(charCode) {
    return charCode === 32 || charCode === 9;
  }
  var chrKeys = /* @__PURE__ */ new Map();
  function getKey(chr) {
    let key = chrKeys.get(chr);
    if (key === void 0) {
      key = chrKeys.size;
      chrKeys.set(chr, key);
    }
    return key;
  }
  var LineRangeFragment = class {
    constructor(range, lines) {
      this.range = range;
      this.lines = lines;
      this.histogram = [];
      let counter = 0;
      for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {
        const line = lines[i];
        for (let j = 0; j < line.length; j++) {
          counter++;
          const chr = line[j];
          const key2 = getKey(chr);
          this.histogram[key2] = (this.histogram[key2] || 0) + 1;
        }
        counter++;
        const key = getKey("\n");
        this.histogram[key] = (this.histogram[key] || 0) + 1;
      }
      this.totalCount = counter;
    }
    computeSimilarity(other) {
      var _a3, _b;
      let sumDifferences = 0;
      const maxLength = Math.max(this.histogram.length, other.histogram.length);
      for (let i = 0; i < maxLength; i++) {
        sumDifferences += Math.abs(((_a3 = this.histogram[i]) !== null && _a3 !== void 0 ? _a3 : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));
      }
      return 1 - sumDifferences / (this.totalCount + other.totalCount);
    }
  };

  // node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js
  var linesDiffComputers = {
    getLegacy: () => new SmartLinesDiffComputer(),
    getAdvanced: () => new StandardLinesDiffComputer()
  };

  // node_modules/monaco-editor/esm/vs/base/common/color.js
  function roundFloat(number, decimalPoints) {
    const decimal = Math.pow(10, decimalPoints);
    return Math.round(number * decimal) / decimal;
  }
  var RGBA = class {
    constructor(r, g, b, a2 = 1) {
      this._rgbaBrand = void 0;
      this.r = Math.min(255, Math.max(0, r)) | 0;
      this.g = Math.min(255, Math.max(0, g)) | 0;
      this.b = Math.min(255, Math.max(0, b)) | 0;
      this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
    }
    static equals(a2, b) {
      return a2.r === b.r && a2.g === b.g && a2.b === b.b && a2.a === b.a;
    }
  };
  var HSLA = class _HSLA {
    constructor(h, s, l, a2) {
      this._hslaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
    }
    static equals(a2, b) {
      return a2.h === b.h && a2.s === b.s && a2.l === b.l && a2.a === b.a;
    }
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba) {
      const r = rgba.r / 255;
      const g = rgba.g / 255;
      const b = rgba.b / 255;
      const a2 = rgba.a;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0;
      let s = 0;
      const l = (min + max) / 2;
      const chroma = max - min;
      if (chroma > 0) {
        s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
        switch (max) {
          case r:
            h = (g - b) / chroma + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / chroma + 2;
            break;
          case b:
            h = (r - g) / chroma + 4;
            break;
        }
        h *= 60;
        h = Math.round(h);
      }
      return new _HSLA(h, s, l, a2);
    }
    static _hue2rgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla) {
      const h = hsla.h / 360;
      const { s, l, a: a2 } = hsla;
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = _HSLA._hue2rgb(p, q, h + 1 / 3);
        g = _HSLA._hue2rgb(p, q, h);
        b = _HSLA._hue2rgb(p, q, h - 1 / 3);
      }
      return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a2);
    }
  };
  var HSVA = class _HSVA {
    constructor(h, s, v, a2) {
      this._hsvaBrand = void 0;
      this.h = Math.max(Math.min(360, h), 0) | 0;
      this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);
      this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);
      this.a = roundFloat(Math.max(Math.min(1, a2), 0), 3);
    }
    static equals(a2, b) {
      return a2.h === b.h && a2.s === b.s && a2.v === b.v && a2.a === b.a;
    }
    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
    static fromRGBA(rgba) {
      const r = rgba.r / 255;
      const g = rgba.g / 255;
      const b = rgba.b / 255;
      const cmax = Math.max(r, g, b);
      const cmin = Math.min(r, g, b);
      const delta = cmax - cmin;
      const s = cmax === 0 ? 0 : delta / cmax;
      let m;
      if (delta === 0) {
        m = 0;
      } else if (cmax === r) {
        m = ((g - b) / delta % 6 + 6) % 6;
      } else if (cmax === g) {
        m = (b - r) / delta + 2;
      } else {
        m = (r - g) / delta + 4;
      }
      return new _HSVA(Math.round(m * 60), s, cmax, rgba.a);
    }
    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
    static toRGBA(hsva) {
      const { h, s, v, a: a2 } = hsva;
      const c = v * s;
      const x = c * (1 - Math.abs(h / 60 % 2 - 1));
      const m = v - c;
      let [r, g, b] = [0, 0, 0];
      if (h < 60) {
        r = c;
        g = x;
      } else if (h < 120) {
        r = x;
        g = c;
      } else if (h < 180) {
        g = c;
        b = x;
      } else if (h < 240) {
        g = x;
        b = c;
      } else if (h < 300) {
        r = x;
        b = c;
      } else if (h <= 360) {
        r = c;
        b = x;
      }
      r = Math.round((r + m) * 255);
      g = Math.round((g + m) * 255);
      b = Math.round((b + m) * 255);
      return new RGBA(r, g, b, a2);
    }
  };
  var Color = class _Color {
    static fromHex(hex) {
      return _Color.Format.CSS.parseHex(hex) || _Color.red;
    }
    static equals(a2, b) {
      if (!a2 && !b) {
        return true;
      }
      if (!a2 || !b) {
        return false;
      }
      return a2.equals(b);
    }
    get hsla() {
      if (this._hsla) {
        return this._hsla;
      } else {
        return HSLA.fromRGBA(this.rgba);
      }
    }
    get hsva() {
      if (this._hsva) {
        return this._hsva;
      }
      return HSVA.fromRGBA(this.rgba);
    }
    constructor(arg) {
      if (!arg) {
        throw new Error("Color needs a value");
      } else if (arg instanceof RGBA) {
        this.rgba = arg;
      } else if (arg instanceof HSLA) {
        this._hsla = arg;
        this.rgba = HSLA.toRGBA(arg);
      } else if (arg instanceof HSVA) {
        this._hsva = arg;
        this.rgba = HSVA.toRGBA(arg);
      } else {
        throw new Error("Invalid color ctor argument");
      }
    }
    equals(other) {
      return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);
    }
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance() {
      const R = _Color._relativeLuminanceForComponent(this.rgba.r);
      const G = _Color._relativeLuminanceForComponent(this.rgba.g);
      const B = _Color._relativeLuminanceForComponent(this.rgba.b);
      const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;
      return roundFloat(luminance, 4);
    }
    static _relativeLuminanceForComponent(color) {
      const c = color / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    }
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter() {
      const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3;
      return yiq >= 128;
    }
    isLighterThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 > lum2;
    }
    isDarkerThan(another) {
      const lum1 = this.getRelativeLuminance();
      const lum2 = another.getRelativeLuminance();
      return lum1 < lum2;
    }
    lighten(factor) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));
    }
    darken(factor) {
      return new _Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));
    }
    transparent(factor) {
      const { r, g, b, a: a2 } = this.rgba;
      return new _Color(new RGBA(r, g, b, a2 * factor));
    }
    isTransparent() {
      return this.rgba.a === 0;
    }
    isOpaque() {
      return this.rgba.a === 1;
    }
    opposite() {
      return new _Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
    }
    makeOpaque(opaqueBackground) {
      if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {
        return this;
      }
      const { r, g, b, a: a2 } = this.rgba;
      return new _Color(new RGBA(opaqueBackground.rgba.r - a2 * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a2 * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a2 * (opaqueBackground.rgba.b - b), 1));
    }
    toString() {
      if (!this._toString) {
        this._toString = _Color.Format.CSS.format(this);
      }
      return this._toString;
    }
    static getLighterColor(of, relative2, factor) {
      if (of.isLighterThan(relative2)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor = factor * (lum2 - lum1) / lum2;
      return of.lighten(factor);
    }
    static getDarkerColor(of, relative2, factor) {
      if (of.isDarkerThan(relative2)) {
        return of;
      }
      factor = factor ? factor : 0.5;
      const lum1 = of.getRelativeLuminance();
      const lum2 = relative2.getRelativeLuminance();
      factor = factor * (lum1 - lum2) / lum1;
      return of.darken(factor);
    }
  };
  Color.white = new Color(new RGBA(255, 255, 255, 1));
  Color.black = new Color(new RGBA(0, 0, 0, 1));
  Color.red = new Color(new RGBA(255, 0, 0, 1));
  Color.blue = new Color(new RGBA(0, 0, 255, 1));
  Color.green = new Color(new RGBA(0, 255, 0, 1));
  Color.cyan = new Color(new RGBA(0, 255, 255, 1));
  Color.lightgrey = new Color(new RGBA(211, 211, 211, 1));
  Color.transparent = new Color(new RGBA(0, 0, 0, 0));
  (function(Color3) {
    let Format;
    (function(Format2) {
      let CSS;
      (function(CSS2) {
        function formatRGB(color) {
          if (color.rgba.a === 1) {
            return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;
          }
          return Color3.Format.CSS.formatRGBA(color);
        }
        CSS2.formatRGB = formatRGB;
        function formatRGBA(color) {
          return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+color.rgba.a.toFixed(2)})`;
        }
        CSS2.formatRGBA = formatRGBA;
        function formatHSL(color) {
          if (color.hsla.a === 1) {
            return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;
          }
          return Color3.Format.CSS.formatHSLA(color);
        }
        CSS2.formatHSL = formatHSL;
        function formatHSLA(color) {
          return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;
        }
        CSS2.formatHSLA = formatHSLA;
        function _toTwoDigitHex(n) {
          const r = n.toString(16);
          return r.length !== 2 ? "0" + r : r;
        }
        function formatHex(color) {
          return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;
        }
        CSS2.formatHex = formatHex;
        function formatHexA(color, compact = false) {
          if (compact && color.rgba.a === 1) {
            return Color3.Format.CSS.formatHex(color);
          }
          return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;
        }
        CSS2.formatHexA = formatHexA;
        function format5(color) {
          if (color.isOpaque()) {
            return Color3.Format.CSS.formatHex(color);
          }
          return Color3.Format.CSS.formatRGBA(color);
        }
        CSS2.format = format5;
        function parseHex(hex) {
          const length = hex.length;
          if (length === 0) {
            return null;
          }
          if (hex.charCodeAt(0) !== 35) {
            return null;
          }
          if (length === 7) {
            const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            return new Color3(new RGBA(r, g, b, 1));
          }
          if (length === 9) {
            const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));
            const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));
            const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));
            const a2 = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));
            return new Color3(new RGBA(r, g, b, a2 / 255));
          }
          if (length === 4) {
            const r = _parseHexDigit(hex.charCodeAt(1));
            const g = _parseHexDigit(hex.charCodeAt(2));
            const b = _parseHexDigit(hex.charCodeAt(3));
            return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));
          }
          if (length === 5) {
            const r = _parseHexDigit(hex.charCodeAt(1));
            const g = _parseHexDigit(hex.charCodeAt(2));
            const b = _parseHexDigit(hex.charCodeAt(3));
            const a2 = _parseHexDigit(hex.charCodeAt(4));
            return new Color3(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a2 + a2) / 255));
          }
          return null;
        }
        CSS2.parseHex = parseHex;
        function _parseHexDigit(charCode) {
          switch (charCode) {
            case 48:
              return 0;
            case 49:
              return 1;
            case 50:
              return 2;
            case 51:
              return 3;
            case 52:
              return 4;
            case 53:
              return 5;
            case 54:
              return 6;
            case 55:
              return 7;
            case 56:
              return 8;
            case 57:
              return 9;
            case 97:
              return 10;
            case 65:
              return 10;
            case 98:
              return 11;
            case 66:
              return 11;
            case 99:
              return 12;
            case 67:
              return 12;
            case 100:
              return 13;
            case 68:
              return 13;
            case 101:
              return 14;
            case 69:
              return 14;
            case 102:
              return 15;
            case 70:
              return 15;
          }
          return 0;
        }
      })(CSS = Format2.CSS || (Format2.CSS = {}));
    })(Format = Color3.Format || (Color3.Format = {}));
  })(Color || (Color = {}));

  // node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js
  function _parseCaptureGroups(captureGroups) {
    const values = [];
    for (const captureGroup of captureGroups) {
      const parsedNumber = Number(captureGroup);
      if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\s/g, "") !== "") {
        values.push(parsedNumber);
      }
    }
    return values;
  }
  function _toIColor(r, g, b, a2) {
    return {
      red: r / 255,
      blue: b / 255,
      green: g / 255,
      alpha: a2
    };
  }
  function _findRange(model, match) {
    const index = match.index;
    const length = match[0].length;
    if (!index) {
      return;
    }
    const startPosition = model.positionAt(index);
    const range = {
      startLineNumber: startPosition.lineNumber,
      startColumn: startPosition.column,
      endLineNumber: startPosition.lineNumber,
      endColumn: startPosition.column + length
    };
    return range;
  }
  function _findHexColorInformation(range, hexValue) {
    if (!range) {
      return;
    }
    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);
    if (!parsedHexColor) {
      return;
    }
    return {
      range,
      color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)
    };
  }
  function _findRGBColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    return {
      range,
      color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)
    };
  }
  function _findHSLColorInformation(range, matches, isAlpha) {
    if (!range || matches.length !== 1) {
      return;
    }
    const match = matches[0];
    const captureGroups = match.values();
    const parsedRegex = _parseCaptureGroups(captureGroups);
    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));
    return {
      range,
      color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)
    };
  }
  function _findMatches(model, regex) {
    if (typeof model === "string") {
      return [...model.matchAll(regex)];
    } else {
      return model.findMatches(regex);
    }
  }
  function computeColors(model) {
    const result = [];
    const initialValidationRegex = /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm;
    const initialValidationMatches = _findMatches(model, initialValidationRegex);
    if (initialValidationMatches.length > 0) {
      for (const initialMatch of initialValidationMatches) {
        const initialCaptureGroups = initialMatch.filter((captureGroup) => captureGroup !== void 0);
        const colorScheme = initialCaptureGroups[1];
        const colorParameters = initialCaptureGroups[2];
        if (!colorParameters) {
          continue;
        }
        let colorInformation;
        if (colorScheme === "rgb") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "rgba") {
          const regexParameters = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "hsl") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);
        } else if (colorScheme === "hsla") {
          const regexParameters = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
          colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);
        } else if (colorScheme === "#") {
          colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);
        }
        if (colorInformation) {
          result.push(colorInformation);
        }
      }
    }
    return result;
  }
  function computeDefaultDocumentColors(model) {
    if (!model || typeof model.getValue !== "function" || typeof model.positionAt !== "function") {
      return [];
    }
    return computeColors(model);
  }

  // node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve3) {
        resolve3(value);
      });
    }
    return new (P || (P = Promise))(function(resolve3, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var MirrorModel = class extends MirrorTextModel {
    get uri() {
      return this._uri;
    }
    get eol() {
      return this._eol;
    }
    getValue() {
      return this.getText();
    }
    findMatches(regex) {
      const matches = [];
      for (let i = 0; i < this._lines.length; i++) {
        const line = this._lines[i];
        const offsetToAdd = this.offsetAt(new Position(i + 1, 1));
        const iteratorOverMatches = line.matchAll(regex);
        for (const match of iteratorOverMatches) {
          if (match.index || match.index === 0) {
            match.index = match.index + offsetToAdd;
          }
          matches.push(match);
        }
      }
      return matches;
    }
    getLinesContent() {
      return this._lines.slice(0);
    }
    getLineCount() {
      return this._lines.length;
    }
    getLineContent(lineNumber) {
      return this._lines[lineNumber - 1];
    }
    getWordAtPosition(position, wordDefinition) {
      const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
      if (wordAtText) {
        return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
      }
      return null;
    }
    words(wordDefinition) {
      const lines = this._lines;
      const wordenize = this._wordenize.bind(this);
      let lineNumber = 0;
      let lineText = "";
      let wordRangesIdx = 0;
      let wordRanges = [];
      return {
        *[Symbol.iterator]() {
          while (true) {
            if (wordRangesIdx < wordRanges.length) {
              const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
              wordRangesIdx += 1;
              yield value;
            } else {
              if (lineNumber < lines.length) {
                lineText = lines[lineNumber];
                wordRanges = wordenize(lineText, wordDefinition);
                wordRangesIdx = 0;
                lineNumber += 1;
              } else {
                break;
              }
            }
          }
        }
      };
    }
    getLineWords(lineNumber, wordDefinition) {
      const content = this._lines[lineNumber - 1];
      const ranges = this._wordenize(content, wordDefinition);
      const words = [];
      for (const range of ranges) {
        words.push({
          word: content.substring(range.start, range.end),
          startColumn: range.start + 1,
          endColumn: range.end + 1
        });
      }
      return words;
    }
    _wordenize(content, wordDefinition) {
      const result = [];
      let match;
      wordDefinition.lastIndex = 0;
      while (match = wordDefinition.exec(content)) {
        if (match[0].length === 0) {
          break;
        }
        result.push({ start: match.index, end: match.index + match[0].length });
      }
      return result;
    }
    getValueInRange(range) {
      range = this._validateRange(range);
      if (range.startLineNumber === range.endLineNumber) {
        return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
      }
      const lineEnding = this._eol;
      const startLineIndex = range.startLineNumber - 1;
      const endLineIndex = range.endLineNumber - 1;
      const resultLines = [];
      resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
      for (let i = startLineIndex + 1; i < endLineIndex; i++) {
        resultLines.push(this._lines[i]);
      }
      resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
      return resultLines.join(lineEnding);
    }
    offsetAt(position) {
      position = this._validatePosition(position);
      this._ensureLineStarts();
      return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);
    }
    positionAt(offset) {
      offset = Math.floor(offset);
      offset = Math.max(0, offset);
      this._ensureLineStarts();
      const out = this._lineStarts.getIndexOf(offset);
      const lineLength = this._lines[out.index].length;
      return {
        lineNumber: 1 + out.index,
        column: 1 + Math.min(out.remainder, lineLength)
      };
    }
    _validateRange(range) {
      const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
      const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
      if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {
        return {
          startLineNumber: start.lineNumber,
          startColumn: start.column,
          endLineNumber: end.lineNumber,
          endColumn: end.column
        };
      }
      return range;
    }
    _validatePosition(position) {
      if (!Position.isIPosition(position)) {
        throw new Error("bad position");
      }
      let { lineNumber, column } = position;
      let hasChanged = false;
      if (lineNumber < 1) {
        lineNumber = 1;
        column = 1;
        hasChanged = true;
      } else if (lineNumber > this._lines.length) {
        lineNumber = this._lines.length;
        column = this._lines[lineNumber - 1].length + 1;
        hasChanged = true;
      } else {
        const maxCharacter = this._lines[lineNumber - 1].length + 1;
        if (column < 1) {
          column = 1;
          hasChanged = true;
        } else if (column > maxCharacter) {
          column = maxCharacter;
          hasChanged = true;
        }
      }
      if (!hasChanged) {
        return position;
      } else {
        return { lineNumber, column };
      }
    }
  };
  var EditorSimpleWorker = class _EditorSimpleWorker {
    constructor(host, foreignModuleFactory) {
      this._host = host;
      this._models = /* @__PURE__ */ Object.create(null);
      this._foreignModuleFactory = foreignModuleFactory;
      this._foreignModule = null;
    }
    dispose() {
      this._models = /* @__PURE__ */ Object.create(null);
    }
    _getModel(uri) {
      return this._models[uri];
    }
    _getModels() {
      const all = [];
      Object.keys(this._models).forEach((key) => all.push(this._models[key]));
      return all;
    }
    acceptNewModel(data) {
      this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);
    }
    acceptModelChanged(strURL, e) {
      if (!this._models[strURL]) {
        return;
      }
      const model = this._models[strURL];
      model.onEvents(e);
    }
    acceptRemovedModel(strURL) {
      if (!this._models[strURL]) {
        return;
      }
      delete this._models[strURL];
    }
    computeUnicodeHighlights(url, options, range) {
      return __awaiter2(this, void 0, void 0, function* () {
        const model = this._getModel(url);
        if (!model) {
          return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
        }
        return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);
      });
    }
    // ---- BEGIN diff --------------------------------------------------------------------------
    computeDiff(originalUrl, modifiedUrl, options, algorithm) {
      return __awaiter2(this, void 0, void 0, function* () {
        const original = this._getModel(originalUrl);
        const modified = this._getModel(modifiedUrl);
        if (!original || !modified) {
          return null;
        }
        return _EditorSimpleWorker.computeDiff(original, modified, options, algorithm);
      });
    }
    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {
      const diffAlgorithm = algorithm === "advanced" ? linesDiffComputers.getAdvanced() : linesDiffComputers.getLegacy();
      const originalLines = originalTextModel.getLinesContent();
      const modifiedLines = modifiedTextModel.getLinesContent();
      const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);
      const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);
      function getLineChanges(changes) {
        return changes.map((m) => {
          var _a3;
          return [m.originalRange.startLineNumber, m.originalRange.endLineNumberExclusive, m.modifiedRange.startLineNumber, m.modifiedRange.endLineNumberExclusive, (_a3 = m.innerChanges) === null || _a3 === void 0 ? void 0 : _a3.map((m2) => [
            m2.originalRange.startLineNumber,
            m2.originalRange.startColumn,
            m2.originalRange.endLineNumber,
            m2.originalRange.endColumn,
            m2.modifiedRange.startLineNumber,
            m2.modifiedRange.startColumn,
            m2.modifiedRange.endLineNumber,
            m2.modifiedRange.endColumn
          ])];
        });
      }
      return {
        identical,
        quitEarly: result.hitTimeout,
        changes: getLineChanges(result.changes),
        moves: result.moves.map((m) => [
          m.lineRangeMapping.originalRange.startLineNumber,
          m.lineRangeMapping.originalRange.endLineNumberExclusive,
          m.lineRangeMapping.modifiedRange.startLineNumber,
          m.lineRangeMapping.modifiedRange.endLineNumberExclusive,
          getLineChanges(m.changes)
        ])
      };
    }
    static _modelsAreIdentical(original, modified) {
      const originalLineCount = original.getLineCount();
      const modifiedLineCount = modified.getLineCount();
      if (originalLineCount !== modifiedLineCount) {
        return false;
      }
      for (let line = 1; line <= originalLineCount; line++) {
        const originalLine = original.getLineContent(line);
        const modifiedLine = modified.getLineContent(line);
        if (originalLine !== modifiedLine) {
          return false;
        }
      }
      return true;
    }
    computeMoreMinimalEdits(modelUrl, edits, pretty) {
      return __awaiter2(this, void 0, void 0, function* () {
        const model = this._getModel(modelUrl);
        if (!model) {
          return edits;
        }
        const result = [];
        let lastEol = void 0;
        edits = edits.slice(0).sort((a2, b) => {
          if (a2.range && b.range) {
            return Range.compareRangesUsingStarts(a2.range, b.range);
          }
          const aRng = a2.range ? 0 : 1;
          const bRng = b.range ? 0 : 1;
          return aRng - bRng;
        });
        for (let { range, text, eol } of edits) {
          if (typeof eol === "number") {
            lastEol = eol;
          }
          if (Range.isEmpty(range) && !text) {
            continue;
          }
          const original = model.getValueInRange(range);
          text = text.replace(/\r\n|\n|\r/g, model.eol);
          if (original === text) {
            continue;
          }
          if (Math.max(text.length, original.length) > _EditorSimpleWorker._diffLimit) {
            result.push({ range, text });
            continue;
          }
          const changes = stringDiff(original, text, pretty);
          const editOffset = model.offsetAt(Range.lift(range).getStartPosition());
          for (const change of changes) {
            const start = model.positionAt(editOffset + change.originalStart);
            const end = model.positionAt(editOffset + change.originalStart + change.originalLength);
            const newEdit = {
              text: text.substr(change.modifiedStart, change.modifiedLength),
              range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
            };
            if (model.getValueInRange(newEdit.range) !== newEdit.text) {
              result.push(newEdit);
            }
          }
        }
        if (typeof lastEol === "number") {
          result.push({ eol: lastEol, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
        }
        return result;
      });
    }
    // ---- END minimal edits ---------------------------------------------------------------
    computeLinks(modelUrl) {
      return __awaiter2(this, void 0, void 0, function* () {
        const model = this._getModel(modelUrl);
        if (!model) {
          return null;
        }
        return computeLinks(model);
      });
    }
    // --- BEGIN default document colors -----------------------------------------------------------
    computeDefaultDocumentColors(modelUrl) {
      return __awaiter2(this, void 0, void 0, function* () {
        const model = this._getModel(modelUrl);
        if (!model) {
          return null;
        }
        return computeDefaultDocumentColors(model);
      });
    }
    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {
      return __awaiter2(this, void 0, void 0, function* () {
        const sw = new StopWatch();
        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
        const seen = /* @__PURE__ */ new Set();
        outer:
          for (const url of modelUrls) {
            const model = this._getModel(url);
            if (!model) {
              continue;
            }
            for (const word of model.words(wordDefRegExp)) {
              if (word === leadingWord || !isNaN(Number(word))) {
                continue;
              }
              seen.add(word);
              if (seen.size > _EditorSimpleWorker._suggestionsLimit) {
                break outer;
              }
            }
          }
        return { words: Array.from(seen), duration: sw.elapsed() };
      });
    }
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {
      return __awaiter2(this, void 0, void 0, function* () {
        const model = this._getModel(modelUrl);
        if (!model) {
          return /* @__PURE__ */ Object.create(null);
        }
        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
        const result = /* @__PURE__ */ Object.create(null);
        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {
          const words = model.getLineWords(line, wordDefRegExp);
          for (const word of words) {
            if (!isNaN(Number(word.word))) {
              continue;
            }
            let array = result[word.word];
            if (!array) {
              array = [];
              result[word.word] = array;
            }
            array.push({
              startLineNumber: line,
              startColumn: word.startColumn,
              endLineNumber: line,
              endColumn: word.endColumn
            });
          }
        }
        return result;
      });
    }
    //#endregion
    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {
      return __awaiter2(this, void 0, void 0, function* () {
        const model = this._getModel(modelUrl);
        if (!model) {
          return null;
        }
        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);
        if (range.startColumn === range.endColumn) {
          range = {
            startLineNumber: range.startLineNumber,
            startColumn: range.startColumn,
            endLineNumber: range.endLineNumber,
            endColumn: range.endColumn + 1
          };
        }
        const selectionText = model.getValueInRange(range);
        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
        if (!wordRange) {
          return null;
        }
        const word = model.getValueInRange(wordRange);
        const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
        return result;
      });
    }
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    loadForeignModule(moduleId, createData, foreignHostMethods) {
      const proxyMethodRequest = (method, args) => {
        return this._host.fhr(method, args);
      };
      const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
      const ctx = {
        host: foreignHost,
        getMirrorModels: () => {
          return this._getModels();
        }
      };
      if (this._foreignModuleFactory) {
        this._foreignModule = this._foreignModuleFactory(ctx, createData);
        return Promise.resolve(getAllMethodNames(this._foreignModule));
      }
      return Promise.reject(new Error(`Unexpected usage`));
    }
    // foreign method request
    fmr(method, args) {
      if (!this._foreignModule || typeof this._foreignModule[method] !== "function") {
        return Promise.reject(new Error("Missing requestHandler or method: " + method));
      }
      try {
        return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
  EditorSimpleWorker._diffLimit = 1e5;
  EditorSimpleWorker._suggestionsLimit = 1e4;
  if (typeof importScripts === "function") {
    globalThis.monaco = createMonacoBaseAPI();
  }

  // node_modules/monaco-editor/esm/vs/editor/editor.worker.js
  var initialized = false;
  function initialize(foreignModule) {
    if (initialized) {
      return;
    }
    initialized = true;
    const simpleWorker = new SimpleWorkerServer((msg) => {
      globalThis.postMessage(msg);
    }, (host) => new EditorSimpleWorker(host, foreignModule));
    globalThis.onmessage = (e) => {
      simpleWorker.onmessage(e.data);
    };
  }
  globalThis.onmessage = (e) => {
    if (!initialized) {
      initialize(null);
    }
  };

  // node_modules/monaco-worker-manager/worker.js
  function initialize2(fn) {
    self.onmessage = () => {
      initialize((ctx, createData) => Object.create(fn(ctx, createData)));
    };
  }

  // node_modules/vscode-languageserver-textdocument/lib/esm/main.js
  var __spreadArray = function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var FullTextDocument = (
    /** @class */
    function() {
      function FullTextDocument3(uri, languageId2, version, content) {
        this._uri = uri;
        this._languageId = languageId2;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(changes, version) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
          var change = changes_1[_i];
          if (FullTextDocument3.isIncremental(change)) {
            var range = getWellformedRange(change.range);
            var startOffset = this.offsetAt(range.start);
            var endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            var startLine = Math.max(range.start.line, 0);
            var endLine = Math.max(range.end.line, 0);
            var lineOffsets = this._lineOffsets;
            var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            var diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (FullTextDocument3.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.isIncremental = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      };
      FullTextDocument3.isFull = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      };
      return FullTextDocument3;
    }()
  );
  var TextDocument;
  (function(TextDocument3) {
    function create(uri, languageId2, version, content) {
      return new FullTextDocument(uri, languageId2, version, content);
    }
    TextDocument3.create = create;
    function update(document2, changes, version) {
      if (document2 instanceof FullTextDocument) {
        document2.update(changes, version);
        return document2;
      } else {
        throw new Error("TextDocument.update: document must be created by TextDocument.create");
      }
    }
    TextDocument3.update = update;
    function applyEdits(document2, edits) {
      var text = document2.getText();
      var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a2, b) {
        var diff = a2.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a2.range.start.character - b.range.start.character;
        }
        return diff;
      });
      var lastModifiedOffset = 0;
      var spans = [];
      for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
        var e = sortedEdits_1[_i];
        var startOffset = document2.offsetAt(e.range.start);
        if (startOffset < lastModifiedOffset) {
          throw new Error("Overlapping edit");
        } else if (startOffset > lastModifiedOffset) {
          spans.push(text.substring(lastModifiedOffset, startOffset));
        }
        if (e.newText.length) {
          spans.push(e.newText);
        }
        lastModifiedOffset = document2.offsetAt(e.range.end);
      }
      spans.push(text.substr(lastModifiedOffset));
      return spans.join("");
    }
    TextDocument3.applyEdits = applyEdits;
  })(TextDocument || (TextDocument = {}));
  function mergeSort(data, compare) {
    if (data.length <= 1) {
      return data;
    }
    var p = data.length / 2 | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      var ret = compare(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
  function computeLineOffsets(text, isAtLineStart, textOffset) {
    if (textOffset === void 0) {
      textOffset = 0;
    }
    var result = isAtLineStart ? [textOffset] : [];
    for (var i = 0; i < text.length; i++) {
      var ch = text.charCodeAt(i);
      if (ch === 13 || ch === 10) {
        if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
          i++;
        }
        result.push(textOffset + i + 1);
      }
    }
    return result;
  }
  function getWellformedRange(range) {
    var start = range.start;
    var end = range.end;
    if (start.line > end.line || start.line === end.line && start.character > end.character) {
      return { start: end, end: start };
    }
    return range;
  }
  function getWellformedEdit(textEdit) {
    var range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
      return { newText: textEdit.newText, range };
    }
    return textEdit;
  }

  // node_modules/jsonc-parser/lib/esm/impl/scanner.js
  function createScanner(text, ignoreTrivia = false) {
    const len = text.length;
    let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
    function scanHexDigits(count, exact) {
      let digits = 0;
      let value2 = 0;
      while (digits < count || !exact) {
        let ch = text.charCodeAt(pos);
        if (ch >= 48 && ch <= 57) {
          value2 = value2 * 16 + ch - 48;
        } else if (ch >= 65 && ch <= 70) {
          value2 = value2 * 16 + ch - 65 + 10;
        } else if (ch >= 97 && ch <= 102) {
          value2 = value2 * 16 + ch - 97 + 10;
        } else {
          break;
        }
        pos++;
        digits++;
      }
      if (digits < count) {
        value2 = -1;
      }
      return value2;
    }
    function setPosition(newPosition) {
      pos = newPosition;
      value = "";
      tokenOffset = 0;
      token = 16;
      scanError = 0;
    }
    function scanNumber() {
      let start = pos;
      if (text.charCodeAt(pos) === 48) {
        pos++;
      } else {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      }
      if (pos < text.length && text.charCodeAt(pos) === 46) {
        pos++;
        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
          while (pos < text.length && isDigit(text.charCodeAt(pos))) {
            pos++;
          }
        } else {
          scanError = 3;
          return text.substring(start, pos);
        }
      }
      let end = pos;
      if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
        pos++;
        if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
          pos++;
        }
        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
          while (pos < text.length && isDigit(text.charCodeAt(pos))) {
            pos++;
          }
          end = pos;
        } else {
          scanError = 3;
        }
      }
      return text.substring(start, end);
    }
    function scanString() {
      let result = "", start = pos;
      while (true) {
        if (pos >= len) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        }
        const ch = text.charCodeAt(pos);
        if (ch === 34) {
          result += text.substring(start, pos);
          pos++;
          break;
        }
        if (ch === 92) {
          result += text.substring(start, pos);
          pos++;
          if (pos >= len) {
            scanError = 2;
            break;
          }
          const ch2 = text.charCodeAt(pos++);
          switch (ch2) {
            case 34:
              result += '"';
              break;
            case 92:
              result += "\\";
              break;
            case 47:
              result += "/";
              break;
            case 98:
              result += "\b";
              break;
            case 102:
              result += "\f";
              break;
            case 110:
              result += "\n";
              break;
            case 114:
              result += "\r";
              break;
            case 116:
              result += "	";
              break;
            case 117:
              const ch3 = scanHexDigits(4, true);
              if (ch3 >= 0) {
                result += String.fromCharCode(ch3);
              } else {
                scanError = 4;
              }
              break;
            default:
              scanError = 5;
          }
          start = pos;
          continue;
        }
        if (ch >= 0 && ch <= 31) {
          if (isLineBreak(ch)) {
            result += text.substring(start, pos);
            scanError = 2;
            break;
          } else {
            scanError = 6;
          }
        }
        pos++;
      }
      return result;
    }
    function scanNext() {
      value = "";
      scanError = 0;
      tokenOffset = pos;
      lineStartOffset = lineNumber;
      prevTokenLineStartOffset = tokenLineStartOffset;
      if (pos >= len) {
        tokenOffset = len;
        return token = 17;
      }
      let code = text.charCodeAt(pos);
      if (isWhiteSpace(code)) {
        do {
          pos++;
          value += String.fromCharCode(code);
          code = text.charCodeAt(pos);
        } while (isWhiteSpace(code));
        return token = 15;
      }
      if (isLineBreak(code)) {
        pos++;
        value += String.fromCharCode(code);
        if (code === 13 && text.charCodeAt(pos) === 10) {
          pos++;
          value += "\n";
        }
        lineNumber++;
        tokenLineStartOffset = pos;
        return token = 14;
      }
      switch (code) {
        case 123:
          pos++;
          return token = 1;
        case 125:
          pos++;
          return token = 2;
        case 91:
          pos++;
          return token = 3;
        case 93:
          pos++;
          return token = 4;
        case 58:
          pos++;
          return token = 6;
        case 44:
          pos++;
          return token = 5;
        case 34:
          pos++;
          value = scanString();
          return token = 10;
        case 47:
          const start = pos - 1;
          if (text.charCodeAt(pos + 1) === 47) {
            pos += 2;
            while (pos < len) {
              if (isLineBreak(text.charCodeAt(pos))) {
                break;
              }
              pos++;
            }
            value = text.substring(start, pos);
            return token = 12;
          }
          if (text.charCodeAt(pos + 1) === 42) {
            pos += 2;
            const safeLength = len - 1;
            let commentClosed = false;
            while (pos < safeLength) {
              const ch = text.charCodeAt(pos);
              if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
                pos += 2;
                commentClosed = true;
                break;
              }
              pos++;
              if (isLineBreak(ch)) {
                if (ch === 13 && text.charCodeAt(pos) === 10) {
                  pos++;
                }
                lineNumber++;
                tokenLineStartOffset = pos;
              }
            }
            if (!commentClosed) {
              pos++;
              scanError = 1;
            }
            value = text.substring(start, pos);
            return token = 13;
          }
          value += String.fromCharCode(code);
          pos++;
          return token = 16;
        case 45:
          value += String.fromCharCode(code);
          pos++;
          if (pos === len || !isDigit(text.charCodeAt(pos))) {
            return token = 16;
          }
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          value += scanNumber();
          return token = 11;
        default:
          while (pos < len && isUnknownContentCharacter(code)) {
            pos++;
            code = text.charCodeAt(pos);
          }
          if (tokenOffset !== pos) {
            value = text.substring(tokenOffset, pos);
            switch (value) {
              case "true":
                return token = 8;
              case "false":
                return token = 9;
              case "null":
                return token = 7;
            }
            return token = 16;
          }
          value += String.fromCharCode(code);
          pos++;
          return token = 16;
      }
    }
    function isUnknownContentCharacter(code) {
      if (isWhiteSpace(code) || isLineBreak(code)) {
        return false;
      }
      switch (code) {
        case 125:
        case 93:
        case 123:
        case 91:
        case 34:
        case 58:
        case 44:
        case 47:
          return false;
      }
      return true;
    }
    function scanNextNonTrivia() {
      let result;
      do {
        result = scanNext();
      } while (result >= 12 && result <= 15);
      return result;
    }
    return {
      setPosition,
      getPosition: () => pos,
      scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
      getToken: () => token,
      getTokenValue: () => value,
      getTokenOffset: () => tokenOffset,
      getTokenLength: () => pos - tokenOffset,
      getTokenStartLine: () => lineStartOffset,
      getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
      getTokenError: () => scanError
    };
  }
  function isWhiteSpace(ch) {
    return ch === 32 || ch === 9;
  }
  function isLineBreak(ch) {
    return ch === 10 || ch === 13;
  }
  function isDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  var CharacterCodes;
  (function(CharacterCodes2) {
    CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
    CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
    CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
    CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
    CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
    CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
    CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
    CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
    CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
    CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
    CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
    CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
    CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
    CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
    CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
    CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
    CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
    CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
    CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
    CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
    CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
    CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
    CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
    CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
    CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
    CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
    CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
    CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
    CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
    CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
    CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
    CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
    CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
    CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
    CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
    CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
    CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
    CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
    CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
    CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
    CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
    CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
    CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
    CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
    CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
    CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
    CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
    CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
    CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
    CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
    CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
    CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
    CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
    CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
    CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
    CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
    CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
    CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
    CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
    CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
    CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
    CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
    CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
    CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
    CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
    CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
    CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
    CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
    CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
    CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
    CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
    CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
    CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
    CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
    CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
    CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
    CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
    CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
    CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
    CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
  })(CharacterCodes || (CharacterCodes = {}));

  // node_modules/jsonc-parser/lib/esm/impl/parser.js
  var ParseOptions;
  (function(ParseOptions2) {
    ParseOptions2.DEFAULT = {
      allowTrailingComma: false
    };
  })(ParseOptions || (ParseOptions = {}));
  function parse(text, errors = [], options = ParseOptions.DEFAULT) {
    let currentProperty = null;
    let currentParent = [];
    const previousParents = [];
    function onValue(value) {
      if (Array.isArray(currentParent)) {
        currentParent.push(value);
      } else if (currentProperty !== null) {
        currentParent[currentProperty] = value;
      }
    }
    const visitor = {
      onObjectBegin: () => {
        const object = {};
        onValue(object);
        previousParents.push(currentParent);
        currentParent = object;
        currentProperty = null;
      },
      onObjectProperty: (name) => {
        currentProperty = name;
      },
      onObjectEnd: () => {
        currentParent = previousParents.pop();
      },
      onArrayBegin: () => {
        const array = [];
        onValue(array);
        previousParents.push(currentParent);
        currentParent = array;
        currentProperty = null;
      },
      onArrayEnd: () => {
        currentParent = previousParents.pop();
      },
      onLiteralValue: onValue,
      onError: (error, offset, length) => {
        errors.push({ error, offset, length });
      }
    };
    visit(text, visitor, options);
    return currentParent[0];
  }
  function getNodePath(node) {
    if (!node.parent || !node.parent.children) {
      return [];
    }
    const path5 = getNodePath(node.parent);
    if (node.parent.type === "property") {
      const key = node.parent.children[0].value;
      path5.push(key);
    } else if (node.parent.type === "array") {
      const index = node.parent.children.indexOf(node);
      if (index !== -1) {
        path5.push(index);
      }
    }
    return path5;
  }
  function getNodeValue(node) {
    switch (node.type) {
      case "array":
        return node.children.map(getNodeValue);
      case "object":
        const obj = /* @__PURE__ */ Object.create(null);
        for (let prop of node.children) {
          const valueNode = prop.children[1];
          if (valueNode) {
            obj[prop.children[0].value] = getNodeValue(valueNode);
          }
        }
        return obj;
      case "null":
      case "string":
      case "number":
      case "boolean":
        return node.value;
      default:
        return void 0;
    }
  }
  function contains(node, offset, includeRightBound = false) {
    return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
  }
  function findNodeAtOffset(node, offset, includeRightBound = false) {
    if (contains(node, offset, includeRightBound)) {
      const children = node.children;
      if (Array.isArray(children)) {
        for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
          const item = findNodeAtOffset(children[i], offset, includeRightBound);
          if (item) {
            return item;
          }
        }
      }
      return node;
    }
    return void 0;
  }
  function visit(text, visitor, options = ParseOptions.DEFAULT) {
    const _scanner = createScanner(text, false);
    const _jsonPath = [];
    function toNoArgVisit(visitFunction) {
      return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
    }
    function toNoArgVisitWithPath(visitFunction) {
      return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
    }
    function toOneArgVisit(visitFunction) {
      return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
    }
    function toOneArgVisitWithPath(visitFunction) {
      return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
    }
    const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
    const disallowComments = options && options.disallowComments;
    const allowTrailingComma = options && options.allowTrailingComma;
    function scanNext() {
      while (true) {
        const token = _scanner.scan();
        switch (_scanner.getTokenError()) {
          case 4:
            handleError(
              14
              /* ParseErrorCode.InvalidUnicode */
            );
            break;
          case 5:
            handleError(
              15
              /* ParseErrorCode.InvalidEscapeCharacter */
            );
            break;
          case 3:
            handleError(
              13
              /* ParseErrorCode.UnexpectedEndOfNumber */
            );
            break;
          case 1:
            if (!disallowComments) {
              handleError(
                11
                /* ParseErrorCode.UnexpectedEndOfComment */
              );
            }
            break;
          case 2:
            handleError(
              12
              /* ParseErrorCode.UnexpectedEndOfString */
            );
            break;
          case 6:
            handleError(
              16
              /* ParseErrorCode.InvalidCharacter */
            );
            break;
        }
        switch (token) {
          case 12:
          case 13:
            if (disallowComments) {
              handleError(
                10
                /* ParseErrorCode.InvalidCommentToken */
              );
            } else {
              onComment();
            }
            break;
          case 16:
            handleError(
              1
              /* ParseErrorCode.InvalidSymbol */
            );
            break;
          case 15:
          case 14:
            break;
          default:
            return token;
        }
      }
    }
    function handleError(error, skipUntilAfter = [], skipUntil = []) {
      onError(error);
      if (skipUntilAfter.length + skipUntil.length > 0) {
        let token = _scanner.getToken();
        while (token !== 17) {
          if (skipUntilAfter.indexOf(token) !== -1) {
            scanNext();
            break;
          } else if (skipUntil.indexOf(token) !== -1) {
            break;
          }
          token = scanNext();
        }
      }
    }
    function parseString(isValue) {
      const value = _scanner.getTokenValue();
      if (isValue) {
        onLiteralValue(value);
      } else {
        onObjectProperty(value);
        _jsonPath.push(value);
      }
      scanNext();
      return true;
    }
    function parseLiteral() {
      switch (_scanner.getToken()) {
        case 11:
          const tokenValue = _scanner.getTokenValue();
          let value = Number(tokenValue);
          if (isNaN(value)) {
            handleError(
              2
              /* ParseErrorCode.InvalidNumberFormat */
            );
            value = 0;
          }
          onLiteralValue(value);
          break;
        case 7:
          onLiteralValue(null);
          break;
        case 8:
          onLiteralValue(true);
          break;
        case 9:
          onLiteralValue(false);
          break;
        default:
          return false;
      }
      scanNext();
      return true;
    }
    function parseProperty() {
      if (_scanner.getToken() !== 10) {
        handleError(3, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
        return false;
      }
      parseString(false);
      if (_scanner.getToken() === 6) {
        onSeparator(":");
        scanNext();
        if (!parseValue()) {
          handleError(4, [], [
            2,
            5
            /* SyntaxKind.CommaToken */
          ]);
        }
      } else {
        handleError(5, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      _jsonPath.pop();
      return true;
    }
    function parseObject() {
      onObjectBegin();
      scanNext();
      let needsComma = false;
      while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
        if (_scanner.getToken() === 5) {
          if (!needsComma) {
            handleError(4, [], []);
          }
          onSeparator(",");
          scanNext();
          if (_scanner.getToken() === 2 && allowTrailingComma) {
            break;
          }
        } else if (needsComma) {
          handleError(6, [], []);
        }
        if (!parseProperty()) {
          handleError(4, [], [
            2,
            5
            /* SyntaxKind.CommaToken */
          ]);
        }
        needsComma = true;
      }
      onObjectEnd();
      if (_scanner.getToken() !== 2) {
        handleError(7, [
          2
          /* SyntaxKind.CloseBraceToken */
        ], []);
      } else {
        scanNext();
      }
      return true;
    }
    function parseArray() {
      onArrayBegin();
      scanNext();
      let isFirstElement = true;
      let needsComma = false;
      while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
        if (_scanner.getToken() === 5) {
          if (!needsComma) {
            handleError(4, [], []);
          }
          onSeparator(",");
          scanNext();
          if (_scanner.getToken() === 4 && allowTrailingComma) {
            break;
          }
        } else if (needsComma) {
          handleError(6, [], []);
        }
        if (isFirstElement) {
          _jsonPath.push(0);
          isFirstElement = false;
        } else {
          _jsonPath[_jsonPath.length - 1]++;
        }
        if (!parseValue()) {
          handleError(4, [], [
            4,
            5
            /* SyntaxKind.CommaToken */
          ]);
        }
        needsComma = true;
      }
      onArrayEnd();
      if (!isFirstElement) {
        _jsonPath.pop();
      }
      if (_scanner.getToken() !== 4) {
        handleError(8, [
          4
          /* SyntaxKind.CloseBracketToken */
        ], []);
      } else {
        scanNext();
      }
      return true;
    }
    function parseValue() {
      switch (_scanner.getToken()) {
        case 3:
          return parseArray();
        case 1:
          return parseObject();
        case 10:
          return parseString(true);
        default:
          return parseLiteral();
      }
    }
    scanNext();
    if (_scanner.getToken() === 17) {
      if (options.allowEmptyContent) {
        return true;
      }
      handleError(4, [], []);
      return false;
    }
    if (!parseValue()) {
      handleError(4, [], []);
      return false;
    }
    if (_scanner.getToken() !== 17) {
      handleError(9, [], []);
    }
    return true;
  }

  // node_modules/jsonc-parser/lib/esm/main.js
  var createScanner2 = createScanner;
  var ScanError;
  (function(ScanError2) {
    ScanError2[ScanError2["None"] = 0] = "None";
    ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
    ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
    ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
    ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
    ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
    ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
  })(ScanError || (ScanError = {}));
  var SyntaxKind;
  (function(SyntaxKind2) {
    SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
    SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
    SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
    SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
    SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
    SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
    SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
    SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
    SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
    SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
    SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
    SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
    SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
    SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
    SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
    SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
    SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
  })(SyntaxKind || (SyntaxKind = {}));
  var parse2 = parse;
  var findNodeAtOffset2 = findNodeAtOffset;
  var getNodePath2 = getNodePath;
  var getNodeValue2 = getNodeValue;
  var ParseErrorCode;
  (function(ParseErrorCode2) {
    ParseErrorCode2[ParseErrorCode2["InvalidSymbol"] = 1] = "InvalidSymbol";
    ParseErrorCode2[ParseErrorCode2["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
    ParseErrorCode2[ParseErrorCode2["PropertyNameExpected"] = 3] = "PropertyNameExpected";
    ParseErrorCode2[ParseErrorCode2["ValueExpected"] = 4] = "ValueExpected";
    ParseErrorCode2[ParseErrorCode2["ColonExpected"] = 5] = "ColonExpected";
    ParseErrorCode2[ParseErrorCode2["CommaExpected"] = 6] = "CommaExpected";
    ParseErrorCode2[ParseErrorCode2["CloseBraceExpected"] = 7] = "CloseBraceExpected";
    ParseErrorCode2[ParseErrorCode2["CloseBracketExpected"] = 8] = "CloseBracketExpected";
    ParseErrorCode2[ParseErrorCode2["EndOfFileExpected"] = 9] = "EndOfFileExpected";
    ParseErrorCode2[ParseErrorCode2["InvalidCommentToken"] = 10] = "InvalidCommentToken";
    ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
    ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
    ParseErrorCode2[ParseErrorCode2["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
    ParseErrorCode2[ParseErrorCode2["InvalidUnicode"] = 14] = "InvalidUnicode";
    ParseErrorCode2[ParseErrorCode2["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
    ParseErrorCode2[ParseErrorCode2["InvalidCharacter"] = 16] = "InvalidCharacter";
  })(ParseErrorCode || (ParseErrorCode = {}));

  // node_modules/vscode-uri/lib/esm/index.js
  var LIB;
  (() => {
    "use strict";
    var t = { 470: (t2) => {
      function e2(t3) {
        if ("string" != typeof t3)
          throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
      }
      function r2(t3, e3) {
        for (var r3, n3 = "", o = 0, i = -1, a2 = 0, h = 0; h <= t3.length; ++h) {
          if (h < t3.length)
            r3 = t3.charCodeAt(h);
          else {
            if (47 === r3)
              break;
            r3 = 47;
          }
          if (47 === r3) {
            if (i === h - 1 || 1 === a2)
              ;
            else if (i !== h - 1 && 2 === a2) {
              if (n3.length < 2 || 2 !== o || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                if (n3.length > 2) {
                  var s = n3.lastIndexOf("/");
                  if (s !== n3.length - 1) {
                    -1 === s ? (n3 = "", o = 0) : o = (n3 = n3.slice(0, s)).length - 1 - n3.lastIndexOf("/"), i = h, a2 = 0;
                    continue;
                  }
                } else if (2 === n3.length || 1 === n3.length) {
                  n3 = "", o = 0, i = h, a2 = 0;
                  continue;
                }
              }
              e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o = 2);
            } else
              n3.length > 0 ? n3 += "/" + t3.slice(i + 1, h) : n3 = t3.slice(i + 1, h), o = h - i - 1;
            i = h, a2 = 0;
          } else
            46 === r3 && -1 !== a2 ? ++a2 : a2 = -1;
        }
        return n3;
      }
      var n2 = { resolve: function() {
        for (var t3, n3 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
          var a2;
          i >= 0 ? a2 = arguments[i] : (void 0 === t3 && (t3 = process.cwd()), a2 = t3), e2(a2), 0 !== a2.length && (n3 = a2 + "/" + n3, o = 47 === a2.charCodeAt(0));
        }
        return n3 = r2(n3, !o), o ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
      }, normalize: function(t3) {
        if (e2(t3), 0 === t3.length)
          return ".";
        var n3 = 47 === t3.charCodeAt(0), o = 47 === t3.charCodeAt(t3.length - 1);
        return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n3 ? "/" + t3 : t3;
      }, isAbsolute: function(t3) {
        return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
      }, join: function() {
        if (0 === arguments.length)
          return ".";
        for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
          var o = arguments[r3];
          e2(o), o.length > 0 && (void 0 === t3 ? t3 = o : t3 += "/" + o);
        }
        return void 0 === t3 ? "." : n2.normalize(t3);
      }, relative: function(t3, r3) {
        if (e2(t3), e2(r3), t3 === r3)
          return "";
        if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
          return "";
        for (var o = 1; o < t3.length && 47 === t3.charCodeAt(o); ++o)
          ;
        for (var i = t3.length, a2 = i - o, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h)
          ;
        for (var s = r3.length - h, c = a2 < s ? a2 : s, f2 = -1, u = 0; u <= c; ++u) {
          if (u === c) {
            if (s > c) {
              if (47 === r3.charCodeAt(h + u))
                return r3.slice(h + u + 1);
              if (0 === u)
                return r3.slice(h + u);
            } else
              a2 > c && (47 === t3.charCodeAt(o + u) ? f2 = u : 0 === u && (f2 = 0));
            break;
          }
          var l = t3.charCodeAt(o + u);
          if (l !== r3.charCodeAt(h + u))
            break;
          47 === l && (f2 = u);
        }
        var p = "";
        for (u = o + f2 + 1; u <= i; ++u)
          u !== i && 47 !== t3.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
        return p.length > 0 ? p + r3.slice(h + f2) : (h += f2, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
      }, _makeLong: function(t3) {
        return t3;
      }, dirname: function(t3) {
        if (e2(t3), 0 === t3.length)
          return ".";
        for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, o = -1, i = true, a2 = t3.length - 1; a2 >= 1; --a2)
          if (47 === (r3 = t3.charCodeAt(a2))) {
            if (!i) {
              o = a2;
              break;
            }
          } else
            i = false;
        return -1 === o ? n3 ? "/" : "." : n3 && 1 === o ? "//" : t3.slice(0, o);
      }, basename: function(t3, r3) {
        if (void 0 !== r3 && "string" != typeof r3)
          throw new TypeError('"ext" argument must be a string');
        e2(t3);
        var n3, o = 0, i = -1, a2 = true;
        if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
          if (r3.length === t3.length && r3 === t3)
            return "";
          var h = r3.length - 1, s = -1;
          for (n3 = t3.length - 1; n3 >= 0; --n3) {
            var c = t3.charCodeAt(n3);
            if (47 === c) {
              if (!a2) {
                o = n3 + 1;
                break;
              }
            } else
              -1 === s && (a2 = false, s = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (i = n3) : (h = -1, i = s));
          }
          return o === i ? i = s : -1 === i && (i = t3.length), t3.slice(o, i);
        }
        for (n3 = t3.length - 1; n3 >= 0; --n3)
          if (47 === t3.charCodeAt(n3)) {
            if (!a2) {
              o = n3 + 1;
              break;
            }
          } else
            -1 === i && (a2 = false, i = n3 + 1);
        return -1 === i ? "" : t3.slice(o, i);
      }, extname: function(t3) {
        e2(t3);
        for (var r3 = -1, n3 = 0, o = -1, i = true, a2 = 0, h = t3.length - 1; h >= 0; --h) {
          var s = t3.charCodeAt(h);
          if (47 !== s)
            -1 === o && (i = false, o = h + 1), 46 === s ? -1 === r3 ? r3 = h : 1 !== a2 && (a2 = 1) : -1 !== r3 && (a2 = -1);
          else if (!i) {
            n3 = h + 1;
            break;
          }
        }
        return -1 === r3 || -1 === o || 0 === a2 || 1 === a2 && r3 === o - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, o);
      }, format: function(t3) {
        if (null === t3 || "object" != typeof t3)
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
        return function(t4, e3) {
          var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
          return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
        }(0, t3);
      }, parse: function(t3) {
        e2(t3);
        var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
        if (0 === t3.length)
          return r3;
        var n3, o = t3.charCodeAt(0), i = 47 === o;
        i ? (r3.root = "/", n3 = 1) : n3 = 0;
        for (var a2 = -1, h = 0, s = -1, c = true, f2 = t3.length - 1, u = 0; f2 >= n3; --f2)
          if (47 !== (o = t3.charCodeAt(f2)))
            -1 === s && (c = false, s = f2 + 1), 46 === o ? -1 === a2 ? a2 = f2 : 1 !== u && (u = 1) : -1 !== a2 && (u = -1);
          else if (!c) {
            h = f2 + 1;
            break;
          }
        return -1 === a2 || -1 === s || 0 === u || 1 === u && a2 === s - 1 && a2 === h + 1 ? -1 !== s && (r3.base = r3.name = 0 === h && i ? t3.slice(1, s) : t3.slice(h, s)) : (0 === h && i ? (r3.name = t3.slice(1, a2), r3.base = t3.slice(1, s)) : (r3.name = t3.slice(h, a2), r3.base = t3.slice(h, s)), r3.ext = t3.slice(a2, s)), h > 0 ? r3.dir = t3.slice(0, h - 1) : i && (r3.dir = "/"), r3;
      }, sep: "/", delimiter: ":", win32: null, posix: null };
      n2.posix = n2, t2.exports = n2;
    } }, e = {};
    function r(n2) {
      var o = e[n2];
      if (void 0 !== o)
        return o.exports;
      var i = e[n2] = { exports: {} };
      return t[n2](i, i.exports, r), i.exports;
    }
    r.d = (t2, e2) => {
      for (var n2 in e2)
        r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
    }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
    };
    var n = {};
    (() => {
      var t2;
      if (r.r(n), r.d(n, { URI: () => g, Utils: () => O }), "object" == typeof process)
        t2 = "win32" === process.platform;
      else if ("object" == typeof navigator) {
        var e2 = navigator.userAgent;
        t2 = e2.indexOf("Windows") >= 0;
      }
      var o, i, a2 = (o = function(t3, e3) {
        return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
          t4.__proto__ = e4;
        } || function(t4, e4) {
          for (var r2 in e4)
            Object.prototype.hasOwnProperty.call(e4, r2) && (t4[r2] = e4[r2]);
        }, o(t3, e3);
      }, function(t3, e3) {
        if ("function" != typeof e3 && null !== e3)
          throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
        function r2() {
          this.constructor = t3;
        }
        o(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r2.prototype = e3.prototype, new r2());
      }), h = /^\w[\w\d+.-]*$/, s = /^\//, c = /^\/\//;
      function f2(t3, e3) {
        if (!t3.scheme && e3)
          throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
        if (t3.scheme && !h.test(t3.scheme))
          throw new Error("[UriError]: Scheme contains illegal characters.");
        if (t3.path) {
          if (t3.authority) {
            if (!s.test(t3.path))
              throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
          } else if (c.test(t3.path))
            throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
        }
      }
      var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, g = function() {
        function e3(t3, e4, r2, n2, o2, i2) {
          void 0 === i2 && (i2 = false), "object" == typeof t3 ? (this.scheme = t3.scheme || u, this.authority = t3.authority || u, this.path = t3.path || u, this.query = t3.query || u, this.fragment = t3.fragment || u) : (this.scheme = function(t4, e5) {
            return t4 || e5 ? t4 : "file";
          }(t3, i2), this.authority = e4 || u, this.path = function(t4, e5) {
            switch (t4) {
              case "https":
              case "http":
              case "file":
                e5 ? e5[0] !== l && (e5 = l + e5) : e5 = l;
            }
            return e5;
          }(this.scheme, r2 || u), this.query = n2 || u, this.fragment = o2 || u, f2(this, i2));
        }
        return e3.isUri = function(t3) {
          return t3 instanceof e3 || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
        }, Object.defineProperty(e3.prototype, "fsPath", { get: function() {
          return C(this, false);
        }, enumerable: false, configurable: true }), e3.prototype.with = function(t3) {
          if (!t3)
            return this;
          var e4 = t3.scheme, r2 = t3.authority, n2 = t3.path, o2 = t3.query, i2 = t3.fragment;
          return void 0 === e4 ? e4 = this.scheme : null === e4 && (e4 = u), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = u), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = u), void 0 === o2 ? o2 = this.query : null === o2 && (o2 = u), void 0 === i2 ? i2 = this.fragment : null === i2 && (i2 = u), e4 === this.scheme && r2 === this.authority && n2 === this.path && o2 === this.query && i2 === this.fragment ? this : new v(e4, r2, n2, o2, i2);
        }, e3.parse = function(t3, e4) {
          void 0 === e4 && (e4 = false);
          var r2 = p.exec(t3);
          return r2 ? new v(r2[2] || u, _(r2[4] || u), _(r2[5] || u), _(r2[7] || u), _(r2[9] || u), e4) : new v(u, u, u, u, u);
        }, e3.file = function(e4) {
          var r2 = u;
          if (t2 && (e4 = e4.replace(/\\/g, l)), e4[0] === l && e4[1] === l) {
            var n2 = e4.indexOf(l, 2);
            -1 === n2 ? (r2 = e4.substring(2), e4 = l) : (r2 = e4.substring(2, n2), e4 = e4.substring(n2) || l);
          }
          return new v("file", r2, e4, u, u);
        }, e3.from = function(t3) {
          var e4 = new v(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
          return f2(e4, true), e4;
        }, e3.prototype.toString = function(t3) {
          return void 0 === t3 && (t3 = false), A2(this, t3);
        }, e3.prototype.toJSON = function() {
          return this;
        }, e3.revive = function(t3) {
          if (t3) {
            if (t3 instanceof e3)
              return t3;
            var r2 = new v(t3);
            return r2._formatted = t3.external, r2._fsPath = t3._sep === d ? t3.fsPath : null, r2;
          }
          return t3;
        }, e3;
      }(), d = t2 ? 1 : void 0, v = function(t3) {
        function e3() {
          var e4 = null !== t3 && t3.apply(this, arguments) || this;
          return e4._formatted = null, e4._fsPath = null, e4;
        }
        return a2(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
          return this._fsPath || (this._fsPath = C(this, false)), this._fsPath;
        }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
          return void 0 === t4 && (t4 = false), t4 ? A2(this, true) : (this._formatted || (this._formatted = A2(this, false)), this._formatted);
        }, e3.prototype.toJSON = function() {
          var t4 = { $mid: 1 };
          return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = d), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
        }, e3;
      }(g), y = ((i = {})[58] = "%3A", i[47] = "%2F", i[63] = "%3F", i[35] = "%23", i[91] = "%5B", i[93] = "%5D", i[64] = "%40", i[33] = "%21", i[36] = "%24", i[38] = "%26", i[39] = "%27", i[40] = "%28", i[41] = "%29", i[42] = "%2A", i[43] = "%2B", i[44] = "%2C", i[59] = "%3B", i[61] = "%3D", i[32] = "%20", i);
      function m(t3, e3, r2) {
        for (var n2 = void 0, o2 = -1, i2 = 0; i2 < t3.length; i2++) {
          var a3 = t3.charCodeAt(i2);
          if (a3 >= 97 && a3 <= 122 || a3 >= 65 && a3 <= 90 || a3 >= 48 && a3 <= 57 || 45 === a3 || 46 === a3 || 95 === a3 || 126 === a3 || e3 && 47 === a3 || r2 && 91 === a3 || r2 && 93 === a3 || r2 && 58 === a3)
            -1 !== o2 && (n2 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), void 0 !== n2 && (n2 += t3.charAt(i2));
          else {
            void 0 === n2 && (n2 = t3.substr(0, i2));
            var h2 = y[a3];
            void 0 !== h2 ? (-1 !== o2 && (n2 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), n2 += h2) : -1 === o2 && (o2 = i2);
          }
        }
        return -1 !== o2 && (n2 += encodeURIComponent(t3.substring(o2))), void 0 !== n2 ? n2 : t3;
      }
      function b(t3) {
        for (var e3 = void 0, r2 = 0; r2 < t3.length; r2++) {
          var n2 = t3.charCodeAt(r2);
          35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += y[n2]) : void 0 !== e3 && (e3 += t3[r2]);
        }
        return void 0 !== e3 ? e3 : t3;
      }
      function C(e3, r2) {
        var n2;
        return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? "//".concat(e3.authority).concat(e3.path) : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
      }
      function A2(t3, e3) {
        var r2 = e3 ? b : m, n2 = "", o2 = t3.scheme, i2 = t3.authority, a3 = t3.path, h2 = t3.query, s2 = t3.fragment;
        if (o2 && (n2 += o2, n2 += ":"), (i2 || "file" === o2) && (n2 += l, n2 += l), i2) {
          var c2 = i2.indexOf("@");
          if (-1 !== c2) {
            var f3 = i2.substr(0, c2);
            i2 = i2.substr(c2 + 1), -1 === (c2 = f3.lastIndexOf(":")) ? n2 += r2(f3, false, false) : (n2 += r2(f3.substr(0, c2), false, false), n2 += ":", n2 += r2(f3.substr(c2 + 1), false, true)), n2 += "@";
          }
          -1 === (c2 = (i2 = i2.toLowerCase()).lastIndexOf(":")) ? n2 += r2(i2, false, true) : (n2 += r2(i2.substr(0, c2), false, true), n2 += i2.substr(c2));
        }
        if (a3) {
          if (a3.length >= 3 && 47 === a3.charCodeAt(0) && 58 === a3.charCodeAt(2))
            (u2 = a3.charCodeAt(1)) >= 65 && u2 <= 90 && (a3 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a3.substr(3)));
          else if (a3.length >= 2 && 58 === a3.charCodeAt(1)) {
            var u2;
            (u2 = a3.charCodeAt(0)) >= 65 && u2 <= 90 && (a3 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a3.substr(2)));
          }
          n2 += r2(a3, true, false);
        }
        return h2 && (n2 += "?", n2 += r2(h2, false, false)), s2 && (n2 += "#", n2 += e3 ? s2 : m(s2, false, false)), n2;
      }
      function w(t3) {
        try {
          return decodeURIComponent(t3);
        } catch (e3) {
          return t3.length > 3 ? t3.substr(0, 3) + w(t3.substr(3)) : t3;
        }
      }
      var x = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
      function _(t3) {
        return t3.match(x) ? t3.replace(x, function(t4) {
          return w(t4);
        }) : t3;
      }
      var O, P = r(470), j = function(t3, e3, r2) {
        if (r2 || 2 === arguments.length)
          for (var n2, o2 = 0, i2 = e3.length; o2 < i2; o2++)
            !n2 && o2 in e3 || (n2 || (n2 = Array.prototype.slice.call(e3, 0, o2)), n2[o2] = e3[o2]);
        return t3.concat(n2 || Array.prototype.slice.call(e3));
      }, I = P.posix || P, U = "/";
      !function(t3) {
        t3.joinPath = function(t4) {
          for (var e3 = [], r2 = 1; r2 < arguments.length; r2++)
            e3[r2 - 1] = arguments[r2];
          return t4.with({ path: I.join.apply(I, j([t4.path], e3, false)) });
        }, t3.resolvePath = function(t4) {
          for (var e3 = [], r2 = 1; r2 < arguments.length; r2++)
            e3[r2 - 1] = arguments[r2];
          var n2 = t4.path, o2 = false;
          n2[0] !== U && (n2 = U + n2, o2 = true);
          var i2 = I.resolve.apply(I, j([n2], e3, false));
          return o2 && i2[0] === U && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
        }, t3.dirname = function(t4) {
          if (0 === t4.path.length || t4.path === U)
            return t4;
          var e3 = I.dirname(t4.path);
          return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
        }, t3.basename = function(t4) {
          return I.basename(t4.path);
        }, t3.extname = function(t4) {
          return I.extname(t4.path);
        };
      }(O || (O = {}));
    })(), LIB = n;
  })();
  var { URI: URI2, Utils } = LIB;

  // node_modules/vscode-languageserver-types/lib/esm/main.js
  var DocumentUri;
  (function(DocumentUri2) {
    function is(value) {
      return typeof value === "string";
    }
    DocumentUri2.is = is;
  })(DocumentUri || (DocumentUri = {}));
  var URI3;
  (function(URI4) {
    function is(value) {
      return typeof value === "string";
    }
    URI4.is = is;
  })(URI3 || (URI3 = {}));
  var integer;
  (function(integer2) {
    integer2.MIN_VALUE = -2147483648;
    integer2.MAX_VALUE = 2147483647;
    function is(value) {
      return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
    }
    integer2.is = is;
  })(integer || (integer = {}));
  var uinteger;
  (function(uinteger2) {
    uinteger2.MIN_VALUE = 0;
    uinteger2.MAX_VALUE = 2147483647;
    function is(value) {
      return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
    }
    uinteger2.is = is;
  })(uinteger || (uinteger = {}));
  var Position2;
  (function(Position3) {
    function create(line, character) {
      if (line === Number.MAX_VALUE) {
        line = uinteger.MAX_VALUE;
      }
      if (character === Number.MAX_VALUE) {
        character = uinteger.MAX_VALUE;
      }
      return { line, character };
    }
    Position3.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position3.is = is;
  })(Position2 || (Position2 = {}));
  var Range2;
  (function(Range3) {
    function create(one, two, three, four) {
      if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
        return { start: Position2.create(one, two), end: Position2.create(three, four) };
      } else if (Position2.is(one) && Position2.is(two)) {
        return { start: one, end: two };
      } else {
        throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
      }
    }
    Range3.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
    }
    Range3.is = is;
  })(Range2 || (Range2 = {}));
  var Location;
  (function(Location2) {
    function create(uri, range) {
      return { uri, range };
    }
    Location2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location2.is = is;
  })(Location || (Location = {}));
  var LocationLink;
  (function(LocationLink2) {
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
      return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
    }
    LocationLink2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range2.is(candidate.targetSelectionRange) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink2.is = is;
  })(LocationLink || (LocationLink = {}));
  var Color2;
  (function(Color3) {
    function create(red, green, blue, alpha) {
      return {
        red,
        green,
        blue,
        alpha
      };
    }
    Color3.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color3.is = is;
  })(Color2 || (Color2 = {}));
  var ColorInformation;
  (function(ColorInformation2) {
    function create(range, color) {
      return {
        range,
        color
      };
    }
    ColorInformation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.range) && Color2.is(candidate.color);
    }
    ColorInformation2.is = is;
  })(ColorInformation || (ColorInformation = {}));
  var ColorPresentation;
  (function(ColorPresentation2) {
    function create(label, textEdit, additionalTextEdits) {
      return {
        label,
        textEdit,
        additionalTextEdits
      };
    }
    ColorPresentation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation2.is = is;
  })(ColorPresentation || (ColorPresentation = {}));
  var FoldingRangeKind2;
  (function(FoldingRangeKind3) {
    FoldingRangeKind3.Comment = "comment";
    FoldingRangeKind3.Imports = "imports";
    FoldingRangeKind3.Region = "region";
  })(FoldingRangeKind2 || (FoldingRangeKind2 = {}));
  var FoldingRange;
  (function(FoldingRange2) {
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
      var result = {
        startLine,
        endLine
      };
      if (Is.defined(startCharacter)) {
        result.startCharacter = startCharacter;
      }
      if (Is.defined(endCharacter)) {
        result.endCharacter = endCharacter;
      }
      if (Is.defined(kind)) {
        result.kind = kind;
      }
      if (Is.defined(collapsedText)) {
        result.collapsedText = collapsedText;
      }
      return result;
    }
    FoldingRange2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange2.is = is;
  })(FoldingRange || (FoldingRange = {}));
  var DiagnosticRelatedInformation;
  (function(DiagnosticRelatedInformation2) {
    function create(location, message) {
      return {
        location,
        message
      };
    }
    DiagnosticRelatedInformation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation2.is = is;
  })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
  var DiagnosticSeverity;
  (function(DiagnosticSeverity2) {
    DiagnosticSeverity2.Error = 1;
    DiagnosticSeverity2.Warning = 2;
    DiagnosticSeverity2.Information = 3;
    DiagnosticSeverity2.Hint = 4;
  })(DiagnosticSeverity || (DiagnosticSeverity = {}));
  var DiagnosticTag;
  (function(DiagnosticTag2) {
    DiagnosticTag2.Unnecessary = 1;
    DiagnosticTag2.Deprecated = 2;
  })(DiagnosticTag || (DiagnosticTag = {}));
  var CodeDescription;
  (function(CodeDescription2) {
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription2.is = is;
  })(CodeDescription || (CodeDescription = {}));
  var Diagnostic;
  (function(Diagnostic2) {
    function create(range, message, severity, code, source, relatedInformation) {
      var result = { range, message };
      if (Is.defined(severity)) {
        result.severity = severity;
      }
      if (Is.defined(code)) {
        result.code = code;
      }
      if (Is.defined(source)) {
        result.source = source;
      }
      if (Is.defined(relatedInformation)) {
        result.relatedInformation = relatedInformation;
      }
      return result;
    }
    Diagnostic2.create = create;
    function is(value) {
      var _a3;
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a3 = candidate.codeDescription) === null || _a3 === void 0 ? void 0 : _a3.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic2.is = is;
  })(Diagnostic || (Diagnostic = {}));
  var Command2;
  (function(Command3) {
    function create(title, command) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var result = { title, command };
      if (Is.defined(args) && args.length > 0) {
        result.arguments = args;
      }
      return result;
    }
    Command3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command3.is = is;
  })(Command2 || (Command2 = {}));
  var TextEdit;
  (function(TextEdit2) {
    function replace(range, newText) {
      return { range, newText };
    }
    TextEdit2.replace = replace;
    function insert(position, newText) {
      return { range: { start: position, end: position }, newText };
    }
    TextEdit2.insert = insert;
    function del(range) {
      return { range, newText: "" };
    }
    TextEdit2.del = del;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
    }
    TextEdit2.is = is;
  })(TextEdit || (TextEdit = {}));
  var ChangeAnnotation;
  (function(ChangeAnnotation2) {
    function create(label, needsConfirmation, description2) {
      var result = { label };
      if (needsConfirmation !== void 0) {
        result.needsConfirmation = needsConfirmation;
      }
      if (description2 !== void 0) {
        result.description = description2;
      }
      return result;
    }
    ChangeAnnotation2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    ChangeAnnotation2.is = is;
  })(ChangeAnnotation || (ChangeAnnotation = {}));
  var ChangeAnnotationIdentifier;
  (function(ChangeAnnotationIdentifier2) {
    function is(value) {
      var candidate = value;
      return Is.string(candidate);
    }
    ChangeAnnotationIdentifier2.is = is;
  })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
  var AnnotatedTextEdit;
  (function(AnnotatedTextEdit2) {
    function replace(range, newText, annotation) {
      return { range, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.replace = replace;
    function insert(position, newText, annotation) {
      return { range: { start: position, end: position }, newText, annotationId: annotation };
    }
    AnnotatedTextEdit2.insert = insert;
    function del(range, annotation) {
      return { range, newText: "", annotationId: annotation };
    }
    AnnotatedTextEdit2.del = del;
    function is(value) {
      var candidate = value;
      return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit2.is = is;
  })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
  var TextDocumentEdit;
  (function(TextDocumentEdit2) {
    function create(textDocument, edits) {
      return { textDocument, edits };
    }
    TextDocumentEdit2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit2.is = is;
  })(TextDocumentEdit || (TextDocumentEdit = {}));
  var CreateFile;
  (function(CreateFile2) {
    function create(uri, options, annotation) {
      var result = {
        kind: "create",
        uri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    CreateFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile2.is = is;
  })(CreateFile || (CreateFile = {}));
  var RenameFile;
  (function(RenameFile2) {
    function create(oldUri, newUri, options, annotation) {
      var result = {
        kind: "rename",
        oldUri,
        newUri
      };
      if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    RenameFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile2.is = is;
  })(RenameFile || (RenameFile = {}));
  var DeleteFile;
  (function(DeleteFile2) {
    function create(uri, options, annotation) {
      var result = {
        kind: "delete",
        uri
      };
      if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
        result.options = options;
      }
      if (annotation !== void 0) {
        result.annotationId = annotation;
      }
      return result;
    }
    DeleteFile2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile2.is = is;
  })(DeleteFile || (DeleteFile = {}));
  var WorkspaceEdit;
  (function(WorkspaceEdit2) {
    function is(value) {
      var candidate = value;
      return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
        if (Is.string(change.kind)) {
          return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
        } else {
          return TextDocumentEdit.is(change);
        }
      }));
    }
    WorkspaceEdit2.is = is;
  })(WorkspaceEdit || (WorkspaceEdit = {}));
  var TextEditChangeImpl = (
    /** @class */
    function() {
      function TextEditChangeImpl2(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.delete = function(range, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.add = function(edit) {
        this.edits.push(edit);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl2;
    }()
  );
  var ChangeAnnotations = (
    /** @class */
    function() {
      function ChangeAnnotations2(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations2.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations2.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations2;
    }()
  );
  var WorkspaceChange = (
    /** @class */
    function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange2.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange2;
    }()
  );
  var TextDocumentIdentifier;
  (function(TextDocumentIdentifier2) {
    function create(uri) {
      return { uri };
    }
    TextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier2.is = is;
  })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
  var VersionedTextDocumentIdentifier;
  (function(VersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return { uri, version };
    }
    VersionedTextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier2.is = is;
  })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
  var OptionalVersionedTextDocumentIdentifier;
  (function(OptionalVersionedTextDocumentIdentifier2) {
    function create(uri, version) {
      return { uri, version };
    }
    OptionalVersionedTextDocumentIdentifier2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier2.is = is;
  })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
  var TextDocumentItem;
  (function(TextDocumentItem2) {
    function create(uri, languageId2, version, text) {
      return { uri, languageId: languageId2, version, text };
    }
    TextDocumentItem2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem2.is = is;
  })(TextDocumentItem || (TextDocumentItem = {}));
  var MarkupKind;
  (function(MarkupKind2) {
    MarkupKind2.PlainText = "plaintext";
    MarkupKind2.Markdown = "markdown";
    function is(value) {
      var candidate = value;
      return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
    }
    MarkupKind2.is = is;
  })(MarkupKind || (MarkupKind = {}));
  var MarkupContent;
  (function(MarkupContent2) {
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent2.is = is;
  })(MarkupContent || (MarkupContent = {}));
  var CompletionItemKind2;
  (function(CompletionItemKind3) {
    CompletionItemKind3.Text = 1;
    CompletionItemKind3.Method = 2;
    CompletionItemKind3.Function = 3;
    CompletionItemKind3.Constructor = 4;
    CompletionItemKind3.Field = 5;
    CompletionItemKind3.Variable = 6;
    CompletionItemKind3.Class = 7;
    CompletionItemKind3.Interface = 8;
    CompletionItemKind3.Module = 9;
    CompletionItemKind3.Property = 10;
    CompletionItemKind3.Unit = 11;
    CompletionItemKind3.Value = 12;
    CompletionItemKind3.Enum = 13;
    CompletionItemKind3.Keyword = 14;
    CompletionItemKind3.Snippet = 15;
    CompletionItemKind3.Color = 16;
    CompletionItemKind3.File = 17;
    CompletionItemKind3.Reference = 18;
    CompletionItemKind3.Folder = 19;
    CompletionItemKind3.EnumMember = 20;
    CompletionItemKind3.Constant = 21;
    CompletionItemKind3.Struct = 22;
    CompletionItemKind3.Event = 23;
    CompletionItemKind3.Operator = 24;
    CompletionItemKind3.TypeParameter = 25;
  })(CompletionItemKind2 || (CompletionItemKind2 = {}));
  var InsertTextFormat;
  (function(InsertTextFormat2) {
    InsertTextFormat2.PlainText = 1;
    InsertTextFormat2.Snippet = 2;
  })(InsertTextFormat || (InsertTextFormat = {}));
  var CompletionItemTag2;
  (function(CompletionItemTag3) {
    CompletionItemTag3.Deprecated = 1;
  })(CompletionItemTag2 || (CompletionItemTag2 = {}));
  var InsertReplaceEdit;
  (function(InsertReplaceEdit2) {
    function create(newText, insert, replace) {
      return { newText, insert, replace };
    }
    InsertReplaceEdit2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
    }
    InsertReplaceEdit2.is = is;
  })(InsertReplaceEdit || (InsertReplaceEdit = {}));
  var InsertTextMode;
  (function(InsertTextMode2) {
    InsertTextMode2.asIs = 1;
    InsertTextMode2.adjustIndentation = 2;
  })(InsertTextMode || (InsertTextMode = {}));
  var CompletionItemLabelDetails;
  (function(CompletionItemLabelDetails2) {
    function is(value) {
      var candidate = value;
      return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
    }
    CompletionItemLabelDetails2.is = is;
  })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
  var CompletionItem;
  (function(CompletionItem2) {
    function create(label) {
      return { label };
    }
    CompletionItem2.create = create;
  })(CompletionItem || (CompletionItem = {}));
  var CompletionList;
  (function(CompletionList2) {
    function create(items, isIncomplete) {
      return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList2.create = create;
  })(CompletionList || (CompletionList = {}));
  var MarkedString;
  (function(MarkedString2) {
    function fromPlainText(plainText) {
      return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    MarkedString2.fromPlainText = fromPlainText;
    function is(value) {
      var candidate = value;
      return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString2.is = is;
  })(MarkedString || (MarkedString = {}));
  var Hover;
  (function(Hover2) {
    function is(value) {
      var candidate = value;
      return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
    }
    Hover2.is = is;
  })(Hover || (Hover = {}));
  var ParameterInformation;
  (function(ParameterInformation2) {
    function create(label, documentation) {
      return documentation ? { label, documentation } : { label };
    }
    ParameterInformation2.create = create;
  })(ParameterInformation || (ParameterInformation = {}));
  var SignatureInformation;
  (function(SignatureInformation2) {
    function create(label, documentation) {
      var parameters = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        parameters[_i - 2] = arguments[_i];
      }
      var result = { label };
      if (Is.defined(documentation)) {
        result.documentation = documentation;
      }
      if (Is.defined(parameters)) {
        result.parameters = parameters;
      } else {
        result.parameters = [];
      }
      return result;
    }
    SignatureInformation2.create = create;
  })(SignatureInformation || (SignatureInformation = {}));
  var DocumentHighlightKind3;
  (function(DocumentHighlightKind4) {
    DocumentHighlightKind4.Text = 1;
    DocumentHighlightKind4.Read = 2;
    DocumentHighlightKind4.Write = 3;
  })(DocumentHighlightKind3 || (DocumentHighlightKind3 = {}));
  var DocumentHighlight;
  (function(DocumentHighlight2) {
    function create(range, kind) {
      var result = { range };
      if (Is.number(kind)) {
        result.kind = kind;
      }
      return result;
    }
    DocumentHighlight2.create = create;
  })(DocumentHighlight || (DocumentHighlight = {}));
  var SymbolKind2;
  (function(SymbolKind3) {
    SymbolKind3.File = 1;
    SymbolKind3.Module = 2;
    SymbolKind3.Namespace = 3;
    SymbolKind3.Package = 4;
    SymbolKind3.Class = 5;
    SymbolKind3.Method = 6;
    SymbolKind3.Property = 7;
    SymbolKind3.Field = 8;
    SymbolKind3.Constructor = 9;
    SymbolKind3.Enum = 10;
    SymbolKind3.Interface = 11;
    SymbolKind3.Function = 12;
    SymbolKind3.Variable = 13;
    SymbolKind3.Constant = 14;
    SymbolKind3.String = 15;
    SymbolKind3.Number = 16;
    SymbolKind3.Boolean = 17;
    SymbolKind3.Array = 18;
    SymbolKind3.Object = 19;
    SymbolKind3.Key = 20;
    SymbolKind3.Null = 21;
    SymbolKind3.EnumMember = 22;
    SymbolKind3.Struct = 23;
    SymbolKind3.Event = 24;
    SymbolKind3.Operator = 25;
    SymbolKind3.TypeParameter = 26;
  })(SymbolKind2 || (SymbolKind2 = {}));
  var SymbolTag2;
  (function(SymbolTag3) {
    SymbolTag3.Deprecated = 1;
  })(SymbolTag2 || (SymbolTag2 = {}));
  var SymbolInformation;
  (function(SymbolInformation2) {
    function create(name, kind, range, uri, containerName) {
      var result = {
        name,
        kind,
        location: { uri, range }
      };
      if (containerName) {
        result.containerName = containerName;
      }
      return result;
    }
    SymbolInformation2.create = create;
  })(SymbolInformation || (SymbolInformation = {}));
  var WorkspaceSymbol;
  (function(WorkspaceSymbol2) {
    function create(name, kind, uri, range) {
      return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
    }
    WorkspaceSymbol2.create = create;
  })(WorkspaceSymbol || (WorkspaceSymbol = {}));
  var DocumentSymbol;
  (function(DocumentSymbol2) {
    function create(name, detail, kind, range, selectionRange, children) {
      var result = {
        name,
        detail,
        kind,
        range,
        selectionRange
      };
      if (children !== void 0) {
        result.children = children;
      }
      return result;
    }
    DocumentSymbol2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
    }
    DocumentSymbol2.is = is;
  })(DocumentSymbol || (DocumentSymbol = {}));
  var CodeActionKind;
  (function(CodeActionKind2) {
    CodeActionKind2.Empty = "";
    CodeActionKind2.QuickFix = "quickfix";
    CodeActionKind2.Refactor = "refactor";
    CodeActionKind2.RefactorExtract = "refactor.extract";
    CodeActionKind2.RefactorInline = "refactor.inline";
    CodeActionKind2.RefactorRewrite = "refactor.rewrite";
    CodeActionKind2.Source = "source";
    CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
    CodeActionKind2.SourceFixAll = "source.fixAll";
  })(CodeActionKind || (CodeActionKind = {}));
  var CodeActionTriggerKind;
  (function(CodeActionTriggerKind2) {
    CodeActionTriggerKind2.Invoked = 1;
    CodeActionTriggerKind2.Automatic = 2;
  })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
  var CodeActionContext;
  (function(CodeActionContext2) {
    function create(diagnostics, only, triggerKind) {
      var result = { diagnostics };
      if (only !== void 0 && only !== null) {
        result.only = only;
      }
      if (triggerKind !== void 0 && triggerKind !== null) {
        result.triggerKind = triggerKind;
      }
      return result;
    }
    CodeActionContext2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext2.is = is;
  })(CodeActionContext || (CodeActionContext = {}));
  var CodeAction;
  (function(CodeAction2) {
    function create(title, kindOrCommandOrEdit, kind) {
      var result = { title };
      var checkKind = true;
      if (typeof kindOrCommandOrEdit === "string") {
        checkKind = false;
        result.kind = kindOrCommandOrEdit;
      } else if (Command2.is(kindOrCommandOrEdit)) {
        result.command = kindOrCommandOrEdit;
      } else {
        result.edit = kindOrCommandOrEdit;
      }
      if (checkKind && kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    CodeAction2.create = create;
    function is(value) {
      var candidate = value;
      return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction2.is = is;
  })(CodeAction || (CodeAction = {}));
  var CodeLens;
  (function(CodeLens2) {
    function create(range, data) {
      var result = { range };
      if (Is.defined(data)) {
        result.data = data;
      }
      return result;
    }
    CodeLens2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command2.is(candidate.command));
    }
    CodeLens2.is = is;
  })(CodeLens || (CodeLens = {}));
  var FormattingOptions;
  (function(FormattingOptions2) {
    function create(tabSize, insertSpaces) {
      return { tabSize, insertSpaces };
    }
    FormattingOptions2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions2.is = is;
  })(FormattingOptions || (FormattingOptions = {}));
  var DocumentLink;
  (function(DocumentLink2) {
    function create(range, target, data) {
      return { range, target, data };
    }
    DocumentLink2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink2.is = is;
  })(DocumentLink || (DocumentLink = {}));
  var SelectionRange;
  (function(SelectionRange2) {
    function create(range, parent) {
      return { range, parent };
    }
    SelectionRange2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
    }
    SelectionRange2.is = is;
  })(SelectionRange || (SelectionRange = {}));
  var SemanticTokenTypes;
  (function(SemanticTokenTypes2) {
    SemanticTokenTypes2["namespace"] = "namespace";
    SemanticTokenTypes2["type"] = "type";
    SemanticTokenTypes2["class"] = "class";
    SemanticTokenTypes2["enum"] = "enum";
    SemanticTokenTypes2["interface"] = "interface";
    SemanticTokenTypes2["struct"] = "struct";
    SemanticTokenTypes2["typeParameter"] = "typeParameter";
    SemanticTokenTypes2["parameter"] = "parameter";
    SemanticTokenTypes2["variable"] = "variable";
    SemanticTokenTypes2["property"] = "property";
    SemanticTokenTypes2["enumMember"] = "enumMember";
    SemanticTokenTypes2["event"] = "event";
    SemanticTokenTypes2["function"] = "function";
    SemanticTokenTypes2["method"] = "method";
    SemanticTokenTypes2["macro"] = "macro";
    SemanticTokenTypes2["keyword"] = "keyword";
    SemanticTokenTypes2["modifier"] = "modifier";
    SemanticTokenTypes2["comment"] = "comment";
    SemanticTokenTypes2["string"] = "string";
    SemanticTokenTypes2["number"] = "number";
    SemanticTokenTypes2["regexp"] = "regexp";
    SemanticTokenTypes2["operator"] = "operator";
    SemanticTokenTypes2["decorator"] = "decorator";
  })(SemanticTokenTypes || (SemanticTokenTypes = {}));
  var SemanticTokenModifiers;
  (function(SemanticTokenModifiers2) {
    SemanticTokenModifiers2["declaration"] = "declaration";
    SemanticTokenModifiers2["definition"] = "definition";
    SemanticTokenModifiers2["readonly"] = "readonly";
    SemanticTokenModifiers2["static"] = "static";
    SemanticTokenModifiers2["deprecated"] = "deprecated";
    SemanticTokenModifiers2["abstract"] = "abstract";
    SemanticTokenModifiers2["async"] = "async";
    SemanticTokenModifiers2["modification"] = "modification";
    SemanticTokenModifiers2["documentation"] = "documentation";
    SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
  })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
  var SemanticTokens;
  (function(SemanticTokens2) {
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
    }
    SemanticTokens2.is = is;
  })(SemanticTokens || (SemanticTokens = {}));
  var InlineValueText;
  (function(InlineValueText2) {
    function create(range, text) {
      return { range, text };
    }
    InlineValueText2.create = create;
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText2.is = is;
  })(InlineValueText || (InlineValueText = {}));
  var InlineValueVariableLookup;
  (function(InlineValueVariableLookup2) {
    function create(range, variableName, caseSensitiveLookup) {
      return { range, variableName, caseSensitiveLookup };
    }
    InlineValueVariableLookup2.create = create;
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
    }
    InlineValueVariableLookup2.is = is;
  })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
  var InlineValueEvaluatableExpression;
  (function(InlineValueEvaluatableExpression2) {
    function create(range, expression) {
      return { range, expression };
    }
    InlineValueEvaluatableExpression2.create = create;
    function is(value) {
      var candidate = value;
      return candidate !== void 0 && candidate !== null && Range2.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
    }
    InlineValueEvaluatableExpression2.is = is;
  })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
  var InlineValueContext;
  (function(InlineValueContext2) {
    function create(frameId, stoppedLocation) {
      return { frameId, stoppedLocation };
    }
    InlineValueContext2.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Range2.is(value.stoppedLocation);
    }
    InlineValueContext2.is = is;
  })(InlineValueContext || (InlineValueContext = {}));
  var InlayHintKind3;
  (function(InlayHintKind4) {
    InlayHintKind4.Type = 1;
    InlayHintKind4.Parameter = 2;
    function is(value) {
      return value === 1 || value === 2;
    }
    InlayHintKind4.is = is;
  })(InlayHintKind3 || (InlayHintKind3 = {}));
  var InlayHintLabelPart;
  (function(InlayHintLabelPart2) {
    function create(value) {
      return { value };
    }
    InlayHintLabelPart2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command2.is(candidate.command));
    }
    InlayHintLabelPart2.is = is;
  })(InlayHintLabelPart || (InlayHintLabelPart = {}));
  var InlayHint;
  (function(InlayHint2) {
    function create(position, label, kind) {
      var result = { position, label };
      if (kind !== void 0) {
        result.kind = kind;
      }
      return result;
    }
    InlayHint2.create = create;
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && Position2.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind3.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
    }
    InlayHint2.is = is;
  })(InlayHint || (InlayHint = {}));
  var WorkspaceFolder;
  (function(WorkspaceFolder2) {
    function is(value) {
      var candidate = value;
      return Is.objectLiteral(candidate) && URI3.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder2.is = is;
  })(WorkspaceFolder || (WorkspaceFolder = {}));
  var TextDocument2;
  (function(TextDocument3) {
    function create(uri, languageId2, version, content) {
      return new FullTextDocument2(uri, languageId2, version, content);
    }
    TextDocument3.create = create;
    function is(value) {
      var candidate = value;
      return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument3.is = is;
    function applyEdits(document2, edits) {
      var text = document2.getText();
      var sortedEdits = mergeSort2(edits, function(a2, b) {
        var diff = a2.range.start.line - b.range.start.line;
        if (diff === 0) {
          return a2.range.start.character - b.range.start.character;
        }
        return diff;
      });
      var lastModifiedOffset = text.length;
      for (var i = sortedEdits.length - 1; i >= 0; i--) {
        var e = sortedEdits[i];
        var startOffset = document2.offsetAt(e.range.start);
        var endOffset = document2.offsetAt(e.range.end);
        if (endOffset <= lastModifiedOffset) {
          text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
        } else {
          throw new Error("Overlapping edit");
        }
        lastModifiedOffset = startOffset;
      }
      return text;
    }
    TextDocument3.applyEdits = applyEdits;
    function mergeSort2(data, compare) {
      if (data.length <= 1) {
        return data;
      }
      var p = data.length / 2 | 0;
      var left = data.slice(0, p);
      var right = data.slice(p);
      mergeSort2(left, compare);
      mergeSort2(right, compare);
      var leftIdx = 0;
      var rightIdx = 0;
      var i = 0;
      while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
          data[i++] = left[leftIdx++];
        } else {
          data[i++] = right[rightIdx++];
        }
      }
      while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
      }
      while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
      }
      return data;
    }
  })(TextDocument2 || (TextDocument2 = {}));
  var FullTextDocument2 = (
    /** @class */
    function() {
      function FullTextDocument3(uri, languageId2, version, content) {
        this._uri = uri;
        this._languageId = languageId2;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = void 0;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position2.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position2.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument3;
    }()
  );
  var Is;
  (function(Is2) {
    var toString = Object.prototype.toString;
    function defined(value) {
      return typeof value !== "undefined";
    }
    Is2.defined = defined;
    function undefined2(value) {
      return typeof value === "undefined";
    }
    Is2.undefined = undefined2;
    function boolean(value) {
      return value === true || value === false;
    }
    Is2.boolean = boolean;
    function string2(value) {
      return toString.call(value) === "[object String]";
    }
    Is2.string = string2;
    function number(value) {
      return toString.call(value) === "[object Number]";
    }
    Is2.number = number;
    function numberRange(value, min, max) {
      return toString.call(value) === "[object Number]" && min <= value && value <= max;
    }
    Is2.numberRange = numberRange;
    function integer2(value) {
      return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
    }
    Is2.integer = integer2;
    function uinteger2(value) {
      return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
    }
    Is2.uinteger = uinteger2;
    function func(value) {
      return toString.call(value) === "[object Function]";
    }
    Is2.func = func;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    Is2.objectLiteral = objectLiteral;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    Is2.typedArray = typedArray;
  })(Is || (Is = {}));

  // node_modules/yaml/browser/dist/nodes/identity.js
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

  // node_modules/yaml/browser/dist/visit.js
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit2(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit2.BREAK = BREAK;
  visit2.SKIP = SKIP;
  visit2.REMOVE = REMOVE;
  function visit_(key, node, visitor, path5) {
    const ctrl = callVisitor(key, node, visitor, path5);
    if (isNode(ctrl) || isPair(ctrl)) {
      replaceNode(key, path5, ctrl);
      return visit_(key, ctrl, visitor, path5);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path5 = Object.freeze(path5.concat(node));
        for (let i = 0; i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path5);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (isPair(node)) {
        path5 = Object.freeze(path5.concat(node));
        const ck = visit_("key", node.key, visitor, path5);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path5);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path5) {
    const ctrl = await callVisitor(key, node, visitor, path5);
    if (isNode(ctrl) || isPair(ctrl)) {
      replaceNode(key, path5, ctrl);
      return visitAsync_(key, ctrl, visitor, path5);
    }
    if (typeof ctrl !== "symbol") {
      if (isCollection(node)) {
        path5 = Object.freeze(path5.concat(node));
        for (let i = 0; i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path5);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (isPair(node)) {
        path5 = Object.freeze(path5.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path5);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path5);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path5) {
    if (typeof visitor === "function")
      return visitor(key, node, path5);
    if (isMap(node))
      return visitor.Map?.(key, node, path5);
    if (isSeq(node))
      return visitor.Seq?.(key, node, path5);
    if (isPair(node))
      return visitor.Pair?.(key, node, path5);
    if (isScalar(node))
      return visitor.Scalar?.(key, node, path5);
    if (isAlias(node))
      return visitor.Alias?.(key, node, path5);
    return void 0;
  }
  function replaceNode(key, path5, node) {
    const parent = path5[path5.length - 1];
    if (isCollection(parent)) {
      parent.items[key] = node;
    } else if (isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }

  // node_modules/yaml/browser/dist/doc/directives.js
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
  var Directives = class _Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, _Directives.defaultTags, tags);
    }
    clone() {
      const copy = new _Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
      const res = new _Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: _Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, _Directives.defaultTags);
          break;
      }
      return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, _Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix)
        return prefix + decodeURIComponent(suffix);
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
        const tags = {};
        visit2(doc.contents, (_key, node) => {
          if (isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join("\n");
    }
  };
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

  // node_modules/yaml/browser/dist/doc/anchors.js
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = /* @__PURE__ */ new Set();
    visit2(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = /* @__PURE__ */ new Map();
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        if (!prevAnchors)
          prevAnchors = anchorNames(doc);
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      /**
       * With circular references, the source node is only resolved after all
       * of its child nodes are. This is why anchors are set only after all of
       * the nodes have been created.
       */
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }

  // node_modules/yaml/browser/dist/doc/applyReviver.js
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length; i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === void 0)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === void 0)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === void 0)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === void 0)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }

  // node_modules/yaml/browser/dist/nodes/toJS.js
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: void 0 };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }

  // node_modules/yaml/browser/dist/nodes/Node.js
  var NodeBase = class {
    constructor(type) {
      Object.defineProperty(this, NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: /* @__PURE__ */ new Map(),
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
    }
  };

  // node_modules/yaml/browser/dist/nodes/Alias.js
  var Alias = class extends NodeBase {
    constructor(source) {
      super(ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
      let found = void 0;
      visit2(doc, {
        Node: (_key, node) => {
          if (node === this)
            return visit2.BREAK;
          if (node.anchor === this.source)
            found = node;
        }
      });
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors.get(source);
      if (!data) {
        toJS(source, null, ctx);
        data = anchors.get(source);
      }
      if (!data || data.res === void 0) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  };
  function getAliasCount(doc, node, anchors) {
    if (isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors && source && anchors.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors);
        if (c > count)
          count = c;
      }
      return count;
    } else if (isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors);
      const vc = getAliasCount(doc, node.value, anchors);
      return Math.max(kc, vc);
    }
    return 1;
  }

  // node_modules/yaml/browser/dist/nodes/Scalar.js
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
  var Scalar = class extends NodeBase {
    constructor(value) {
      super(SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  };
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

  // node_modules/yaml/browser/dist/doc/createNode.js
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (isDocument(value))
      value = value.contents;
    if (isNode(value))
      return value;
    if (isPair(value)) {
      const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
      map2.items.push(value);
      return map2;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema5, sourceObjects } = ctx;
    let ref = void 0;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        if (!ref.anchor)
          ref.anchor = onAnchor(value);
        return new Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema5.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema5[MAP] : Symbol.iterator in Object(value) ? schema5[SEQ] : schema5[MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }

  // node_modules/yaml/browser/dist/nodes/Collection.js
  function collectionFromPath(schema5, path5, value) {
    let v = value;
    for (let i = path5.length - 1; i >= 0; --i) {
      const k = path5[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a2 = [];
        a2[k] = v;
        v = a2;
      } else {
        v = /* @__PURE__ */ new Map([[k, v]]);
      }
    }
    return createNode(v, void 0, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema: schema5,
      sourceObjects: /* @__PURE__ */ new Map()
    });
  }
  var isEmptyPath = (path5) => path5 == null || typeof path5 === "object" && !!path5[Symbol.iterator]().next().done;
  var Collection = class extends NodeBase {
    constructor(type, schema5) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema5,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema5) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema5)
        copy.schema = schema5;
      copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema5) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path5, value) {
      if (isEmptyPath(path5))
        this.add(value);
      else {
        const [key, ...rest] = path5;
        const node = this.get(key, true);
        if (isCollection(node))
          node.addIn(rest, value);
        else if (node === void 0 && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path5) {
      const [key, ...rest] = path5;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path5, keepScalar) {
      const [key, ...rest] = path5;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && isScalar(node) ? node.value : node;
      else
        return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path5) {
      const [key, ...rest] = path5;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path5, value) {
      const [key, ...rest] = path5;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (isCollection(node))
          node.setIn(rest, value);
        else if (node === void 0 && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  };
  Collection.maxFlowStringSingleLineLength = 60;

  // node_modules/yaml/browser/dist/stringify/stringifyComment.js
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

  // node_modules/yaml/browser/dist/stringify/foldFlowLines.js
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = void 0;
    let prev = void 0;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch; ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === "\n") {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i);
        end = i + endStep;
        split = void 0;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
          const next = text[i + 1];
          if (next && next !== " " && next !== "\n" && next !== "	")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = void 0;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "	") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = void 0;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0; i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    while (ch === " " || ch === "	") {
      do {
        ch = text[i += 1];
      } while (ch && ch !== "\n");
      ch = text[i + 1];
    }
    return i;
  }

  // node_modules/yaml/browser/dist/stringify/stringifyString.js
  var getFoldOptions = (ctx, isBlock2) => ({
    indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
      if (str[i] === "\n") {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + "\n\n";
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += "\n";
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? "|\n" : ">\n";
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== "\n" && ch !== "	" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf("\n");
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === "\n")
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === "\n")
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (literal) {
      value = value.replace(/\n+/g, `$&${indent}`);
      return `${header}
${indent}${start}${value}${end}`;
    }
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
    return `${header}
${indent}${body}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.BLOCK_FOLDED:
        case Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }

  // node_modules/yaml/browser/dist/stringify/stringify.js
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: /* @__PURE__ */ new Set(),
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = void 0;
    let obj;
    if (isScalar(item)) {
      obj = item.value;
      const match = tags.filter((t) => t.identify?.(obj));
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? typeof obj;
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
    if (anchor && anchorIsValid(anchor)) {
      anchors.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = void 0;
    const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    if (!tagObj)
      tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }

  // node_modules/yaml/browser/dist/stringify/stringifyPair.js
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (isCollection(key)) {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? "\n" : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === "\n")
          ws = "\n\n";
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf("\n");
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === "\n") {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }

  // node_modules/yaml/browser/dist/log.js
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof process !== "undefined" && process.emitWarning)
        process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }

  // node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
  var MERGE_KEY = "<<";
  function addPairToJSMap(ctx, map2, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
      value = isAlias(value) ? value.resolve(ctx.doc) : value;
      if (isSeq(value))
        for (const it of value.items)
          mergeToJSMap(ctx, map2, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeToJSMap(ctx, map2, it);
      else
        mergeToJSMap(ctx, map2, value);
    } else {
      const jsKey = toJS(key, "", ctx);
      if (map2 instanceof Map) {
        map2.set(jsKey, toJS(value, jsKey, ctx));
      } else if (map2 instanceof Set) {
        map2.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS(value, stringKey, ctx);
        if (stringKey in map2)
          Object.defineProperty(map2, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map2[stringKey] = jsValue;
      }
    }
    return map2;
  }
  var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
  function mergeToJSMap(ctx, map2, value) {
    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map2 instanceof Map) {
        if (!map2.has(key))
          map2.set(key, value2);
      } else if (map2 instanceof Set) {
        map2.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
        Object.defineProperty(map2, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map2;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (isNode(key) && ctx && ctx.doc) {
      const strCtx = createStringifyContext(ctx.doc, {});
      strCtx.anchors = /* @__PURE__ */ new Set();
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }

  // node_modules/yaml/browser/dist/nodes/Pair.js
  function createPair(key, value, ctx) {
    const k = createNode(key, void 0, ctx);
    const v = createNode(value, void 0, ctx);
    return new Pair(k, v);
  }
  var Pair = class _Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, NODE_TYPE, { value: PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema5) {
      let { key, value } = this;
      if (isNode(key))
        key = key.clone(schema5);
      if (isNode(value))
        value = value.clone(schema5);
      return new _Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      return addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  };

  // node_modules/yaml/browser/dist/stringify/stringifyCollection.js
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify4(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (isPair(item)) {
        const ik = isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1; i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : "\n";
      }
    }
    if (comment) {
      str += "\n" + indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment2 = item.comment;
      } else if (isPair(item)) {
        const ik = isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment2 = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik && ik.comment) {
          comment2 = ik.comment;
        }
      }
      if (comment2)
        reqNewline = true;
      let str2 = stringify(item, itemCtx, () => comment2 = null);
      if (i < items.length - 1)
        str2 += ",";
      if (comment2)
        str2 += lineComment(str2, itemIndent, commentString(comment2));
      if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
        reqNewline = true;
      lines.push(str2);
      linesAtValue = lines.length;
    }
    let str;
    const { start, end } = flowChars;
    if (lines.length === 0) {
      str = start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = len > Collection.maxFlowStringSingleLineLength;
      }
      if (reqNewline) {
        str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : "\n";
        str += `
${indent}${end}`;
      } else {
        str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
    if (comment) {
      str += lineComment(str, indent, commentString(comment));
      if (onComment)
        onComment();
    }
    return str;
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }

  // node_modules/yaml/browser/dist/nodes/YAMLMap.js
  function findPair(items, key) {
    const k = isScalar(key) ? key.value : key;
    for (const it of items) {
      if (isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return void 0;
  }
  var YAMLMap = class extends Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema5) {
      super(MAP, schema5);
      this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema5, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map2 = new this(schema5);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== void 0 || keepUndefined)
          map2.items.push(createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema5.sortMapEntries === "function") {
        map2.items.sort(schema5.sortMapEntries);
      }
      return map2;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
      let _pair;
      if (isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair(pair, pair?.value);
      } else
        _pair = new Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (isScalar(prev.value) && isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
      const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      if (ctx?.onCreate)
        ctx.onCreate(map2);
      for (const item of this.items)
        addPairToJSMap(ctx, map2, item);
      return map2;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  };

  // node_modules/yaml/browser/dist/schema/common/map.js
  var map = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map2, onError) {
      if (!isMap(map2))
        onError("Expected a mapping for this tag");
      return map2;
    },
    createNode: (schema5, obj, ctx) => YAMLMap.from(schema5, obj, ctx)
  };

  // node_modules/yaml/browser/dist/nodes/YAMLSeq.js
  var YAMLSeq = class extends Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema5) {
      super(SEQ, schema5);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return void 0;
      const it = this.items[idx];
      return !keepScalar && isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (isScalar(prev) && isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq2 = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq2);
      let i = 0;
      for (const item of this.items)
        seq2.push(toJS(item, String(i++), ctx));
      return seq2;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema5, obj, ctx) {
      const { replacer } = ctx;
      const seq2 = new this(schema5);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq2.items.push(createNode(it, void 0, ctx));
        }
      }
      return seq2;
    }
  };
  function asItemIndex(key) {
    let idx = isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }

  // node_modules/yaml/browser/dist/schema/common/seq.js
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema5, obj, ctx) => YAMLSeq.from(schema5, obj, ctx)
  };

  // node_modules/yaml/browser/dist/schema/common/string.js
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString(item, ctx, onComment, onChompKeep);
    }
  };

  // node_modules/yaml/browser/dist/schema/common/null.js
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };

  // node_modules/yaml/browser/dist/schema/core/bool.js
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };

  // node_modules/yaml/browser/dist/stringify/stringifyNumber.js
  function stringifyNumber({ format: format5, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format5 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }

  // node_modules/yaml/browser/dist/schema/core/float.js
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber
  };

  // node_modules/yaml/browser/dist/schema/core/int.js
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };

  // node_modules/yaml/browser/dist/schema/core/schema.js
  var schema = [
    map,
    seq,
    string,
    nullTag,
    boolTag,
    intOct,
    int,
    intHex,
    floatNaN,
    floatExp,
    float
  ];

  // node_modules/yaml/browser/dist/schema/json/schema.js
  function intIdentify2(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema2 = [map, seq].concat(jsonScalars, jsonError);

  // node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
      if (typeof Buffer === "function") {
        return Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0; i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      const buf = value;
      let str;
      if (typeof Buffer === "function") {
        str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0; i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      if (!type)
        type = Scalar.BLOCK_LITERAL;
      if (type !== Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
      }
      return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
  function resolvePairs(seq2, onError) {
    if (isSeq(seq2)) {
      for (let i = 0; i < seq2.items.length; ++i) {
        let item = seq2.items[i];
        if (isPair(item))
          continue;
        else if (isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair(new Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq2.items[i] = isPair(item) ? item : new Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq2;
  }
  function createPairs(schema5, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq(schema5);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else
            throw new TypeError(`Expected { key: value } tuple: ${it}`);
        } else {
          key = it;
        }
        pairs2.items.push(createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
  var YAMLOMap = class _YAMLOMap extends YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.prototype.set.bind(this);
      this.tag = _YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map2 = /* @__PURE__ */ new Map();
      if (ctx?.onCreate)
        ctx.onCreate(map2);
      for (const pair of this.items) {
        let key, value;
        if (isPair(pair)) {
          key = toJS(pair.key, "", ctx);
          value = toJS(pair.value, key, ctx);
        } else {
          key = toJS(pair, "", ctx);
        }
        if (map2.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map2.set(key, value);
      }
      return map2;
    }
    static from(schema5, iterable, ctx) {
      const pairs2 = createPairs(schema5, iterable, ctx);
      const omap2 = new this();
      omap2.items = pairs2.items;
      return omap2;
    }
  };
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq2, onError) {
      const pairs2 = resolvePairs(seq2, onError);
      const seenKeys = [];
      for (const { key } of pairs2.items) {
        if (isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap(), pairs2);
    },
    createNode: (schema5, iterable, ctx) => YAMLOMap.from(schema5, iterable, ctx)
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar(false),
    stringify: boolStringify
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
  var floatNaN2 = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
  };
  var floatExp2 = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
  };
  var float2 = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f2 = str.substring(dot + 1).replace(/_/g, "");
        if (f2[f2.length - 1] === "0")
          node.minFractionDigits = f2.length;
      }
      return node;
    },
    stringify: stringifyNumber
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
  var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve2(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify2(node, radix, prefix) {
    const { value } = node;
    if (intIdentify3(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
    stringify: (node) => intStringify2(node, 2, "0b")
  };
  var intOct2 = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
    stringify: (node) => intStringify2(node, 8, "0")
  };
  var int2 = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
    stringify: stringifyNumber
  };
  var intHex2 = {
    identify: intIdentify3,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
    stringify: (node) => intStringify2(node, 16, "0x")
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
  var YAMLSet = class _YAMLSet extends YAMLMap {
    constructor(schema5) {
      super(schema5);
      this.tag = _YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair(key.key, null);
      else
        pair = new Pair(key, null);
      const prev = findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
      const pair = findPair(this.items, key);
      return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema5, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema5);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set2.items.push(createPair(value, null, ctx));
        }
      return set2;
    }
  };
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema5, iterable, ctx) => YAMLSet.from(schema5, iterable, ctx),
    resolve(map2, onError) {
      if (isMap(map2)) {
        if (map2.hasAllNullValues(true))
          return Object.assign(new YAMLSet(), map2);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map2;
    }
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 6e4 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
  };

  // node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
  var schema3 = [
    map,
    seq,
    string,
    nullTag,
    trueTag,
    falseTag,
    intBin,
    intOct2,
    int2,
    intHex2,
    floatNaN2,
    floatExp2,
    float2,
    binary,
    omap,
    pairs,
    set,
    intTime,
    floatTime,
    timestamp
  ];

  // node_modules/yaml/browser/dist/schema/tags.js
  var schemas = /* @__PURE__ */ new Map([
    ["core", schema],
    ["failsafe", [map, seq, string]],
    ["json", schema2],
    ["yaml11", schema3],
    ["yaml-1.1", schema3]
  ]);
  var tagsByName = {
    binary,
    bool: boolTag,
    float,
    floatExp,
    floatNaN,
    floatTime,
    int,
    intHex,
    intOct,
    intTime,
    map,
    null: nullTag,
    omap,
    pairs,
    seq,
    set,
    timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary,
    "tag:yaml.org,2002:omap": omap,
    "tag:yaml.org,2002:pairs": pairs,
    "tag:yaml.org,2002:set": set,
    "tag:yaml.org,2002:timestamp": timestamp
  };
  function getTags(customTags, schemaName2) {
    let tags = schemas.get(schemaName2);
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName2}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    return tags.map((tag) => {
      if (typeof tag !== "string")
        return tag;
      const tagObj = tagsByName[tag];
      if (tagObj)
        return tagObj;
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
  }

  // node_modules/yaml/browser/dist/schema/Schema.js
  var sortMapEntriesByKey = (a2, b) => a2.key < b.key ? -1 : a2.key > b.key ? 1 : 0;
  var Schema = class _Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema: schema5, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
      this.merge = !!merge;
      this.name = typeof schema5 === "string" && schema5 || "core";
      this.knownTags = resolveKnownTags ? coreKnownTags : {};
      this.tags = getTags(customTags, this.name);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, MAP, { value: map });
      Object.defineProperty(this, SCALAR, { value: string });
      Object.defineProperty(this, SEQ, { value: seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  };

  // node_modules/yaml/browser/dist/stringify/stringifyDocument.js
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
      let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes("\n")) {
          lines.push("...");
          lines.push(indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(indentComment(commentString(dc), ""));
      }
    }
    return lines.join("\n") + "\n";
  }

  // node_modules/yaml/browser/dist/doc/Document.js
  var Document = class _Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, NODE_TYPE, { value: DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
        replacer = void 0;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new Directives({ version });
      this.setSchema(version, options);
      this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
      const copy = Object.create(_Document.prototype, {
        [NODE_TYPE]: { value: DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /** Adds a value to the document. */
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path5, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path5, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchorNames(this);
        node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
      }
      return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = void 0;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
        replacer = void 0;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
        this,
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || "a"
      );
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode(value, tag, ctx);
      if (flow && isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path5) {
      if (isEmptyPath(path5)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path5) : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
      return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path5, keepScalar) {
      if (isEmptyPath(path5))
        return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
      return isCollection(this.contents) ? this.contents.getIn(path5, keepScalar) : void 0;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
      return isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path5) {
      if (isEmptyPath(path5))
        return this.contents !== void 0;
      return isCollection(this.contents) ? this.contents.hasIn(path5) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
      if (this.contents == null) {
        this.contents = collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path5, value) {
      if (isEmptyPath(path5)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = collectionFromPath(this.schema, Array.from(path5), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path5, value);
      }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new Directives({ version: "1.1" });
          opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new Directives({ version });
          opt = { merge: false, resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: /* @__PURE__ */ new Map(),
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument(this, options);
    }
  };
  function assertCollection(contents) {
    if (isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }

  // node_modules/yaml/browser/dist/errors.js
  var YAMLError = class extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  };
  var YAMLParseError = class extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  };
  var YAMLWarning = class extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  };
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "\u2026" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "\u2026";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + "\u2026\n";
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end && end.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };

  // node_modules/yaml/browser/dist/compose/resolve-props.js
  function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      switch (token.type) {
        case "space":
          if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
            onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            hasNewlineAfterProp = true;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = false;
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      hasNewlineAfterProp,
      anchor,
      tag,
      end,
      start: start ?? end
    };
  }

  // node_modules/yaml/browser/dist/compose/util-contains-newline.js
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes("\n"))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }

  // node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }

  // node_modules/yaml/browser/dist/compose/util-map-includes.js
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b) => a2 === b || isScalar(a2) && isScalar(b) && a2.value === b.value && !(a2.value === "<<" && ctx.schema.merge);
    return items.some((pair) => isEqual(pair.key, search));
  }

  // node_modules/yaml/browser/dist/compose/resolve-block-map.js
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap;
    const map2 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep: sep2, value } = collItem;
      const keyProps = resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep2?.[0],
        offset,
        onError,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep2) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map2.comment)
              map2.comment += "\n" + keyProps.comment;
            else
              map2.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, key, onError);
      if (mapIncludes(ctx, map2.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps(sep2 ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep2, null, valueProps, onError);
        if (ctx.schema.compat)
          flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map2.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map2.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map2.range = [bm.offset, offset, commentEnd ?? offset];
    return map2;
  }

  // node_modules/yaml/browser/dist/compose/resolve-block-seq.js
  function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq;
    const seq2 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq2.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq2.items.push(node);
    }
    seq2.range = [bs.offset, offset, commentEnd ?? offset];
    return seq2;
  }

  // node_modules/yaml/browser/dist/compose/resolve-end.js
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep2 = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep2 + cb;
            sep2 = "";
            break;
          }
          case "newline":
            if (comment)
              sep2 += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }

  // node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
    const isMap2 = fc.start.source === "{";
    const fcName = isMap2 ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep: sep2, value } = collItem;
      const props = resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep2?.[0],
        offset,
        onError,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep2 && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += "\n" + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap2 && ctx.options.strict && containsNewline(key))
          onError(
            key,
            // checked by containsNewline()
            "MULTILINE_IMPLICIT_KEY",
            "Implicit keys of flow sequence pairs need to be on a single line"
          );
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += "\n" + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap2 && !sep2 && !props.found) {
        const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep2, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        const keyStart = props.end;
        const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        const valueProps = resolveProps(sep2 ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap2 && !props.found && ctx.options.strict) {
            if (sep2)
              for (const st of sep2) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap2) {
          const map2 = coll;
          if (mapIncludes(ctx, map2.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map2.items.push(pair);
        } else {
          const map2 = new YAMLMap(ctx.schema);
          map2.flow = true;
          map2.items.push(pair);
          coll.items.push(map2);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap2 ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += "\n" + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }

  // node_modules/yaml/browser/dist/compose/compose-collection.js
  function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN2, ctx, token, tagToken, onError) {
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq" || !expType) {
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt?.collection) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN2, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = isNode(res) ? res : new Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }

  // node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
  function resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines2(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1; i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep2 = "";
    let prevMoreIndented = false;
    for (let i = 0; i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + "\n";
    for (let i = contentStart; i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.BLOCK_LITERAL) {
        value += sep2 + indent.slice(trimIndent) + content;
        sep2 = "\n";
      } else if (indent.length > trimIndent || content[0] === "	") {
        if (sep2 === " ")
          sep2 = "\n";
        else if (!prevMoreIndented && sep2 === "\n")
          sep2 = "\n\n";
        value += sep2 + indent.slice(trimIndent) + content;
        sep2 = "\n";
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep2 === "\n")
          value += "\n";
        else
          sep2 = "\n";
      } else {
        value += sep2 + content;
        sep2 = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart; i < lines.length; ++i)
          value += "\n" + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== "\n")
          value += "\n";
        break;
      default:
        value += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines2(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }

  // node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "	":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
      line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
    } catch (_) {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep2 = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep2 === "\n")
          res += sep2;
        else
          sep2 = "\n";
      } else {
        res += sep2 + match[1];
        sep2 = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep2 + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1; i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === "\n")
        continue;
      if (ch === "\n") {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === "\n") {
          next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === "\n") {
          next = source[++i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "	") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
        if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== "\n")
        break;
      if (ch === "\n")
        fold += "\n";
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\0",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	",
    v: "\v",
    N: "\x85",
    _: "\xA0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "	": "	"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }

  // node_modules/yaml/browser/dist/compose/compose-scalar.js
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = isScalar(res) ? res : new Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema5, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema5[SCALAR];
    const matchWithTest = [];
    for (const tag of schema5.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema5.knownTags[tagName];
    if (kt && !kt.collection) {
      schema5.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema5[SCALAR];
  }
  function findScalarTagByTest({ directives, schema: schema5 }, value, token, onError) {
    const tag = schema5.tags.find((tag2) => tag2.default && tag2.test?.test(value)) || schema5[SCALAR];
    if (schema5.compat) {
      const compat = schema5.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema5[SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }

  // node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      if (pos === null)
        pos = before.length;
      for (let i = pos - 1; i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }

  // node_modules/yaml/browser/dist/compose/compose-node.js
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection(CN, ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }

  // node_modules/yaml/browser/dist/compose/compose-doc.js
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document(void 0, opts);
    const ctx = {
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }

  // node_modules/yaml/browser/dist/compose/composer.js
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }
  var Composer = class {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new YAMLWarning(pos, code, message));
        else
          this.errors.push(new YAMLParseError(pos, code, message));
      };
      this.directives = new Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document(void 0, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  };

  // node_modules/yaml/browser/dist/parse/cst.js
  var cst_exports = {};
  __export(cst_exports, {
    BOM: () => BOM,
    DOCUMENT: () => DOCUMENT,
    FLOW_END: () => FLOW_END,
    SCALAR: () => SCALAR2,
    createScalarToken: () => createScalarToken,
    isCollection: () => isCollection2,
    isScalar: () => isScalar2,
    prettyToken: () => prettyToken,
    resolveAsScalar: () => resolveAsScalar,
    setScalarValue: () => setScalarValue,
    stringify: () => stringify2,
    tokenType: () => tokenType,
    visit: () => visit3
  });

  // node_modules/yaml/browser/dist/parse/cst-scalar.js
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar(token, strict, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: "\n" }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf("\n");
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + "\n";
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf("\n");
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + "\n";
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }

  // node_modules/yaml/browser/dist/parse/cst-stringify.js
  var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep: sep2, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep2)
      for (const st of sep2)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }

  // node_modules/yaml/browser/dist/parse/cst-visit.js
  var BREAK2 = Symbol("break visit");
  var SKIP2 = Symbol("skip children");
  var REMOVE2 = Symbol("remove item");
  function visit3(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit3.BREAK = BREAK2;
  visit3.SKIP = SKIP2;
  visit3.REMOVE = REMOVE2;
  visit3.itemAtPath = (cst, path5) => {
    let item = cst;
    for (const [field, index] of path5) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return void 0;
    }
    return item;
  };
  visit3.parentCollection = (cst, path5) => {
    const parent = visit3.itemAtPath(cst, path5.slice(0, -1));
    const field = path5[path5.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path5, item, visitor) {
    let ctrl = visitor(item, path5);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0; i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path5.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK2)
            return BREAK2;
          else if (ci === REMOVE2) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path5);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path5) : ctrl;
  }

  // node_modules/yaml/browser/dist/parse/cst.js
  var BOM = "\uFEFF";
  var DOCUMENT = "";
  var FLOW_END = "";
  var SCALAR2 = "";
  var isCollection2 = (token) => !!token && "items" in token;
  var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR2:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR2:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case "\n":
      case "\r\n":
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "	":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }

  // node_modules/yaml/browser/dist/parse/lexer.js
  function isEmpty(ch) {
    switch (ch) {
      case void 0:
      case " ":
      case "\n":
      case "\r":
      case "	":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = "0123456789ABCDEFabcdef".split("");
  var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
  var invalidFlowScalarChars = ",[]{}".split("");
  var invalidAnchorChars = " ,[]{}\n\r	".split("");
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
  var Lexer = class {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
      if (source) {
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "	")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === "\n")
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === "\n";
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === "\n" || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf("\n", this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        const cs = line.indexOf("#");
        if (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "	")
            dirEnd = cs - 1;
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "	")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if (s === "---" && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return "doc";
        } else if (s === "..." && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          return "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case void 0:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case void 0:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf("\n", this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf("\n", cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i = this.pos; ch = this.buffer[i]; ++i) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else
          this.indentNext += this.blockScalarIndent;
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf("\n", cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      if (!this.blockScalarKeep) {
        do {
          let i = nl - 1;
          let ch2 = this.buffer[i];
          if (ch2 === "\r")
            ch2 = this.buffer[--i];
          const lastChar = i;
          while (ch2 === " " || ch2 === "	")
            ch2 = this.buffer[--i];
          if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
            nl = i;
          else
            break;
        } while (true);
      }
      yield SCALAR2;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && next === ",")
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === "\n") {
              i += 1;
              ch = "\n";
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
            break;
          if (ch === "\n") {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && invalidFlowScalarChars.includes(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield SCALAR2;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.includes(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === "\n")
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === "\n")
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "	");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  };

  // node_modules/yaml/browser/dist/parse/line-counter.js
  var LineCounter = class {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  };

  // node_modules/yaml/browser/dist/parse/parser.js
  function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {
    }
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }
  var Parser = class {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new Lexer();
      this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
      this.source = source;
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep2;
        if (scalar.end) {
          sep2 = scalar.end;
          sep2.push(this.sourceToken);
          delete scalar.end;
        } else
          sep2 = [this.sourceToken];
        const map2 = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep: sep2 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf("\n") + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf("\n", nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map2) {
      const it = map2.items[map2.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : void 0;
            const last = Array.isArray(end) ? end[end.length - 1] : void 0;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map2.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map2.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map2.indent)) {
              const prev = map2.items[map2.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map2.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map2.indent) {
        const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0; i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map2.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map2.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
              it.start.push(this.sourceToken);
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map2.items.push({ start });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken] }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (includesToken(it.start, "explicit-key-ind")) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep2 = it.sep;
                sep2.push(this.sourceToken);
                delete it.key, delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep: sep2 }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map2.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map2.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map2);
            if (bv) {
              if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
                map2.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq2) {
      const it = seq2.items[seq2.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : void 0;
            const last = Array.isArray(end) ? end[end.length - 1] : void 0;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq2.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq2.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq2.indent)) {
              const prev = seq2.items[seq2.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq2.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq2.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq2.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq2.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq2.indent) {
        const bv = this.startBlockValue(seq2);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top && top.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep2 = fc.end.splice(1, fc.end.length);
          sep2.push(this.sourceToken);
          const map2 = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map2;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf("\n") + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf("\n", nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  };

  // node_modules/yaml/browser/dist/public-api.js
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
    return { lineCounter, prettyErrors };
  }
  function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser2 = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    let doc = null;
    for (const _doc of composer.compose(parser2.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
    return doc;
  }
  function parse3(src, reviver, options) {
    let _reviver = void 0;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === void 0 && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }

  // node_modules/monaco-yaml/yaml.worker.js
  var path2 = __toESM(require_path_browserify(), 1);
  var path = __toESM(require_path_browserify(), 1);
  var path3 = __toESM(require_path_browserify(), 1);
  var prettier = __toESM(require_standalone(), 1);
  var parser = __toESM(require_parser_yaml(), 1);
  var path4 = __toESM(require_path_browserify(), 1);
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __commonJS2 = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var require_json_schema_draft_07 = __commonJS2({
    "node_modules/yaml-language-server/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
      module.exports = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
          schemaArray: {
            type: "array",
            minItems: 1,
            items: { $ref: "#" }
          },
          nonNegativeInteger: {
            type: "integer",
            minimum: 0
          },
          nonNegativeIntegerDefault0: {
            allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
          },
          simpleTypes: {
            enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
          },
          stringArray: {
            type: "array",
            items: { type: "string" },
            uniqueItems: true,
            default: []
          }
        },
        type: ["object", "boolean"],
        properties: {
          $id: {
            type: "string",
            format: "uri-reference"
          },
          $schema: {
            type: "string",
            format: "uri"
          },
          $ref: {
            type: "string",
            format: "uri-reference"
          },
          $comment: {
            type: "string"
          },
          title: {
            type: "string"
          },
          description: {
            type: "string"
          },
          default: true,
          readOnly: {
            type: "boolean",
            default: false
          },
          examples: {
            type: "array",
            items: true
          },
          multipleOf: {
            type: "number",
            exclusiveMinimum: 0
          },
          maximum: {
            type: "number"
          },
          exclusiveMaximum: {
            type: "number"
          },
          minimum: {
            type: "number"
          },
          exclusiveMinimum: {
            type: "number"
          },
          maxLength: { $ref: "#/definitions/nonNegativeInteger" },
          minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          pattern: {
            type: "string",
            format: "regex"
          },
          additionalItems: { $ref: "#" },
          items: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
            default: true
          },
          maxItems: { $ref: "#/definitions/nonNegativeInteger" },
          minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          uniqueItems: {
            type: "boolean",
            default: false
          },
          contains: { $ref: "#" },
          maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
          minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
          required: { $ref: "#/definitions/stringArray" },
          additionalProperties: { $ref: "#" },
          definitions: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          properties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            default: {}
          },
          patternProperties: {
            type: "object",
            additionalProperties: { $ref: "#" },
            propertyNames: { format: "regex" },
            default: {}
          },
          dependencies: {
            type: "object",
            additionalProperties: {
              anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
            }
          },
          propertyNames: { $ref: "#" },
          const: true,
          enum: {
            type: "array",
            items: true,
            minItems: 1,
            uniqueItems: true
          },
          type: {
            anyOf: [
              { $ref: "#/definitions/simpleTypes" },
              {
                type: "array",
                items: { $ref: "#/definitions/simpleTypes" },
                minItems: 1,
                uniqueItems: true
              }
            ]
          },
          format: { type: "string" },
          contentMediaType: { type: "string" },
          contentEncoding: { type: "string" },
          if: { $ref: "#" },
          then: { $ref: "#" },
          else: { $ref: "#" },
          allOf: { $ref: "#/definitions/schemaArray" },
          anyOf: { $ref: "#/definitions/schemaArray" },
          oneOf: { $ref: "#/definitions/schemaArray" },
          not: { $ref: "#" }
        },
        default: true
      };
    }
  });
  function startsWith(haystack, needle) {
    if (haystack.length < needle.length) {
      return false;
    }
    for (var i = 0; i < needle.length; i++) {
      if (haystack[i] !== needle[i]) {
        return false;
      }
    }
    return true;
  }
  function endsWith(haystack, needle) {
    var diff = haystack.length - needle.length;
    if (diff > 0) {
      return haystack.lastIndexOf(needle) === diff;
    } else if (diff === 0) {
      return haystack === needle;
    } else {
      return false;
    }
  }
  function extendedRegExp(pattern) {
    if (startsWith(pattern, "(?i)")) {
      return new RegExp(pattern.substring(4), "i");
    } else {
      return new RegExp(pattern);
    }
  }
  function equals2(one, other) {
    if (one === other) {
      return true;
    }
    if (one === null || one === void 0 || other === null || other === void 0) {
      return false;
    }
    if (typeof one !== typeof other) {
      return false;
    }
    if (typeof one !== "object") {
      return false;
    }
    if (Array.isArray(one) !== Array.isArray(other)) {
      return false;
    }
    var i, key;
    if (Array.isArray(one)) {
      if (one.length !== other.length) {
        return false;
      }
      for (i = 0; i < one.length; i++) {
        if (!equals2(one[i], other[i])) {
          return false;
        }
      }
    } else {
      var oneKeys = [];
      for (key in one) {
        oneKeys.push(key);
      }
      oneKeys.sort();
      var otherKeys = [];
      for (key in other) {
        otherKeys.push(key);
      }
      otherKeys.sort();
      if (!equals2(oneKeys, otherKeys)) {
        return false;
      }
      for (i = 0; i < oneKeys.length; i++) {
        if (!equals2(one[oneKeys[i]], other[oneKeys[i]])) {
          return false;
        }
      }
    }
    return true;
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isDefined(val) {
    return typeof val !== "undefined";
  }
  function isBoolean(val) {
    return typeof val === "boolean";
  }
  function isString2(val) {
    return typeof val === "string";
  }
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["Undefined"] = 0] = "Undefined";
    ErrorCode2[ErrorCode2["EnumValueMismatch"] = 1] = "EnumValueMismatch";
    ErrorCode2[ErrorCode2["Deprecated"] = 2] = "Deprecated";
    ErrorCode2[ErrorCode2["UnexpectedEndOfComment"] = 257] = "UnexpectedEndOfComment";
    ErrorCode2[ErrorCode2["UnexpectedEndOfString"] = 258] = "UnexpectedEndOfString";
    ErrorCode2[ErrorCode2["UnexpectedEndOfNumber"] = 259] = "UnexpectedEndOfNumber";
    ErrorCode2[ErrorCode2["InvalidUnicode"] = 260] = "InvalidUnicode";
    ErrorCode2[ErrorCode2["InvalidEscapeCharacter"] = 261] = "InvalidEscapeCharacter";
    ErrorCode2[ErrorCode2["InvalidCharacter"] = 262] = "InvalidCharacter";
    ErrorCode2[ErrorCode2["PropertyExpected"] = 513] = "PropertyExpected";
    ErrorCode2[ErrorCode2["CommaExpected"] = 514] = "CommaExpected";
    ErrorCode2[ErrorCode2["ColonExpected"] = 515] = "ColonExpected";
    ErrorCode2[ErrorCode2["ValueExpected"] = 516] = "ValueExpected";
    ErrorCode2[ErrorCode2["CommaOrCloseBacketExpected"] = 517] = "CommaOrCloseBacketExpected";
    ErrorCode2[ErrorCode2["CommaOrCloseBraceExpected"] = 518] = "CommaOrCloseBraceExpected";
    ErrorCode2[ErrorCode2["TrailingComma"] = 519] = "TrailingComma";
    ErrorCode2[ErrorCode2["DuplicateKey"] = 520] = "DuplicateKey";
    ErrorCode2[ErrorCode2["CommentNotPermitted"] = 521] = "CommentNotPermitted";
    ErrorCode2[ErrorCode2["SchemaResolveError"] = 768] = "SchemaResolveError";
  })(ErrorCode || (ErrorCode = {}));
  var ClientCapabilities;
  (function(ClientCapabilities2) {
    ClientCapabilities2.LATEST = {
      textDocument: {
        completion: {
          completionItem: {
            documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText],
            commitCharactersSupport: true
          }
        }
      }
    };
  })(ClientCapabilities || (ClientCapabilities = {}));
  function format4(message, args) {
    return args.length === 0 ? message : message.replace(
      /{(\d+)}/g,
      (match, [index]) => index in args ? args[index] : match
    );
  }
  var localize2 = (key, message, ...args) => format4(message, args);
  function loadMessageBundle() {
    return localize2;
  }
  var __extends = function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var localize22 = loadMessageBundle();
  var formats = {
    "color-hex": { errorMessage: localize22("colorHexFormatWarning", "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA."), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },
    "date-time": { errorMessage: localize22("dateTimeFormatWarning", "String is not a RFC3339 date-time."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
    "date": { errorMessage: localize22("dateFormatWarning", "String is not a RFC3339 date."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },
    "time": { errorMessage: localize22("timeFormatWarning", "String is not a RFC3339 time."), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
    "email": { errorMessage: localize22("emailFormatWarning", "String is not an e-mail address."), pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/ }
  };
  var ASTNodeImpl = (
    /** @class */
    function() {
      function ASTNodeImpl3(parent, offset, length) {
        if (length === void 0) {
          length = 0;
        }
        this.offset = offset;
        this.length = length;
        this.parent = parent;
      }
      Object.defineProperty(ASTNodeImpl3.prototype, "children", {
        get: function() {
          return [];
        },
        enumerable: false,
        configurable: true
      });
      ASTNodeImpl3.prototype.toString = function() {
        return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : "");
      };
      return ASTNodeImpl3;
    }()
  );
  var NullASTNodeImpl = (
    /** @class */
    function(_super) {
      __extends(NullASTNodeImpl3, _super);
      function NullASTNodeImpl3(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = "null";
        _this.value = null;
        return _this;
      }
      return NullASTNodeImpl3;
    }(ASTNodeImpl)
  );
  var BooleanASTNodeImpl = (
    /** @class */
    function(_super) {
      __extends(BooleanASTNodeImpl3, _super);
      function BooleanASTNodeImpl3(parent, boolValue, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = "boolean";
        _this.value = boolValue;
        return _this;
      }
      return BooleanASTNodeImpl3;
    }(ASTNodeImpl)
  );
  var ArrayASTNodeImpl = (
    /** @class */
    function(_super) {
      __extends(ArrayASTNodeImpl3, _super);
      function ArrayASTNodeImpl3(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = "array";
        _this.items = [];
        return _this;
      }
      Object.defineProperty(ArrayASTNodeImpl3.prototype, "children", {
        get: function() {
          return this.items;
        },
        enumerable: false,
        configurable: true
      });
      return ArrayASTNodeImpl3;
    }(ASTNodeImpl)
  );
  var NumberASTNodeImpl = (
    /** @class */
    function(_super) {
      __extends(NumberASTNodeImpl3, _super);
      function NumberASTNodeImpl3(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = "number";
        _this.isInteger = true;
        _this.value = Number.NaN;
        return _this;
      }
      return NumberASTNodeImpl3;
    }(ASTNodeImpl)
  );
  var StringASTNodeImpl = (
    /** @class */
    function(_super) {
      __extends(StringASTNodeImpl3, _super);
      function StringASTNodeImpl3(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = "string";
        _this.value = "";
        return _this;
      }
      return StringASTNodeImpl3;
    }(ASTNodeImpl)
  );
  var PropertyASTNodeImpl = (
    /** @class */
    function(_super) {
      __extends(PropertyASTNodeImpl3, _super);
      function PropertyASTNodeImpl3(parent, offset, keyNode) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = "property";
        _this.colonOffset = -1;
        _this.keyNode = keyNode;
        return _this;
      }
      Object.defineProperty(PropertyASTNodeImpl3.prototype, "children", {
        get: function() {
          return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
        },
        enumerable: false,
        configurable: true
      });
      return PropertyASTNodeImpl3;
    }(ASTNodeImpl)
  );
  var ObjectASTNodeImpl = (
    /** @class */
    function(_super) {
      __extends(ObjectASTNodeImpl3, _super);
      function ObjectASTNodeImpl3(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = "object";
        _this.properties = [];
        return _this;
      }
      Object.defineProperty(ObjectASTNodeImpl3.prototype, "children", {
        get: function() {
          return this.properties;
        },
        enumerable: false,
        configurable: true
      });
      return ObjectASTNodeImpl3;
    }(ASTNodeImpl)
  );
  function asSchema(schema5) {
    if (isBoolean(schema5)) {
      return schema5 ? {} : { "not": {} };
    }
    return schema5;
  }
  var EnumMatch;
  (function(EnumMatch3) {
    EnumMatch3[EnumMatch3["Key"] = 0] = "Key";
    EnumMatch3[EnumMatch3["Enum"] = 1] = "Enum";
  })(EnumMatch || (EnumMatch = {}));
  var SchemaCollector = (
    /** @class */
    function() {
      function SchemaCollector3(focusOffset, exclude) {
        if (focusOffset === void 0) {
          focusOffset = -1;
        }
        this.focusOffset = focusOffset;
        this.exclude = exclude;
        this.schemas = [];
      }
      SchemaCollector3.prototype.add = function(schema5) {
        this.schemas.push(schema5);
      };
      SchemaCollector3.prototype.merge = function(other) {
        Array.prototype.push.apply(this.schemas, other.schemas);
      };
      SchemaCollector3.prototype.include = function(node) {
        return (this.focusOffset === -1 || contains2(node, this.focusOffset)) && node !== this.exclude;
      };
      SchemaCollector3.prototype.newSub = function() {
        return new SchemaCollector3(-1, this.exclude);
      };
      return SchemaCollector3;
    }()
  );
  var NoOpSchemaCollector = (
    /** @class */
    function() {
      function NoOpSchemaCollector3() {
      }
      Object.defineProperty(NoOpSchemaCollector3.prototype, "schemas", {
        get: function() {
          return [];
        },
        enumerable: false,
        configurable: true
      });
      NoOpSchemaCollector3.prototype.add = function(schema5) {
      };
      NoOpSchemaCollector3.prototype.merge = function(other) {
      };
      NoOpSchemaCollector3.prototype.include = function(node) {
        return true;
      };
      NoOpSchemaCollector3.prototype.newSub = function() {
        return this;
      };
      NoOpSchemaCollector3.instance = new NoOpSchemaCollector3();
      return NoOpSchemaCollector3;
    }()
  );
  var ValidationResult = (
    /** @class */
    function() {
      function ValidationResult3() {
        this.problems = [];
        this.propertiesMatches = 0;
        this.propertiesValueMatches = 0;
        this.primaryValueMatches = 0;
        this.enumValueMatch = false;
        this.enumValues = void 0;
      }
      ValidationResult3.prototype.hasProblems = function() {
        return !!this.problems.length;
      };
      ValidationResult3.prototype.mergeAll = function(validationResults) {
        for (var _i = 0, validationResults_1 = validationResults; _i < validationResults_1.length; _i++) {
          var validationResult = validationResults_1[_i];
          this.merge(validationResult);
        }
      };
      ValidationResult3.prototype.merge = function(validationResult) {
        this.problems = this.problems.concat(validationResult.problems);
      };
      ValidationResult3.prototype.mergeEnumValues = function(validationResult) {
        if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
          this.enumValues = this.enumValues.concat(validationResult.enumValues);
          for (var _i = 0, _a3 = this.problems; _i < _a3.length; _i++) {
            var error = _a3[_i];
            if (error.code === ErrorCode.EnumValueMismatch) {
              error.message = localize22("enumWarning", "Value is not accepted. Valid values: {0}.", this.enumValues.map(function(v) {
                return JSON.stringify(v);
              }).join(", "));
            }
          }
        }
      };
      ValidationResult3.prototype.mergePropertyMatch = function(propertyValidationResult) {
        this.merge(propertyValidationResult);
        this.propertiesMatches++;
        if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
          this.propertiesValueMatches++;
        }
        if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {
          this.primaryValueMatches++;
        }
      };
      ValidationResult3.prototype.compare = function(other) {
        var hasProblems = this.hasProblems();
        if (hasProblems !== other.hasProblems()) {
          return hasProblems ? -1 : 1;
        }
        if (this.enumValueMatch !== other.enumValueMatch) {
          return other.enumValueMatch ? -1 : 1;
        }
        if (this.primaryValueMatches !== other.primaryValueMatches) {
          return this.primaryValueMatches - other.primaryValueMatches;
        }
        if (this.propertiesValueMatches !== other.propertiesValueMatches) {
          return this.propertiesValueMatches - other.propertiesValueMatches;
        }
        return this.propertiesMatches - other.propertiesMatches;
      };
      return ValidationResult3;
    }()
  );
  function getNodeValue22(node) {
    return getNodeValue2(node);
  }
  function getNodePath22(node) {
    return getNodePath2(node);
  }
  function contains2(node, offset, includeRightBound) {
    if (includeRightBound === void 0) {
      includeRightBound = false;
    }
    return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
  }
  var JSONDocument = (
    /** @class */
    function() {
      function JSONDocument3(root, syntaxErrors, comments) {
        if (syntaxErrors === void 0) {
          syntaxErrors = [];
        }
        if (comments === void 0) {
          comments = [];
        }
        this.root = root;
        this.syntaxErrors = syntaxErrors;
        this.comments = comments;
      }
      JSONDocument3.prototype.getNodeFromOffset = function(offset, includeRightBound) {
        if (includeRightBound === void 0) {
          includeRightBound = false;
        }
        if (this.root) {
          return findNodeAtOffset2(this.root, offset, includeRightBound);
        }
        return void 0;
      };
      JSONDocument3.prototype.visit = function(visitor) {
        if (this.root) {
          var doVisit_1 = function(node) {
            var ctn = visitor(node);
            var children = node.children;
            if (Array.isArray(children)) {
              for (var i = 0; i < children.length && ctn; i++) {
                ctn = doVisit_1(children[i]);
              }
            }
            return ctn;
          };
          doVisit_1(this.root);
        }
      };
      JSONDocument3.prototype.validate = function(textDocument, schema5, severity) {
        if (severity === void 0) {
          severity = DiagnosticSeverity.Warning;
        }
        if (this.root && schema5) {
          var validationResult = new ValidationResult();
          validate(this.root, schema5, validationResult, NoOpSchemaCollector.instance);
          return validationResult.problems.map(function(p) {
            var _a3;
            var range = Range2.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
            return Diagnostic.create(range, p.message, (_a3 = p.severity) !== null && _a3 !== void 0 ? _a3 : severity, p.code);
          });
        }
        return void 0;
      };
      JSONDocument3.prototype.getMatchingSchemas = function(schema5, focusOffset, exclude) {
        if (focusOffset === void 0) {
          focusOffset = -1;
        }
        var matchingSchemas = new SchemaCollector(focusOffset, exclude);
        if (this.root && schema5) {
          validate(this.root, schema5, new ValidationResult(), matchingSchemas);
        }
        return matchingSchemas.schemas;
      };
      return JSONDocument3;
    }()
  );
  function validate(n, schema5, validationResult, matchingSchemas) {
    if (!n || !matchingSchemas.include(n)) {
      return;
    }
    var node = n;
    switch (node.type) {
      case "object":
        _validateObjectNode(node, schema5, validationResult, matchingSchemas);
        break;
      case "array":
        _validateArrayNode(node, schema5, validationResult, matchingSchemas);
        break;
      case "string":
        _validateStringNode(node, schema5, validationResult, matchingSchemas);
        break;
      case "number":
        _validateNumberNode(node, schema5, validationResult, matchingSchemas);
        break;
      case "property":
        return validate(node.valueNode, schema5, validationResult, matchingSchemas);
    }
    _validateNode();
    matchingSchemas.add({ node, schema: schema5 });
    function _validateNode() {
      function matchesType(type) {
        return node.type === type || type === "integer" && node.type === "number" && node.isInteger;
      }
      if (Array.isArray(schema5.type)) {
        if (!schema5.type.some(matchesType)) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            message: schema5.errorMessage || localize22("typeArrayMismatchWarning", "Incorrect type. Expected one of {0}.", schema5.type.join(", "))
          });
        }
      } else if (schema5.type) {
        if (!matchesType(schema5.type)) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            message: schema5.errorMessage || localize22("typeMismatchWarning", 'Incorrect type. Expected "{0}".', schema5.type)
          });
        }
      }
      if (Array.isArray(schema5.allOf)) {
        for (var _i = 0, _a3 = schema5.allOf; _i < _a3.length; _i++) {
          var subSchemaRef = _a3[_i];
          validate(node, asSchema(subSchemaRef), validationResult, matchingSchemas);
        }
      }
      var notSchema = asSchema(schema5.not);
      if (notSchema) {
        var subValidationResult = new ValidationResult();
        var subMatchingSchemas = matchingSchemas.newSub();
        validate(node, notSchema, subValidationResult, subMatchingSchemas);
        if (!subValidationResult.hasProblems()) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            message: localize22("notSchemaWarning", "Matches a schema that is not allowed.")
          });
        }
        for (var _b = 0, _c = subMatchingSchemas.schemas; _b < _c.length; _b++) {
          var ms = _c[_b];
          ms.inverted = !ms.inverted;
          matchingSchemas.add(ms);
        }
      }
      var testAlternatives = function(alternatives, maxOneMatch) {
        var matches = [];
        var bestMatch = void 0;
        for (var _i2 = 0, alternatives_1 = alternatives; _i2 < alternatives_1.length; _i2++) {
          var subSchemaRef2 = alternatives_1[_i2];
          var subSchema = asSchema(subSchemaRef2);
          var subValidationResult2 = new ValidationResult();
          var subMatchingSchemas2 = matchingSchemas.newSub();
          validate(node, subSchema, subValidationResult2, subMatchingSchemas2);
          if (!subValidationResult2.hasProblems()) {
            matches.push(subSchema);
          }
          if (!bestMatch) {
            bestMatch = { schema: subSchema, validationResult: subValidationResult2, matchingSchemas: subMatchingSchemas2 };
          } else {
            if (!maxOneMatch && !subValidationResult2.hasProblems() && !bestMatch.validationResult.hasProblems()) {
              bestMatch.matchingSchemas.merge(subMatchingSchemas2);
              bestMatch.validationResult.propertiesMatches += subValidationResult2.propertiesMatches;
              bestMatch.validationResult.propertiesValueMatches += subValidationResult2.propertiesValueMatches;
            } else {
              var compareResult = subValidationResult2.compare(bestMatch.validationResult);
              if (compareResult > 0) {
                bestMatch = { schema: subSchema, validationResult: subValidationResult2, matchingSchemas: subMatchingSchemas2 };
              } else if (compareResult === 0) {
                bestMatch.matchingSchemas.merge(subMatchingSchemas2);
                bestMatch.validationResult.mergeEnumValues(subValidationResult2);
              }
            }
          }
        }
        if (matches.length > 1 && maxOneMatch) {
          validationResult.problems.push({
            location: { offset: node.offset, length: 1 },
            message: localize22("oneOfWarning", "Matches multiple schemas when only one must validate.")
          });
        }
        if (bestMatch) {
          validationResult.merge(bestMatch.validationResult);
          validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;
          validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;
          matchingSchemas.merge(bestMatch.matchingSchemas);
        }
        return matches.length;
      };
      if (Array.isArray(schema5.anyOf)) {
        testAlternatives(schema5.anyOf, false);
      }
      if (Array.isArray(schema5.oneOf)) {
        testAlternatives(schema5.oneOf, true);
      }
      var testBranch = function(schema22) {
        var subValidationResult2 = new ValidationResult();
        var subMatchingSchemas2 = matchingSchemas.newSub();
        validate(node, asSchema(schema22), subValidationResult2, subMatchingSchemas2);
        validationResult.merge(subValidationResult2);
        validationResult.propertiesMatches += subValidationResult2.propertiesMatches;
        validationResult.propertiesValueMatches += subValidationResult2.propertiesValueMatches;
        matchingSchemas.merge(subMatchingSchemas2);
      };
      var testCondition = function(ifSchema2, thenSchema, elseSchema) {
        var subSchema = asSchema(ifSchema2);
        var subValidationResult2 = new ValidationResult();
        var subMatchingSchemas2 = matchingSchemas.newSub();
        validate(node, subSchema, subValidationResult2, subMatchingSchemas2);
        matchingSchemas.merge(subMatchingSchemas2);
        if (!subValidationResult2.hasProblems()) {
          if (thenSchema) {
            testBranch(thenSchema);
          }
        } else if (elseSchema) {
          testBranch(elseSchema);
        }
      };
      var ifSchema = asSchema(schema5.if);
      if (ifSchema) {
        testCondition(ifSchema, asSchema(schema5.then), asSchema(schema5.else));
      }
      if (Array.isArray(schema5.enum)) {
        var val = getNodeValue22(node);
        var enumValueMatch = false;
        for (var _d = 0, _e = schema5.enum; _d < _e.length; _d++) {
          var e = _e[_d];
          if (equals2(val, e)) {
            enumValueMatch = true;
            break;
          }
        }
        validationResult.enumValues = schema5.enum;
        validationResult.enumValueMatch = enumValueMatch;
        if (!enumValueMatch) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            code: ErrorCode.EnumValueMismatch,
            message: schema5.errorMessage || localize22("enumWarning", "Value is not accepted. Valid values: {0}.", schema5.enum.map(function(v) {
              return JSON.stringify(v);
            }).join(", "))
          });
        }
      }
      if (isDefined(schema5.const)) {
        var val = getNodeValue22(node);
        if (!equals2(val, schema5.const)) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            code: ErrorCode.EnumValueMismatch,
            message: schema5.errorMessage || localize22("constWarning", "Value must be {0}.", JSON.stringify(schema5.const))
          });
          validationResult.enumValueMatch = false;
        } else {
          validationResult.enumValueMatch = true;
        }
        validationResult.enumValues = [schema5.const];
      }
      if (schema5.deprecationMessage && node.parent) {
        validationResult.problems.push({
          location: { offset: node.parent.offset, length: node.parent.length },
          severity: DiagnosticSeverity.Warning,
          message: schema5.deprecationMessage,
          code: ErrorCode.Deprecated
        });
      }
    }
    function _validateNumberNode(node2, schema22, validationResult2, matchingSchemas2) {
      var val = node2.value;
      function normalizeFloats(float3) {
        var _a3;
        var parts = /^(-?\d+)(?:\.(\d+))?(?:e([-+]\d+))?$/.exec(float3.toString());
        return parts && {
          value: Number(parts[1] + (parts[2] || "")),
          multiplier: (((_a3 = parts[2]) === null || _a3 === void 0 ? void 0 : _a3.length) || 0) - (parseInt(parts[3]) || 0)
        };
      }
      ;
      if (isNumber(schema22.multipleOf)) {
        var remainder = -1;
        if (Number.isInteger(schema22.multipleOf)) {
          remainder = val % schema22.multipleOf;
        } else {
          var normMultipleOf = normalizeFloats(schema22.multipleOf);
          var normValue = normalizeFloats(val);
          if (normMultipleOf && normValue) {
            var multiplier = Math.pow(10, Math.abs(normValue.multiplier - normMultipleOf.multiplier));
            if (normValue.multiplier < normMultipleOf.multiplier) {
              normValue.value *= multiplier;
            } else {
              normMultipleOf.value *= multiplier;
            }
            remainder = normValue.value % normMultipleOf.value;
          }
        }
        if (remainder !== 0) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            message: localize22("multipleOfWarning", "Value is not divisible by {0}.", schema22.multipleOf)
          });
        }
      }
      function getExclusiveLimit(limit, exclusive) {
        if (isNumber(exclusive)) {
          return exclusive;
        }
        if (isBoolean(exclusive) && exclusive) {
          return limit;
        }
        return void 0;
      }
      function getLimit(limit, exclusive) {
        if (!isBoolean(exclusive) || !exclusive) {
          return limit;
        }
        return void 0;
      }
      var exclusiveMinimum = getExclusiveLimit(schema22.minimum, schema22.exclusiveMinimum);
      if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("exclusiveMinimumWarning", "Value is below the exclusive minimum of {0}.", exclusiveMinimum)
        });
      }
      var exclusiveMaximum = getExclusiveLimit(schema22.maximum, schema22.exclusiveMaximum);
      if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("exclusiveMaximumWarning", "Value is above the exclusive maximum of {0}.", exclusiveMaximum)
        });
      }
      var minimum = getLimit(schema22.minimum, schema22.exclusiveMinimum);
      if (isNumber(minimum) && val < minimum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("minimumWarning", "Value is below the minimum of {0}.", minimum)
        });
      }
      var maximum = getLimit(schema22.maximum, schema22.exclusiveMaximum);
      if (isNumber(maximum) && val > maximum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("maximumWarning", "Value is above the maximum of {0}.", maximum)
        });
      }
    }
    function _validateStringNode(node2, schema22, validationResult2, matchingSchemas2) {
      if (isNumber(schema22.minLength) && node2.value.length < schema22.minLength) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("minLengthWarning", "String is shorter than the minimum length of {0}.", schema22.minLength)
        });
      }
      if (isNumber(schema22.maxLength) && node2.value.length > schema22.maxLength) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("maxLengthWarning", "String is longer than the maximum length of {0}.", schema22.maxLength)
        });
      }
      if (isString2(schema22.pattern)) {
        var regex = extendedRegExp(schema22.pattern);
        if (!regex.test(node2.value)) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            message: schema22.patternErrorMessage || schema22.errorMessage || localize22("patternWarning", 'String does not match the pattern of "{0}".', schema22.pattern)
          });
        }
      }
      if (schema22.format) {
        switch (schema22.format) {
          case "uri":
          case "uri-reference":
            {
              var errorMessage = void 0;
              if (!node2.value) {
                errorMessage = localize22("uriEmpty", "URI expected.");
              } else {
                var match = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(node2.value);
                if (!match) {
                  errorMessage = localize22("uriMissing", "URI is expected.");
                } else if (!match[2] && schema22.format === "uri") {
                  errorMessage = localize22("uriSchemeMissing", "URI with a scheme is expected.");
                }
              }
              if (errorMessage) {
                validationResult2.problems.push({
                  location: { offset: node2.offset, length: node2.length },
                  message: schema22.patternErrorMessage || schema22.errorMessage || localize22("uriFormatWarning", "String is not a URI: {0}", errorMessage)
                });
              }
            }
            break;
          case "color-hex":
          case "date-time":
          case "date":
          case "time":
          case "email":
            var format32 = formats[schema22.format];
            if (!node2.value || !format32.pattern.exec(node2.value)) {
              validationResult2.problems.push({
                location: { offset: node2.offset, length: node2.length },
                message: schema22.patternErrorMessage || schema22.errorMessage || format32.errorMessage
              });
            }
          default:
        }
      }
    }
    function _validateArrayNode(node2, schema22, validationResult2, matchingSchemas2) {
      if (Array.isArray(schema22.items)) {
        var subSchemas = schema22.items;
        for (var index = 0; index < subSchemas.length; index++) {
          var subSchemaRef = subSchemas[index];
          var subSchema = asSchema(subSchemaRef);
          var itemValidationResult = new ValidationResult();
          var item = node2.items[index];
          if (item) {
            validate(item, subSchema, itemValidationResult, matchingSchemas2);
            validationResult2.mergePropertyMatch(itemValidationResult);
          } else if (node2.items.length >= subSchemas.length) {
            validationResult2.propertiesValueMatches++;
          }
        }
        if (node2.items.length > subSchemas.length) {
          if (typeof schema22.additionalItems === "object") {
            for (var i = subSchemas.length; i < node2.items.length; i++) {
              var itemValidationResult = new ValidationResult();
              validate(node2.items[i], schema22.additionalItems, itemValidationResult, matchingSchemas2);
              validationResult2.mergePropertyMatch(itemValidationResult);
            }
          } else if (schema22.additionalItems === false) {
            validationResult2.problems.push({
              location: { offset: node2.offset, length: node2.length },
              message: localize22("additionalItemsWarning", "Array has too many items according to schema. Expected {0} or fewer.", subSchemas.length)
            });
          }
        }
      } else {
        var itemSchema = asSchema(schema22.items);
        if (itemSchema) {
          for (var _i = 0, _a3 = node2.items; _i < _a3.length; _i++) {
            var item = _a3[_i];
            var itemValidationResult = new ValidationResult();
            validate(item, itemSchema, itemValidationResult, matchingSchemas2);
            validationResult2.mergePropertyMatch(itemValidationResult);
          }
        }
      }
      var containsSchema = asSchema(schema22.contains);
      if (containsSchema) {
        var doesContain = node2.items.some(function(item2) {
          var itemValidationResult2 = new ValidationResult();
          validate(item2, containsSchema, itemValidationResult2, NoOpSchemaCollector.instance);
          return !itemValidationResult2.hasProblems();
        });
        if (!doesContain) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            message: schema22.errorMessage || localize22("requiredItemMissingWarning", "Array does not contain required item.")
          });
        }
      }
      if (isNumber(schema22.minItems) && node2.items.length < schema22.minItems) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("minItemsWarning", "Array has too few items. Expected {0} or more.", schema22.minItems)
        });
      }
      if (isNumber(schema22.maxItems) && node2.items.length > schema22.maxItems) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          message: localize22("maxItemsWarning", "Array has too many items. Expected {0} or fewer.", schema22.maxItems)
        });
      }
      if (schema22.uniqueItems === true) {
        var values_1 = getNodeValue22(node2);
        var duplicates = values_1.some(function(value, index2) {
          return index2 !== values_1.lastIndexOf(value);
        });
        if (duplicates) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            message: localize22("uniqueItemsWarning", "Array has duplicate items.")
          });
        }
      }
    }
    function _validateObjectNode(node2, schema22, validationResult2, matchingSchemas2) {
      var seenKeys = /* @__PURE__ */ Object.create(null);
      var unprocessedProperties = [];
      for (var _i = 0, _a3 = node2.properties; _i < _a3.length; _i++) {
        var propertyNode = _a3[_i];
        var key = propertyNode.keyNode.value;
        seenKeys[key] = propertyNode.valueNode;
        unprocessedProperties.push(key);
      }
      if (Array.isArray(schema22.required)) {
        for (var _b = 0, _c = schema22.required; _b < _c.length; _b++) {
          var propertyName = _c[_b];
          if (!seenKeys[propertyName]) {
            var keyNode = node2.parent && node2.parent.type === "property" && node2.parent.keyNode;
            var location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node2.offset, length: 1 };
            validationResult2.problems.push({
              location,
              message: localize22("MissingRequiredPropWarning", 'Missing property "{0}".', propertyName)
            });
          }
        }
      }
      var propertyProcessed = function(prop2) {
        var index = unprocessedProperties.indexOf(prop2);
        while (index >= 0) {
          unprocessedProperties.splice(index, 1);
          index = unprocessedProperties.indexOf(prop2);
        }
      };
      if (schema22.properties) {
        for (var _d = 0, _e = Object.keys(schema22.properties); _d < _e.length; _d++) {
          var propertyName = _e[_d];
          propertyProcessed(propertyName);
          var propertySchema = schema22.properties[propertyName];
          var child = seenKeys[propertyName];
          if (child) {
            if (isBoolean(propertySchema)) {
              if (!propertySchema) {
                var propertyNode = child.parent;
                validationResult2.problems.push({
                  location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                  message: schema22.errorMessage || localize22("DisallowedExtraPropWarning", "Property {0} is not allowed.", propertyName)
                });
              } else {
                validationResult2.propertiesMatches++;
                validationResult2.propertiesValueMatches++;
              }
            } else {
              var propertyValidationResult = new ValidationResult();
              validate(child, propertySchema, propertyValidationResult, matchingSchemas2);
              validationResult2.mergePropertyMatch(propertyValidationResult);
            }
          }
        }
      }
      if (schema22.patternProperties) {
        for (var _f = 0, _g = Object.keys(schema22.patternProperties); _f < _g.length; _f++) {
          var propertyPattern = _g[_f];
          var regex = extendedRegExp(propertyPattern);
          for (var _h = 0, _j = unprocessedProperties.slice(0); _h < _j.length; _h++) {
            var propertyName = _j[_h];
            if (regex.test(propertyName)) {
              propertyProcessed(propertyName);
              var child = seenKeys[propertyName];
              if (child) {
                var propertySchema = schema22.patternProperties[propertyPattern];
                if (isBoolean(propertySchema)) {
                  if (!propertySchema) {
                    var propertyNode = child.parent;
                    validationResult2.problems.push({
                      location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                      message: schema22.errorMessage || localize22("DisallowedExtraPropWarning", "Property {0} is not allowed.", propertyName)
                    });
                  } else {
                    validationResult2.propertiesMatches++;
                    validationResult2.propertiesValueMatches++;
                  }
                } else {
                  var propertyValidationResult = new ValidationResult();
                  validate(child, propertySchema, propertyValidationResult, matchingSchemas2);
                  validationResult2.mergePropertyMatch(propertyValidationResult);
                }
              }
            }
          }
        }
      }
      if (typeof schema22.additionalProperties === "object") {
        for (var _k = 0, unprocessedProperties_1 = unprocessedProperties; _k < unprocessedProperties_1.length; _k++) {
          var propertyName = unprocessedProperties_1[_k];
          var child = seenKeys[propertyName];
          if (child) {
            var propertyValidationResult = new ValidationResult();
            validate(child, schema22.additionalProperties, propertyValidationResult, matchingSchemas2);
            validationResult2.mergePropertyMatch(propertyValidationResult);
          }
        }
      } else if (schema22.additionalProperties === false) {
        if (unprocessedProperties.length > 0) {
          for (var _l = 0, unprocessedProperties_2 = unprocessedProperties; _l < unprocessedProperties_2.length; _l++) {
            var propertyName = unprocessedProperties_2[_l];
            var child = seenKeys[propertyName];
            if (child) {
              var propertyNode = child.parent;
              validationResult2.problems.push({
                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                message: schema22.errorMessage || localize22("DisallowedExtraPropWarning", "Property {0} is not allowed.", propertyName)
              });
            }
          }
        }
      }
      if (isNumber(schema22.maxProperties)) {
        if (node2.properties.length > schema22.maxProperties) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            message: localize22("MaxPropWarning", "Object has more properties than limit of {0}.", schema22.maxProperties)
          });
        }
      }
      if (isNumber(schema22.minProperties)) {
        if (node2.properties.length < schema22.minProperties) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            message: localize22("MinPropWarning", "Object has fewer properties than the required number of {0}", schema22.minProperties)
          });
        }
      }
      if (schema22.dependencies) {
        for (var _m = 0, _o = Object.keys(schema22.dependencies); _m < _o.length; _m++) {
          var key = _o[_m];
          var prop = seenKeys[key];
          if (prop) {
            var propertyDep = schema22.dependencies[key];
            if (Array.isArray(propertyDep)) {
              for (var _p = 0, propertyDep_1 = propertyDep; _p < propertyDep_1.length; _p++) {
                var requiredProp = propertyDep_1[_p];
                if (!seenKeys[requiredProp]) {
                  validationResult2.problems.push({
                    location: { offset: node2.offset, length: node2.length },
                    message: localize22("RequiredDependentPropWarning", "Object is missing property {0} required by property {1}.", requiredProp, key)
                  });
                } else {
                  validationResult2.propertiesValueMatches++;
                }
              }
            } else {
              var propertySchema = asSchema(propertyDep);
              if (propertySchema) {
                var propertyValidationResult = new ValidationResult();
                validate(node2, propertySchema, propertyValidationResult, matchingSchemas2);
                validationResult2.mergePropertyMatch(propertyValidationResult);
              }
            }
          }
        }
      }
      var propertyNames = asSchema(schema22.propertyNames);
      if (propertyNames) {
        for (var _q = 0, _r = node2.properties; _q < _r.length; _q++) {
          var f2 = _r[_q];
          var key = f2.keyNode;
          if (key) {
            validate(key, propertyNames, validationResult2, NoOpSchemaCollector.instance);
          }
        }
      }
    }
  }
  function createRegex(glob, opts) {
    if (typeof glob !== "string") {
      throw new TypeError("Expected a string");
    }
    var str = String(glob);
    var reStr = "";
    var extended = opts ? !!opts.extended : false;
    var globstar = opts ? !!opts.globstar : false;
    var inGroup = false;
    var flags = opts && typeof opts.flags === "string" ? opts.flags : "";
    var c;
    for (var i = 0, len = str.length; i < len; i++) {
      c = str[i];
      switch (c) {
        case "/":
        case "$":
        case "^":
        case "+":
        case ".":
        case "(":
        case ")":
        case "=":
        case "!":
        case "|":
          reStr += "\\" + c;
          break;
        case "?":
          if (extended) {
            reStr += ".";
            break;
          }
        case "[":
        case "]":
          if (extended) {
            reStr += c;
            break;
          }
        case "{":
          if (extended) {
            inGroup = true;
            reStr += "(";
            break;
          }
        case "}":
          if (extended) {
            inGroup = false;
            reStr += ")";
            break;
          }
        case ",":
          if (inGroup) {
            reStr += "|";
            break;
          }
          reStr += "\\" + c;
          break;
        case "*":
          var prevChar = str[i - 1];
          var starCount = 1;
          while (str[i + 1] === "*") {
            starCount++;
            i++;
          }
          var nextChar = str[i + 1];
          if (!globstar) {
            reStr += ".*";
          } else {
            var isGlobstar = starCount > 1 && (prevChar === "/" || prevChar === void 0 || prevChar === "{" || prevChar === ",") && (nextChar === "/" || nextChar === void 0 || nextChar === "," || nextChar === "}");
            if (isGlobstar) {
              if (nextChar === "/") {
                i++;
              } else if (prevChar === "/" && reStr.endsWith("\\/")) {
                reStr = reStr.substr(0, reStr.length - 2);
              }
              reStr += "((?:[^/]*(?:/|$))*)";
            } else {
              reStr += "([^/]*)";
            }
          }
          break;
        default:
          reStr += c;
      }
    }
    if (!flags || !~flags.indexOf("g")) {
      reStr = "^" + reStr + "$";
    }
    return new RegExp(reStr, flags);
  }
  var localize3 = loadMessageBundle();
  var BANG = "!";
  var PATH_SEP = "/";
  var FilePatternAssociation = (
    /** @class */
    function() {
      function FilePatternAssociation3(pattern, uris) {
        this.globWrappers = [];
        try {
          for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {
            var patternString = pattern_1[_i];
            var include = patternString[0] !== BANG;
            if (!include) {
              patternString = patternString.substring(1);
            }
            if (patternString.length > 0) {
              if (patternString[0] === PATH_SEP) {
                patternString = patternString.substring(1);
              }
              this.globWrappers.push({
                regexp: createRegex("**/" + patternString, { extended: true, globstar: true }),
                include
              });
            }
          }
          ;
          this.uris = uris;
        } catch (e) {
          this.globWrappers.length = 0;
          this.uris = [];
        }
      }
      FilePatternAssociation3.prototype.matchesPattern = function(fileName) {
        var match = false;
        for (var _i = 0, _a3 = this.globWrappers; _i < _a3.length; _i++) {
          var _b = _a3[_i], regexp = _b.regexp, include = _b.include;
          if (regexp.test(fileName)) {
            match = include;
          }
        }
        return match;
      };
      FilePatternAssociation3.prototype.getURIs = function() {
        return this.uris;
      };
      return FilePatternAssociation3;
    }()
  );
  var SchemaHandle = (
    /** @class */
    function() {
      function SchemaHandle2(service, url, unresolvedSchemaContent) {
        this.service = service;
        this.url = url;
        this.dependencies = {};
        if (unresolvedSchemaContent) {
          this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));
        }
      }
      SchemaHandle2.prototype.getUnresolvedSchema = function() {
        if (!this.unresolvedSchema) {
          this.unresolvedSchema = this.service.loadSchema(this.url);
        }
        return this.unresolvedSchema;
      };
      SchemaHandle2.prototype.getResolvedSchema = function() {
        var _this = this;
        if (!this.resolvedSchema) {
          this.resolvedSchema = this.getUnresolvedSchema().then(function(unresolved) {
            return _this.service.resolveSchemaContent(unresolved, _this.url, _this.dependencies);
          });
        }
        return this.resolvedSchema;
      };
      SchemaHandle2.prototype.clearSchema = function() {
        this.resolvedSchema = void 0;
        this.unresolvedSchema = void 0;
        this.dependencies = {};
      };
      return SchemaHandle2;
    }()
  );
  var UnresolvedSchema = (
    /** @class */
    function() {
      function UnresolvedSchema2(schema5, errors) {
        if (errors === void 0) {
          errors = [];
        }
        this.schema = schema5;
        this.errors = errors;
      }
      return UnresolvedSchema2;
    }()
  );
  var ResolvedSchema = (
    /** @class */
    function() {
      function ResolvedSchema2(schema5, errors) {
        if (errors === void 0) {
          errors = [];
        }
        this.schema = schema5;
        this.errors = errors;
      }
      ResolvedSchema2.prototype.getSection = function(path5) {
        var schemaRef = this.getSectionRecursive(path5, this.schema);
        if (schemaRef) {
          return asSchema(schemaRef);
        }
        return void 0;
      };
      ResolvedSchema2.prototype.getSectionRecursive = function(path5, schema5) {
        if (!schema5 || typeof schema5 === "boolean" || path5.length === 0) {
          return schema5;
        }
        var next = path5.shift();
        if (schema5.properties && typeof schema5.properties[next]) {
          return this.getSectionRecursive(path5, schema5.properties[next]);
        } else if (schema5.patternProperties) {
          for (var _i = 0, _a3 = Object.keys(schema5.patternProperties); _i < _a3.length; _i++) {
            var pattern = _a3[_i];
            var regex = extendedRegExp(pattern);
            if (regex.test(next)) {
              return this.getSectionRecursive(path5, schema5.patternProperties[pattern]);
            }
          }
        } else if (typeof schema5.additionalProperties === "object") {
          return this.getSectionRecursive(path5, schema5.additionalProperties);
        } else if (next.match("[0-9]+")) {
          if (Array.isArray(schema5.items)) {
            var index = parseInt(next, 10);
            if (!isNaN(index) && schema5.items[index]) {
              return this.getSectionRecursive(path5, schema5.items[index]);
            }
          } else if (schema5.items) {
            return this.getSectionRecursive(path5, schema5.items);
          }
        }
        return void 0;
      };
      return ResolvedSchema2;
    }()
  );
  var JSONSchemaService = (
    /** @class */
    function() {
      function JSONSchemaService2(requestService, contextService, promiseConstructor) {
        this.contextService = contextService;
        this.requestService = requestService;
        this.promiseConstructor = promiseConstructor || Promise;
        this.callOnDispose = [];
        this.contributionSchemas = {};
        this.contributionAssociations = [];
        this.schemasById = {};
        this.filePatternAssociations = [];
        this.registeredSchemasIds = {};
      }
      JSONSchemaService2.prototype.getRegisteredSchemaIds = function(filter) {
        return Object.keys(this.registeredSchemasIds).filter(function(id) {
          var scheme = URI2.parse(id).scheme;
          return scheme !== "schemaservice" && (!filter || filter(scheme));
        });
      };
      Object.defineProperty(JSONSchemaService2.prototype, "promise", {
        get: function() {
          return this.promiseConstructor;
        },
        enumerable: false,
        configurable: true
      });
      JSONSchemaService2.prototype.dispose = function() {
        while (this.callOnDispose.length > 0) {
          this.callOnDispose.pop()();
        }
      };
      JSONSchemaService2.prototype.onResourceChange = function(uri) {
        var _this = this;
        this.cachedSchemaForResource = void 0;
        var hasChanges = false;
        uri = normalizeId(uri);
        var toWalk = [uri];
        var all = Object.keys(this.schemasById).map(function(key) {
          return _this.schemasById[key];
        });
        while (toWalk.length) {
          var curr = toWalk.pop();
          for (var i = 0; i < all.length; i++) {
            var handle = all[i];
            if (handle && (handle.url === curr || handle.dependencies[curr])) {
              if (handle.url !== curr) {
                toWalk.push(handle.url);
              }
              handle.clearSchema();
              all[i] = void 0;
              hasChanges = true;
            }
          }
        }
        return hasChanges;
      };
      JSONSchemaService2.prototype.setSchemaContributions = function(schemaContributions2) {
        if (schemaContributions2.schemas) {
          var schemas2 = schemaContributions2.schemas;
          for (var id in schemas2) {
            var normalizedId = normalizeId(id);
            this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas2[id]);
          }
        }
        if (Array.isArray(schemaContributions2.schemaAssociations)) {
          var schemaAssociations = schemaContributions2.schemaAssociations;
          for (var _i = 0, schemaAssociations_1 = schemaAssociations; _i < schemaAssociations_1.length; _i++) {
            var schemaAssociation = schemaAssociations_1[_i];
            var uris = schemaAssociation.uris.map(normalizeId);
            var association = this.addFilePatternAssociation(schemaAssociation.pattern, uris);
            this.contributionAssociations.push(association);
          }
        }
      };
      JSONSchemaService2.prototype.addSchemaHandle = function(id, unresolvedSchemaContent) {
        var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);
        this.schemasById[id] = schemaHandle;
        return schemaHandle;
      };
      JSONSchemaService2.prototype.getOrAddSchemaHandle = function(id, unresolvedSchemaContent) {
        return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);
      };
      JSONSchemaService2.prototype.addFilePatternAssociation = function(pattern, uris) {
        var fpa = new FilePatternAssociation(pattern, uris);
        this.filePatternAssociations.push(fpa);
        return fpa;
      };
      JSONSchemaService2.prototype.registerExternalSchema = function(uri, filePatterns, unresolvedSchemaContent) {
        var id = normalizeId(uri);
        this.registeredSchemasIds[id] = true;
        this.cachedSchemaForResource = void 0;
        if (filePatterns) {
          this.addFilePatternAssociation(filePatterns, [uri]);
        }
        return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);
      };
      JSONSchemaService2.prototype.clearExternalSchemas = function() {
        this.schemasById = {};
        this.filePatternAssociations = [];
        this.registeredSchemasIds = {};
        this.cachedSchemaForResource = void 0;
        for (var id in this.contributionSchemas) {
          this.schemasById[id] = this.contributionSchemas[id];
          this.registeredSchemasIds[id] = true;
        }
        for (var _i = 0, _a3 = this.contributionAssociations; _i < _a3.length; _i++) {
          var contributionAssociation = _a3[_i];
          this.filePatternAssociations.push(contributionAssociation);
        }
      };
      JSONSchemaService2.prototype.getResolvedSchema = function(schemaId) {
        var id = normalizeId(schemaId);
        var schemaHandle = this.schemasById[id];
        if (schemaHandle) {
          return schemaHandle.getResolvedSchema();
        }
        return this.promise.resolve(void 0);
      };
      JSONSchemaService2.prototype.loadSchema = function(url) {
        if (!this.requestService) {
          var errorMessage = localize3("json.schema.norequestservice", "Unable to load schema from '{0}'. No schema request service available", toDisplayString(url));
          return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));
        }
        return this.requestService(url).then(function(content) {
          if (!content) {
            var errorMessage2 = localize3("json.schema.nocontent", "Unable to load schema from '{0}': No content.", toDisplayString(url));
            return new UnresolvedSchema({}, [errorMessage2]);
          }
          var schemaContent = {};
          var jsonErrors = [];
          schemaContent = parse2(content, jsonErrors);
          var errors = jsonErrors.length ? [localize3("json.schema.invalidFormat", "Unable to parse content from '{0}': Parse error at offset {1}.", toDisplayString(url), jsonErrors[0].offset)] : [];
          return new UnresolvedSchema(schemaContent, errors);
        }, function(error) {
          var errorMessage2 = error.toString();
          var errorSplit = error.toString().split("Error: ");
          if (errorSplit.length > 1) {
            errorMessage2 = errorSplit[1];
          }
          if (endsWith(errorMessage2, ".")) {
            errorMessage2 = errorMessage2.substr(0, errorMessage2.length - 1);
          }
          return new UnresolvedSchema({}, [localize3("json.schema.nocontent", "Unable to load schema from '{0}': {1}.", toDisplayString(url), errorMessage2)]);
        });
      };
      JSONSchemaService2.prototype.resolveSchemaContent = function(schemaToResolve, schemaURL, dependencies) {
        var _this = this;
        var resolveErrors = schemaToResolve.errors.slice(0);
        var schema5 = schemaToResolve.schema;
        if (schema5.$schema) {
          var id = normalizeId(schema5.$schema);
          if (id === "http://json-schema.org/draft-03/schema") {
            return this.promise.resolve(new ResolvedSchema({}, [localize3("json.schema.draft03.notsupported", "Draft-03 schemas are not supported.")]));
          } else if (id === "https://json-schema.org/draft/2019-09/schema") {
            resolveErrors.push(localize3("json.schema.draft201909.notsupported", "Draft 2019-09 schemas are not yet fully supported."));
          }
        }
        var contextService = this.contextService;
        var findSection = function(schema22, path5) {
          if (!path5) {
            return schema22;
          }
          var current = schema22;
          if (path5[0] === "/") {
            path5 = path5.substr(1);
          }
          path5.split("/").some(function(part) {
            part = part.replace(/~1/g, "/").replace(/~0/g, "~");
            current = current[part];
            return !current;
          });
          return current;
        };
        var merge = function(target, sourceRoot, sourceURI, refSegment) {
          var path5 = refSegment ? decodeURIComponent(refSegment) : void 0;
          var section = findSection(sourceRoot, path5);
          if (section) {
            for (var key in section) {
              if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                target[key] = section[key];
              }
            }
          } else {
            resolveErrors.push(localize3("json.schema.invalidref", "$ref '{0}' in '{1}' can not be resolved.", path5, sourceURI));
          }
        };
        var resolveExternalLink = function(node, uri, refSegment, parentSchemaURL, parentSchemaDependencies) {
          if (contextService && !/^[A-Za-z][A-Za-z0-9+\-.+]*:\/\/.*/.test(uri)) {
            uri = contextService.resolveRelativePath(uri, parentSchemaURL);
          }
          uri = normalizeId(uri);
          var referencedHandle = _this.getOrAddSchemaHandle(uri);
          return referencedHandle.getUnresolvedSchema().then(function(unresolvedSchema) {
            parentSchemaDependencies[uri] = true;
            if (unresolvedSchema.errors.length) {
              var loc = refSegment ? uri + "#" + refSegment : uri;
              resolveErrors.push(localize3("json.schema.problemloadingref", "Problems loading reference '{0}': {1}", loc, unresolvedSchema.errors[0]));
            }
            merge(node, unresolvedSchema.schema, uri, refSegment);
            return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);
          });
        };
        var resolveRefs = function(node, parentSchema, parentSchemaURL, parentSchemaDependencies) {
          if (!node || typeof node !== "object") {
            return Promise.resolve(null);
          }
          var toWalk = [node];
          var seen = [];
          var openPromises = [];
          var collectEntries = function() {
            var entries = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              entries[_i] = arguments[_i];
            }
            for (var _a3 = 0, entries_1 = entries; _a3 < entries_1.length; _a3++) {
              var entry = entries_1[_a3];
              if (typeof entry === "object") {
                toWalk.push(entry);
              }
            }
          };
          var collectMapEntries = function() {
            var maps = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              maps[_i] = arguments[_i];
            }
            for (var _a3 = 0, maps_1 = maps; _a3 < maps_1.length; _a3++) {
              var map2 = maps_1[_a3];
              if (typeof map2 === "object") {
                for (var k in map2) {
                  var key = k;
                  var entry = map2[key];
                  if (typeof entry === "object") {
                    toWalk.push(entry);
                  }
                }
              }
            }
          };
          var collectArrayEntries = function() {
            var arrays = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              arrays[_i] = arguments[_i];
            }
            for (var _a3 = 0, arrays_1 = arrays; _a3 < arrays_1.length; _a3++) {
              var array = arrays_1[_a3];
              if (Array.isArray(array)) {
                for (var _b = 0, array_1 = array; _b < array_1.length; _b++) {
                  var entry = array_1[_b];
                  if (typeof entry === "object") {
                    toWalk.push(entry);
                  }
                }
              }
            }
          };
          var handleRef = function(next2) {
            var seenRefs = [];
            while (next2.$ref) {
              var ref = next2.$ref;
              var segments = ref.split("#", 2);
              delete next2.$ref;
              if (segments[0].length > 0) {
                openPromises.push(resolveExternalLink(next2, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));
                return;
              } else {
                if (seenRefs.indexOf(ref) === -1) {
                  merge(next2, parentSchema, parentSchemaURL, segments[1]);
                  seenRefs.push(ref);
                }
              }
            }
            collectEntries(next2.items, next2.additionalItems, next2.additionalProperties, next2.not, next2.contains, next2.propertyNames, next2.if, next2.then, next2.else);
            collectMapEntries(next2.definitions, next2.properties, next2.patternProperties, next2.dependencies);
            collectArrayEntries(next2.anyOf, next2.allOf, next2.oneOf, next2.items);
          };
          while (toWalk.length) {
            var next = toWalk.pop();
            if (seen.indexOf(next) >= 0) {
              continue;
            }
            seen.push(next);
            handleRef(next);
          }
          return _this.promise.all(openPromises);
        };
        return resolveRefs(schema5, schema5, schemaURL, dependencies).then(function(_) {
          return new ResolvedSchema(schema5, resolveErrors);
        });
      };
      JSONSchemaService2.prototype.getSchemaForResource = function(resource, document2) {
        if (document2 && document2.root && document2.root.type === "object") {
          var schemaProperties = document2.root.properties.filter(function(p) {
            return p.keyNode.value === "$schema" && p.valueNode && p.valueNode.type === "string";
          });
          if (schemaProperties.length > 0) {
            var valueNode = schemaProperties[0].valueNode;
            if (valueNode && valueNode.type === "string") {
              var schemeId = getNodeValue22(valueNode);
              if (schemeId && startsWith(schemeId, ".") && this.contextService) {
                schemeId = this.contextService.resolveRelativePath(schemeId, resource);
              }
              if (schemeId) {
                var id = normalizeId(schemeId);
                return this.getOrAddSchemaHandle(id).getResolvedSchema();
              }
            }
          }
        }
        if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {
          return this.cachedSchemaForResource.resolvedSchema;
        }
        var seen = /* @__PURE__ */ Object.create(null);
        var schemas2 = [];
        var normalizedResource = normalizeResourceForMatching(resource);
        for (var _i = 0, _a3 = this.filePatternAssociations; _i < _a3.length; _i++) {
          var entry = _a3[_i];
          if (entry.matchesPattern(normalizedResource)) {
            for (var _b = 0, _c = entry.getURIs(); _b < _c.length; _b++) {
              var schemaId = _c[_b];
              if (!seen[schemaId]) {
                schemas2.push(schemaId);
                seen[schemaId] = true;
              }
            }
          }
        }
        var resolvedSchema = schemas2.length > 0 ? this.createCombinedSchema(resource, schemas2).getResolvedSchema() : this.promise.resolve(void 0);
        this.cachedSchemaForResource = { resource, resolvedSchema };
        return resolvedSchema;
      };
      JSONSchemaService2.prototype.createCombinedSchema = function(resource, schemaIds) {
        if (schemaIds.length === 1) {
          return this.getOrAddSchemaHandle(schemaIds[0]);
        } else {
          var combinedSchemaId = "schemaservice://combinedSchema/" + encodeURIComponent(resource);
          var combinedSchema = {
            allOf: schemaIds.map(function(schemaId) {
              return { $ref: schemaId };
            })
          };
          return this.addSchemaHandle(combinedSchemaId, combinedSchema);
        }
      };
      JSONSchemaService2.prototype.getMatchingSchemas = function(document2, jsonDocument, schema5) {
        if (schema5) {
          var id = schema5.id || "schemaservice://untitled/matchingSchemas/" + idCounter++;
          return this.resolveSchemaContent(new UnresolvedSchema(schema5), id, {}).then(function(resolvedSchema) {
            return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter(function(s) {
              return !s.inverted;
            });
          });
        }
        return this.getSchemaForResource(document2.uri, jsonDocument).then(function(schema22) {
          if (schema22) {
            return jsonDocument.getMatchingSchemas(schema22.schema).filter(function(s) {
              return !s.inverted;
            });
          }
          return [];
        });
      };
      return JSONSchemaService2;
    }()
  );
  var idCounter = 0;
  function normalizeId(id) {
    try {
      return URI2.parse(id).toString();
    } catch (e) {
      return id;
    }
  }
  function normalizeResourceForMatching(resource) {
    try {
      return URI2.parse(resource).with({ fragment: null, query: null }).toString();
    } catch (e) {
      return resource;
    }
  }
  function toDisplayString(url) {
    try {
      var uri = URI2.parse(url);
      if (uri.scheme === "file") {
        return uri.fsPath;
      }
    } catch (e) {
    }
    return url;
  }
  function convertSimple2RegExpPattern(pattern) {
    return pattern.replace(/[-\\{}+?|^$.,[\]()#\s]/g, "\\$&").replace(/[*]/g, ".*");
  }
  function getIndentation2(lineContent, position) {
    if (lineContent.length < position) {
      return 0;
    }
    for (let i = 0; i < position; i++) {
      const char = lineContent.charCodeAt(i);
      if (char !== 32 && char !== 9) {
        return i;
      }
    }
    return position;
  }
  function safeCreateUnicodeRegExp(pattern) {
    try {
      return new RegExp(pattern, "u");
    } catch (ignore) {
      return new RegExp(pattern);
    }
  }
  function getFirstNonWhitespaceCharacterAfterOffset(str, offset) {
    offset++;
    for (let i = offset; i < str.length; i++) {
      const char = str.charAt(i);
      if (char === " " || char === "	") {
        offset++;
      } else {
        return offset;
      }
    }
    return offset;
  }
  function equals22(one, other) {
    if (one === other) {
      return true;
    }
    if (one === null || one === void 0 || other === null || other === void 0) {
      return false;
    }
    if (typeof one !== typeof other) {
      return false;
    }
    if (typeof one !== "object") {
      return false;
    }
    if (Array.isArray(one) !== Array.isArray(other)) {
      return false;
    }
    let i, key;
    if (Array.isArray(one)) {
      if (one.length !== other.length) {
        return false;
      }
      for (i = 0; i < one.length; i++) {
        if (!equals22(one[i], other[i])) {
          return false;
        }
      }
    } else {
      const oneKeys = [];
      for (key in one) {
        oneKeys.push(key);
      }
      oneKeys.sort();
      const otherKeys = [];
      for (key in other) {
        otherKeys.push(key);
      }
      otherKeys.sort();
      if (!equals22(oneKeys, otherKeys)) {
        return false;
      }
      for (i = 0; i < oneKeys.length; i++) {
        if (!equals22(one[oneKeys[i]], other[oneKeys[i]])) {
          return false;
        }
      }
    }
    return true;
  }
  function isNumber2(val) {
    return typeof val === "number";
  }
  function isDefined2(val) {
    return typeof val !== "undefined";
  }
  function isBoolean2(val) {
    return typeof val === "boolean";
  }
  function isString22(val) {
    return typeof val === "string";
  }
  function isIterable(val) {
    return Symbol.iterator in Object(val);
  }
  function convertErrorToTelemetryMsg(err) {
    var _a3;
    if (!err)
      return "null";
    if (err instanceof Error) {
      return (_a3 = err.stack) != null ? _a3 : err.toString();
    }
    return err.toString();
  }
  function getSchemaTypeName(schema5) {
    if (schema5.title) {
      return schema5.title;
    }
    if (schema5.$id) {
      return getSchemaRefTypeTitle(schema5.$id);
    }
    if (schema5.$ref || schema5._$ref) {
      return getSchemaRefTypeTitle(schema5.$ref || schema5._$ref);
    }
    return schema5.closestTitle || (Array.isArray(schema5.type) ? schema5.type.join(" | ") : schema5.type);
  }
  function getSchemaRefTypeTitle($ref) {
    const match = $ref.match(/^(?:.*\/)?(.*?)(?:\.schema\.json)?$/);
    let type = !!match && match[1];
    if (!type) {
      type = "typeNotFound";
      console.error(`$ref (${$ref}) not parsed properly`);
    }
    return type;
  }
  function getSchemaTitle(schema5, url) {
    const uri = URI2.parse(url);
    let baseName = path.basename(uri.fsPath);
    if (!path.extname(uri.fsPath)) {
      baseName += ".json";
    }
    if (Object.getOwnPropertyDescriptor(schema5, "name")) {
      return Object.getOwnPropertyDescriptor(schema5, "name").value + ` (${baseName})`;
    } else if (schema5.title) {
      return schema5.description ? schema5.title + " - " + schema5.description + ` (${baseName})` : schema5.title + ` (${baseName})`;
    }
    return baseName;
  }
  function isPrimitiveType(schema5) {
    return schema5.type !== "object" && !isAnyOfAllOfOneOfType(schema5);
  }
  function isAnyOfAllOfOneOfType(schema5) {
    return !!(schema5.anyOf || schema5.allOf || schema5.oneOf);
  }
  function stringifyObject(obj, indent, stringifyLiteral) {
    if (obj !== null && typeof obj === "object") {
      var newIndent = indent + "	";
      if (Array.isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var result = "[\n";
        for (var i = 0; i < obj.length; i++) {
          result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);
          if (i < obj.length - 1) {
            result += ",";
          }
          result += "\n";
        }
        result += indent + "]";
        return result;
      } else {
        var keys = Object.keys(obj);
        if (keys.length === 0) {
          return "{}";
        }
        var result = "{\n";
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          result += newIndent + JSON.stringify(key) + ": " + stringifyObject(obj[key], newIndent, stringifyLiteral);
          if (i < keys.length - 1) {
            result += ",";
          }
          result += "\n";
        }
        result += indent + "}";
        return result;
      }
    }
    return stringifyLiteral(obj);
  }
  var localize4 = loadMessageBundle();
  var valueCommitCharacters = [",", "}", "]"];
  var propertyCommitCharacters = [":"];
  var JSONCompletion = (
    /** @class */
    function() {
      function JSONCompletion2(schemaService, contributions, promiseConstructor, clientCapabilities) {
        if (contributions === void 0) {
          contributions = [];
        }
        if (promiseConstructor === void 0) {
          promiseConstructor = Promise;
        }
        if (clientCapabilities === void 0) {
          clientCapabilities = {};
        }
        this.schemaService = schemaService;
        this.contributions = contributions;
        this.promiseConstructor = promiseConstructor;
        this.clientCapabilities = clientCapabilities;
      }
      JSONCompletion2.prototype.doResolve = function(item) {
        for (var i = this.contributions.length - 1; i >= 0; i--) {
          var resolveCompletion = this.contributions[i].resolveCompletion;
          if (resolveCompletion) {
            var resolver = resolveCompletion(item);
            if (resolver) {
              return resolver;
            }
          }
        }
        return this.promiseConstructor.resolve(item);
      };
      JSONCompletion2.prototype.doComplete = function(document2, position, doc) {
        var _this = this;
        var result = {
          items: [],
          isIncomplete: false
        };
        var text = document2.getText();
        var offset = document2.offsetAt(position);
        var node = doc.getNodeFromOffset(offset, true);
        if (this.isInComment(document2, node ? node.offset : 0, offset)) {
          return Promise.resolve(result);
        }
        if (node && offset === node.offset + node.length && offset > 0) {
          var ch = text[offset - 1];
          if (node.type === "object" && ch === "}" || node.type === "array" && ch === "]") {
            node = node.parent;
          }
        }
        var currentWord = this.getCurrentWord(document2, offset);
        var overwriteRange;
        if (node && (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null")) {
          overwriteRange = Range2.create(document2.positionAt(node.offset), document2.positionAt(node.offset + node.length));
        } else {
          var overwriteStart = offset - currentWord.length;
          if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
            overwriteStart--;
          }
          overwriteRange = Range2.create(document2.positionAt(overwriteStart), position);
        }
        var supportsCommitCharacters = false;
        var proposed = {};
        var collector = {
          add: function(suggestion) {
            var label = suggestion.label;
            var existing = proposed[label];
            if (!existing) {
              label = label.replace(/[\n]/g, "\u21B5");
              if (label.length > 60) {
                var shortendedLabel = label.substr(0, 57).trim() + "...";
                if (!proposed[shortendedLabel]) {
                  label = shortendedLabel;
                }
              }
              if (overwriteRange && suggestion.insertText !== void 0) {
                suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);
              }
              if (supportsCommitCharacters) {
                suggestion.commitCharacters = suggestion.kind === CompletionItemKind2.Property ? propertyCommitCharacters : valueCommitCharacters;
              }
              suggestion.label = label;
              proposed[label] = suggestion;
              result.items.push(suggestion);
            } else {
              if (!existing.documentation) {
                existing.documentation = suggestion.documentation;
              }
              if (!existing.detail) {
                existing.detail = suggestion.detail;
              }
            }
          },
          setAsIncomplete: function() {
            result.isIncomplete = true;
          },
          error: function(message) {
            console.error(message);
          },
          log: function(message) {
            console.log(message);
          },
          getNumberOfProposals: function() {
            return result.items.length;
          }
        };
        return this.schemaService.getSchemaForResource(document2.uri, doc).then(function(schema5) {
          var collectionPromises = [];
          var addValue = true;
          var currentKey = "";
          var currentProperty = void 0;
          if (node) {
            if (node.type === "string") {
              var parent = node.parent;
              if (parent && parent.type === "property" && parent.keyNode === node) {
                addValue = !parent.valueNode;
                currentProperty = parent;
                currentKey = text.substr(node.offset + 1, node.length - 2);
                if (parent) {
                  node = parent.parent;
                }
              }
            }
          }
          if (node && node.type === "object") {
            if (node.offset === offset) {
              return result;
            }
            var properties = node.properties;
            properties.forEach(function(p) {
              if (!currentProperty || currentProperty !== p) {
                proposed[p.keyNode.value] = CompletionItem.create("__");
              }
            });
            var separatorAfter_1 = "";
            if (addValue) {
              separatorAfter_1 = _this.evaluateSeparatorAfter(document2, document2.offsetAt(overwriteRange.end));
            }
            if (schema5) {
              _this.getPropertyCompletions(schema5, doc, node, addValue, separatorAfter_1, collector);
            } else {
              _this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);
            }
            var location_1 = getNodePath22(node);
            _this.contributions.forEach(function(contribution) {
              var collectPromise = contribution.collectPropertyCompletions(document2.uri, location_1, currentWord, addValue, separatorAfter_1 === "", collector);
              if (collectPromise) {
                collectionPromises.push(collectPromise);
              }
            });
            if (!schema5 && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"') {
              collector.add({
                kind: CompletionItemKind2.Property,
                label: _this.getLabelForValue(currentWord),
                insertText: _this.getInsertTextForProperty(currentWord, void 0, false, separatorAfter_1),
                insertTextFormat: InsertTextFormat.Snippet,
                documentation: ""
              });
              collector.setAsIncomplete();
            }
          }
          var types = {};
          if (schema5) {
            _this.getValueCompletions(schema5, doc, node, offset, document2, collector, types);
          } else {
            _this.getSchemaLessValueCompletions(doc, node, offset, document2, collector);
          }
          if (_this.contributions.length > 0) {
            _this.getContributedValueCompletions(doc, node, offset, document2, collector, collectionPromises);
          }
          return _this.promiseConstructor.all(collectionPromises).then(function() {
            if (collector.getNumberOfProposals() === 0) {
              var offsetForSeparator = offset;
              if (node && (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null")) {
                offsetForSeparator = node.offset + node.length;
              }
              var separatorAfter = _this.evaluateSeparatorAfter(document2, offsetForSeparator);
              _this.addFillerValueCompletions(types, separatorAfter, collector);
            }
            return result;
          });
        });
      };
      JSONCompletion2.prototype.getPropertyCompletions = function(schema5, doc, node, addValue, separatorAfter, collector) {
        var _this = this;
        var matchingSchemas = doc.getMatchingSchemas(schema5.schema, node.offset);
        matchingSchemas.forEach(function(s) {
          if (s.node === node && !s.inverted) {
            var schemaProperties_1 = s.schema.properties;
            if (schemaProperties_1) {
              Object.keys(schemaProperties_1).forEach(function(key) {
                var propertySchema = schemaProperties_1[key];
                if (typeof propertySchema === "object" && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {
                  var proposal = {
                    kind: CompletionItemKind2.Property,
                    label: key,
                    insertText: _this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),
                    insertTextFormat: InsertTextFormat.Snippet,
                    filterText: _this.getFilterTextForValue(key),
                    documentation: _this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || ""
                  };
                  if (propertySchema.suggestSortText !== void 0) {
                    proposal.sortText = propertySchema.suggestSortText;
                  }
                  if (proposal.insertText && endsWith(proposal.insertText, "$1" + separatorAfter)) {
                    proposal.command = {
                      title: "Suggest",
                      command: "editor.action.triggerSuggest"
                    };
                  }
                  collector.add(proposal);
                }
              });
            }
            var schemaPropertyNames_1 = s.schema.propertyNames;
            if (typeof schemaPropertyNames_1 === "object" && !schemaPropertyNames_1.deprecationMessage && !schemaPropertyNames_1.doNotSuggest) {
              var propertyNameCompletionItem = function(name, enumDescription2) {
                if (enumDescription2 === void 0) {
                  enumDescription2 = void 0;
                }
                var proposal = {
                  kind: CompletionItemKind2.Property,
                  label: name,
                  insertText: _this.getInsertTextForProperty(name, void 0, addValue, separatorAfter),
                  insertTextFormat: InsertTextFormat.Snippet,
                  filterText: _this.getFilterTextForValue(name),
                  documentation: enumDescription2 || _this.fromMarkup(schemaPropertyNames_1.markdownDescription) || schemaPropertyNames_1.description || ""
                };
                if (schemaPropertyNames_1.suggestSortText !== void 0) {
                  proposal.sortText = schemaPropertyNames_1.suggestSortText;
                }
                if (proposal.insertText && endsWith(proposal.insertText, "$1" + separatorAfter)) {
                  proposal.command = {
                    title: "Suggest",
                    command: "editor.action.triggerSuggest"
                  };
                }
                collector.add(proposal);
              };
              if (schemaPropertyNames_1.enum) {
                for (var i = 0; i < schemaPropertyNames_1.enum.length; i++) {
                  var enumDescription = void 0;
                  if (schemaPropertyNames_1.markdownEnumDescriptions && i < schemaPropertyNames_1.markdownEnumDescriptions.length) {
                    enumDescription = _this.fromMarkup(schemaPropertyNames_1.markdownEnumDescriptions[i]);
                  } else if (schemaPropertyNames_1.enumDescriptions && i < schemaPropertyNames_1.enumDescriptions.length) {
                    enumDescription = schemaPropertyNames_1.enumDescriptions[i];
                  }
                  propertyNameCompletionItem(schemaPropertyNames_1.enum[i], enumDescription);
                }
              }
              if (schemaPropertyNames_1.const) {
                propertyNameCompletionItem(schemaPropertyNames_1.const);
              }
            }
          }
        });
      };
      JSONCompletion2.prototype.getSchemaLessPropertyCompletions = function(doc, node, currentKey, collector) {
        var _this = this;
        var collectCompletionsForSimilarObject = function(obj) {
          obj.properties.forEach(function(p) {
            var key = p.keyNode.value;
            collector.add({
              kind: CompletionItemKind2.Property,
              label: key,
              insertText: _this.getInsertTextForValue(key, ""),
              insertTextFormat: InsertTextFormat.Snippet,
              filterText: _this.getFilterTextForValue(key),
              documentation: ""
            });
          });
        };
        if (node.parent) {
          if (node.parent.type === "property") {
            var parentKey_1 = node.parent.keyNode.value;
            doc.visit(function(n) {
              if (n.type === "property" && n !== node.parent && n.keyNode.value === parentKey_1 && n.valueNode && n.valueNode.type === "object") {
                collectCompletionsForSimilarObject(n.valueNode);
              }
              return true;
            });
          } else if (node.parent.type === "array") {
            node.parent.items.forEach(function(n) {
              if (n.type === "object" && n !== node) {
                collectCompletionsForSimilarObject(n);
              }
            });
          }
        } else if (node.type === "object") {
          collector.add({
            kind: CompletionItemKind2.Property,
            label: "$schema",
            insertText: this.getInsertTextForProperty("$schema", void 0, true, ""),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: "",
            filterText: this.getFilterTextForValue("$schema")
          });
        }
      };
      JSONCompletion2.prototype.getSchemaLessValueCompletions = function(doc, node, offset, document2, collector) {
        var _this = this;
        var offsetForSeparator = offset;
        if (node && (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null")) {
          offsetForSeparator = node.offset + node.length;
          node = node.parent;
        }
        if (!node) {
          collector.add({
            kind: this.getSuggestionKind("object"),
            label: "Empty object",
            insertText: this.getInsertTextForValue({}, ""),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: ""
          });
          collector.add({
            kind: this.getSuggestionKind("array"),
            label: "Empty array",
            insertText: this.getInsertTextForValue([], ""),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: ""
          });
          return;
        }
        var separatorAfter = this.evaluateSeparatorAfter(document2, offsetForSeparator);
        var collectSuggestionsForValues = function(value) {
          if (value.parent && !contains2(value.parent, offset, true)) {
            collector.add({
              kind: _this.getSuggestionKind(value.type),
              label: _this.getLabelTextForMatchingNode(value, document2),
              insertText: _this.getInsertTextForMatchingNode(value, document2, separatorAfter),
              insertTextFormat: InsertTextFormat.Snippet,
              documentation: ""
            });
          }
          if (value.type === "boolean") {
            _this.addBooleanValueCompletion(!value.value, separatorAfter, collector);
          }
        };
        if (node.type === "property") {
          if (offset > (node.colonOffset || 0)) {
            var valueNode = node.valueNode;
            if (valueNode && (offset > valueNode.offset + valueNode.length || valueNode.type === "object" || valueNode.type === "array")) {
              return;
            }
            var parentKey_2 = node.keyNode.value;
            doc.visit(function(n) {
              if (n.type === "property" && n.keyNode.value === parentKey_2 && n.valueNode) {
                collectSuggestionsForValues(n.valueNode);
              }
              return true;
            });
            if (parentKey_2 === "$schema" && node.parent && !node.parent.parent) {
              this.addDollarSchemaCompletions(separatorAfter, collector);
            }
          }
        }
        if (node.type === "array") {
          if (node.parent && node.parent.type === "property") {
            var parentKey_3 = node.parent.keyNode.value;
            doc.visit(function(n) {
              if (n.type === "property" && n.keyNode.value === parentKey_3 && n.valueNode && n.valueNode.type === "array") {
                n.valueNode.items.forEach(collectSuggestionsForValues);
              }
              return true;
            });
          } else {
            node.items.forEach(collectSuggestionsForValues);
          }
        }
      };
      JSONCompletion2.prototype.getValueCompletions = function(schema5, doc, node, offset, document2, collector, types) {
        var offsetForSeparator = offset;
        var parentKey = void 0;
        var valueNode = void 0;
        if (node && (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null")) {
          offsetForSeparator = node.offset + node.length;
          valueNode = node;
          node = node.parent;
        }
        if (!node) {
          this.addSchemaValueCompletions(schema5.schema, "", collector, types);
          return;
        }
        if (node.type === "property" && offset > (node.colonOffset || 0)) {
          var valueNode_1 = node.valueNode;
          if (valueNode_1 && offset > valueNode_1.offset + valueNode_1.length) {
            return;
          }
          parentKey = node.keyNode.value;
          node = node.parent;
        }
        if (node && (parentKey !== void 0 || node.type === "array")) {
          var separatorAfter = this.evaluateSeparatorAfter(document2, offsetForSeparator);
          var matchingSchemas = doc.getMatchingSchemas(schema5.schema, node.offset, valueNode);
          for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {
            var s = matchingSchemas_1[_i];
            if (s.node === node && !s.inverted && s.schema) {
              if (node.type === "array" && s.schema.items) {
                if (Array.isArray(s.schema.items)) {
                  var index = this.findItemAtOffset(node, document2, offset);
                  if (index < s.schema.items.length) {
                    this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, collector, types);
                  }
                } else {
                  this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types);
                }
              }
              if (parentKey !== void 0) {
                var propertyMatched = false;
                if (s.schema.properties) {
                  var propertySchema = s.schema.properties[parentKey];
                  if (propertySchema) {
                    propertyMatched = true;
                    this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                  }
                }
                if (s.schema.patternProperties && !propertyMatched) {
                  for (var _a3 = 0, _b = Object.keys(s.schema.patternProperties); _a3 < _b.length; _a3++) {
                    var pattern = _b[_a3];
                    var regex = extendedRegExp(pattern);
                    if (regex.test(parentKey)) {
                      propertyMatched = true;
                      var propertySchema = s.schema.patternProperties[pattern];
                      this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                    }
                  }
                }
                if (s.schema.additionalProperties && !propertyMatched) {
                  var propertySchema = s.schema.additionalProperties;
                  this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                }
              }
            }
          }
          if (parentKey === "$schema" && !node.parent) {
            this.addDollarSchemaCompletions(separatorAfter, collector);
          }
          if (types["boolean"]) {
            this.addBooleanValueCompletion(true, separatorAfter, collector);
            this.addBooleanValueCompletion(false, separatorAfter, collector);
          }
          if (types["null"]) {
            this.addNullValueCompletion(separatorAfter, collector);
          }
        }
      };
      JSONCompletion2.prototype.getContributedValueCompletions = function(doc, node, offset, document2, collector, collectionPromises) {
        if (!node) {
          this.contributions.forEach(function(contribution) {
            var collectPromise = contribution.collectDefaultCompletions(document2.uri, collector);
            if (collectPromise) {
              collectionPromises.push(collectPromise);
            }
          });
        } else {
          if (node.type === "string" || node.type === "number" || node.type === "boolean" || node.type === "null") {
            node = node.parent;
          }
          if (node && node.type === "property" && offset > (node.colonOffset || 0)) {
            var parentKey_4 = node.keyNode.value;
            var valueNode = node.valueNode;
            if ((!valueNode || offset <= valueNode.offset + valueNode.length) && node.parent) {
              var location_2 = getNodePath22(node.parent);
              this.contributions.forEach(function(contribution) {
                var collectPromise = contribution.collectValueCompletions(document2.uri, location_2, parentKey_4, collector);
                if (collectPromise) {
                  collectionPromises.push(collectPromise);
                }
              });
            }
          }
        }
      };
      JSONCompletion2.prototype.addSchemaValueCompletions = function(schema5, separatorAfter, collector, types) {
        var _this = this;
        if (typeof schema5 === "object") {
          this.addEnumValueCompletions(schema5, separatorAfter, collector);
          this.addDefaultValueCompletions(schema5, separatorAfter, collector);
          this.collectTypes(schema5, types);
          if (Array.isArray(schema5.allOf)) {
            schema5.allOf.forEach(function(s) {
              return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);
            });
          }
          if (Array.isArray(schema5.anyOf)) {
            schema5.anyOf.forEach(function(s) {
              return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);
            });
          }
          if (Array.isArray(schema5.oneOf)) {
            schema5.oneOf.forEach(function(s) {
              return _this.addSchemaValueCompletions(s, separatorAfter, collector, types);
            });
          }
        }
      };
      JSONCompletion2.prototype.addDefaultValueCompletions = function(schema5, separatorAfter, collector, arrayDepth) {
        var _this = this;
        if (arrayDepth === void 0) {
          arrayDepth = 0;
        }
        var hasProposals = false;
        if (isDefined(schema5.default)) {
          var type = schema5.type;
          var value = schema5.default;
          for (var i = arrayDepth; i > 0; i--) {
            value = [value];
            type = "array";
          }
          collector.add({
            kind: this.getSuggestionKind(type),
            label: this.getLabelForValue(value),
            insertText: this.getInsertTextForValue(value, separatorAfter),
            insertTextFormat: InsertTextFormat.Snippet,
            detail: localize4("json.suggest.default", "Default value")
          });
          hasProposals = true;
        }
        if (Array.isArray(schema5.examples)) {
          schema5.examples.forEach(function(example) {
            var type2 = schema5.type;
            var value2 = example;
            for (var i2 = arrayDepth; i2 > 0; i2--) {
              value2 = [value2];
              type2 = "array";
            }
            collector.add({
              kind: _this.getSuggestionKind(type2),
              label: _this.getLabelForValue(value2),
              insertText: _this.getInsertTextForValue(value2, separatorAfter),
              insertTextFormat: InsertTextFormat.Snippet
            });
            hasProposals = true;
          });
        }
        if (Array.isArray(schema5.defaultSnippets)) {
          schema5.defaultSnippets.forEach(function(s) {
            var type2 = schema5.type;
            var value2 = s.body;
            var label = s.label;
            var insertText;
            var filterText;
            if (isDefined(value2)) {
              var type_1 = schema5.type;
              for (var i2 = arrayDepth; i2 > 0; i2--) {
                value2 = [value2];
                type_1 = "array";
              }
              insertText = _this.getInsertTextForSnippetValue(value2, separatorAfter);
              filterText = _this.getFilterTextForSnippetValue(value2);
              label = label || _this.getLabelForSnippetValue(value2);
            } else if (typeof s.bodyText === "string") {
              var prefix = "", suffix = "", indent = "";
              for (var i2 = arrayDepth; i2 > 0; i2--) {
                prefix = prefix + indent + "[\n";
                suffix = suffix + "\n" + indent + "]";
                indent += "	";
                type2 = "array";
              }
              insertText = prefix + indent + s.bodyText.split("\n").join("\n" + indent) + suffix + separatorAfter;
              label = label || insertText, filterText = insertText.replace(/[\n]/g, "");
            } else {
              return;
            }
            collector.add({
              kind: _this.getSuggestionKind(type2),
              label,
              documentation: _this.fromMarkup(s.markdownDescription) || s.description,
              insertText,
              insertTextFormat: InsertTextFormat.Snippet,
              filterText
            });
            hasProposals = true;
          });
        }
        if (!hasProposals && typeof schema5.items === "object" && !Array.isArray(schema5.items) && arrayDepth < 5) {
          this.addDefaultValueCompletions(schema5.items, separatorAfter, collector, arrayDepth + 1);
        }
      };
      JSONCompletion2.prototype.addEnumValueCompletions = function(schema5, separatorAfter, collector) {
        if (isDefined(schema5.const)) {
          collector.add({
            kind: this.getSuggestionKind(schema5.type),
            label: this.getLabelForValue(schema5.const),
            insertText: this.getInsertTextForValue(schema5.const, separatorAfter),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: this.fromMarkup(schema5.markdownDescription) || schema5.description
          });
        }
        if (Array.isArray(schema5.enum)) {
          for (var i = 0, length = schema5.enum.length; i < length; i++) {
            var enm = schema5.enum[i];
            var documentation = this.fromMarkup(schema5.markdownDescription) || schema5.description;
            if (schema5.markdownEnumDescriptions && i < schema5.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {
              documentation = this.fromMarkup(schema5.markdownEnumDescriptions[i]);
            } else if (schema5.enumDescriptions && i < schema5.enumDescriptions.length) {
              documentation = schema5.enumDescriptions[i];
            }
            collector.add({
              kind: this.getSuggestionKind(schema5.type),
              label: this.getLabelForValue(enm),
              insertText: this.getInsertTextForValue(enm, separatorAfter),
              insertTextFormat: InsertTextFormat.Snippet,
              documentation
            });
          }
        }
      };
      JSONCompletion2.prototype.collectTypes = function(schema5, types) {
        if (Array.isArray(schema5.enum) || isDefined(schema5.const)) {
          return;
        }
        var type = schema5.type;
        if (Array.isArray(type)) {
          type.forEach(function(t) {
            return types[t] = true;
          });
        } else if (type) {
          types[type] = true;
        }
      };
      JSONCompletion2.prototype.addFillerValueCompletions = function(types, separatorAfter, collector) {
        if (types["object"]) {
          collector.add({
            kind: this.getSuggestionKind("object"),
            label: "{}",
            insertText: this.getInsertTextForGuessedValue({}, separatorAfter),
            insertTextFormat: InsertTextFormat.Snippet,
            detail: localize4("defaults.object", "New object"),
            documentation: ""
          });
        }
        if (types["array"]) {
          collector.add({
            kind: this.getSuggestionKind("array"),
            label: "[]",
            insertText: this.getInsertTextForGuessedValue([], separatorAfter),
            insertTextFormat: InsertTextFormat.Snippet,
            detail: localize4("defaults.array", "New array"),
            documentation: ""
          });
        }
      };
      JSONCompletion2.prototype.addBooleanValueCompletion = function(value, separatorAfter, collector) {
        collector.add({
          kind: this.getSuggestionKind("boolean"),
          label: value ? "true" : "false",
          insertText: this.getInsertTextForValue(value, separatorAfter),
          insertTextFormat: InsertTextFormat.Snippet,
          documentation: ""
        });
      };
      JSONCompletion2.prototype.addNullValueCompletion = function(separatorAfter, collector) {
        collector.add({
          kind: this.getSuggestionKind("null"),
          label: "null",
          insertText: "null" + separatorAfter,
          insertTextFormat: InsertTextFormat.Snippet,
          documentation: ""
        });
      };
      JSONCompletion2.prototype.addDollarSchemaCompletions = function(separatorAfter, collector) {
        var _this = this;
        var schemaIds = this.schemaService.getRegisteredSchemaIds(function(schema5) {
          return schema5 === "http" || schema5 === "https";
        });
        schemaIds.forEach(function(schemaId) {
          return collector.add({
            kind: CompletionItemKind2.Module,
            label: _this.getLabelForValue(schemaId),
            filterText: _this.getFilterTextForValue(schemaId),
            insertText: _this.getInsertTextForValue(schemaId, separatorAfter),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: ""
          });
        });
      };
      JSONCompletion2.prototype.getLabelForValue = function(value) {
        return JSON.stringify(value);
      };
      JSONCompletion2.prototype.getFilterTextForValue = function(value) {
        return JSON.stringify(value);
      };
      JSONCompletion2.prototype.getFilterTextForSnippetValue = function(value) {
        return JSON.stringify(value).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1");
      };
      JSONCompletion2.prototype.getLabelForSnippetValue = function(value) {
        var label = JSON.stringify(value);
        return label.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1");
      };
      JSONCompletion2.prototype.getInsertTextForPlainText = function(text) {
        return text.replace(/[\\\$\}]/g, "\\$&");
      };
      JSONCompletion2.prototype.getInsertTextForValue = function(value, separatorAfter) {
        var text = JSON.stringify(value, null, "	");
        if (text === "{}") {
          return "{$1}" + separatorAfter;
        } else if (text === "[]") {
          return "[$1]" + separatorAfter;
        }
        return this.getInsertTextForPlainText(text + separatorAfter);
      };
      JSONCompletion2.prototype.getInsertTextForSnippetValue = function(value, separatorAfter) {
        var replacer = function(value2) {
          if (typeof value2 === "string") {
            if (value2[0] === "^") {
              return value2.substr(1);
            }
          }
          return JSON.stringify(value2);
        };
        return stringifyObject(value, "", replacer) + separatorAfter;
      };
      JSONCompletion2.prototype.getInsertTextForGuessedValue = function(value, separatorAfter) {
        switch (typeof value) {
          case "object":
            if (value === null) {
              return "${1:null}" + separatorAfter;
            }
            return this.getInsertTextForValue(value, separatorAfter);
          case "string":
            var snippetValue = JSON.stringify(value);
            snippetValue = snippetValue.substr(1, snippetValue.length - 2);
            snippetValue = this.getInsertTextForPlainText(snippetValue);
            return '"${1:' + snippetValue + '}"' + separatorAfter;
          case "number":
          case "boolean":
            return "${1:" + JSON.stringify(value) + "}" + separatorAfter;
        }
        return this.getInsertTextForValue(value, separatorAfter);
      };
      JSONCompletion2.prototype.getSuggestionKind = function(type) {
        if (Array.isArray(type)) {
          var array = type;
          type = array.length > 0 ? array[0] : void 0;
        }
        if (!type) {
          return CompletionItemKind2.Value;
        }
        switch (type) {
          case "string":
            return CompletionItemKind2.Value;
          case "object":
            return CompletionItemKind2.Module;
          case "property":
            return CompletionItemKind2.Property;
          default:
            return CompletionItemKind2.Value;
        }
      };
      JSONCompletion2.prototype.getLabelTextForMatchingNode = function(node, document2) {
        switch (node.type) {
          case "array":
            return "[]";
          case "object":
            return "{}";
          default:
            var content = document2.getText().substr(node.offset, node.length);
            return content;
        }
      };
      JSONCompletion2.prototype.getInsertTextForMatchingNode = function(node, document2, separatorAfter) {
        switch (node.type) {
          case "array":
            return this.getInsertTextForValue([], separatorAfter);
          case "object":
            return this.getInsertTextForValue({}, separatorAfter);
          default:
            var content = document2.getText().substr(node.offset, node.length) + separatorAfter;
            return this.getInsertTextForPlainText(content);
        }
      };
      JSONCompletion2.prototype.getInsertTextForProperty = function(key, propertySchema, addValue, separatorAfter) {
        var propertyText = this.getInsertTextForValue(key, "");
        if (!addValue) {
          return propertyText;
        }
        var resultText = propertyText + ": ";
        var value;
        var nValueProposals = 0;
        if (propertySchema) {
          if (Array.isArray(propertySchema.defaultSnippets)) {
            if (propertySchema.defaultSnippets.length === 1) {
              var body = propertySchema.defaultSnippets[0].body;
              if (isDefined(body)) {
                value = this.getInsertTextForSnippetValue(body, "");
              }
            }
            nValueProposals += propertySchema.defaultSnippets.length;
          }
          if (propertySchema.enum) {
            if (!value && propertySchema.enum.length === 1) {
              value = this.getInsertTextForGuessedValue(propertySchema.enum[0], "");
            }
            nValueProposals += propertySchema.enum.length;
          }
          if (isDefined(propertySchema.default)) {
            if (!value) {
              value = this.getInsertTextForGuessedValue(propertySchema.default, "");
            }
            nValueProposals++;
          }
          if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
            if (!value) {
              value = this.getInsertTextForGuessedValue(propertySchema.examples[0], "");
            }
            nValueProposals += propertySchema.examples.length;
          }
          if (nValueProposals === 0) {
            var type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
            if (!type) {
              if (propertySchema.properties) {
                type = "object";
              } else if (propertySchema.items) {
                type = "array";
              }
            }
            switch (type) {
              case "boolean":
                value = "$1";
                break;
              case "string":
                value = '"$1"';
                break;
              case "object":
                value = "{$1}";
                break;
              case "array":
                value = "[$1]";
                break;
              case "number":
              case "integer":
                value = "${1:0}";
                break;
              case "null":
                value = "${1:null}";
                break;
              default:
                return propertyText;
            }
          }
        }
        if (!value || nValueProposals > 1) {
          value = "$1";
        }
        return resultText + value + separatorAfter;
      };
      JSONCompletion2.prototype.getCurrentWord = function(document2, offset) {
        var i = offset - 1;
        var text = document2.getText();
        while (i >= 0 && ' 	\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1) {
          i--;
        }
        return text.substring(i + 1, offset);
      };
      JSONCompletion2.prototype.evaluateSeparatorAfter = function(document2, offset) {
        var scanner = createScanner2(document2.getText(), true);
        scanner.setPosition(offset);
        var token = scanner.scan();
        switch (token) {
          case 5:
          case 2:
          case 4:
          case 17:
            return "";
          default:
            return ",";
        }
      };
      JSONCompletion2.prototype.findItemAtOffset = function(node, document2, offset) {
        var scanner = createScanner2(document2.getText(), true);
        var children = node.items;
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          if (offset > child.offset + child.length) {
            scanner.setPosition(child.offset + child.length);
            var token = scanner.scan();
            if (token === 5 && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {
              return i + 1;
            }
            return i;
          } else if (offset >= child.offset) {
            return i;
          }
        }
        return 0;
      };
      JSONCompletion2.prototype.isInComment = function(document2, start, offset) {
        var scanner = createScanner2(document2.getText(), false);
        scanner.setPosition(start);
        var token = scanner.scan();
        while (token !== 17 && scanner.getTokenOffset() + scanner.getTokenLength() < offset) {
          token = scanner.scan();
        }
        return (token === 12 || token === 13) && scanner.getTokenOffset() <= offset;
      };
      JSONCompletion2.prototype.fromMarkup = function(markupString) {
        if (markupString && this.doesSupportMarkdown()) {
          return {
            kind: MarkupKind.Markdown,
            value: markupString
          };
        }
        return void 0;
      };
      JSONCompletion2.prototype.doesSupportMarkdown = function() {
        if (!isDefined(this.supportsMarkdown)) {
          var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
          this.supportsMarkdown = completion && completion.completionItem && Array.isArray(completion.completionItem.documentationFormat) && completion.completionItem.documentationFormat.indexOf(MarkupKind.Markdown) !== -1;
        }
        return this.supportsMarkdown;
      };
      JSONCompletion2.prototype.doesSupportsCommitCharacters = function() {
        if (!isDefined(this.supportsCommitCharacters)) {
          var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
          this.supportsCommitCharacters = completion && completion.completionItem && !!completion.completionItem.commitCharactersSupport;
        }
        return this.supportsCommitCharacters;
      };
      return JSONCompletion2;
    }()
  );
  var JSONHover = (
    /** @class */
    function() {
      function JSONHover2(schemaService, contributions, promiseConstructor) {
        if (contributions === void 0) {
          contributions = [];
        }
        this.schemaService = schemaService;
        this.contributions = contributions;
        this.promise = promiseConstructor || Promise;
      }
      JSONHover2.prototype.doHover = function(document2, position, doc) {
        var offset = document2.offsetAt(position);
        var node = doc.getNodeFromOffset(offset);
        if (!node || (node.type === "object" || node.type === "array") && offset > node.offset + 1 && offset < node.offset + node.length - 1) {
          return this.promise.resolve(null);
        }
        var hoverRangeNode = node;
        if (node.type === "string") {
          var parent = node.parent;
          if (parent && parent.type === "property" && parent.keyNode === node) {
            node = parent.valueNode;
            if (!node) {
              return this.promise.resolve(null);
            }
          }
        }
        var hoverRange = Range2.create(document2.positionAt(hoverRangeNode.offset), document2.positionAt(hoverRangeNode.offset + hoverRangeNode.length));
        var createHover = function(contents) {
          var result = {
            contents,
            range: hoverRange
          };
          return result;
        };
        var location = getNodePath22(node);
        for (var i = this.contributions.length - 1; i >= 0; i--) {
          var contribution = this.contributions[i];
          var promise = contribution.getInfoContribution(document2.uri, location);
          if (promise) {
            return promise.then(function(htmlContent) {
              return createHover(htmlContent);
            });
          }
        }
        return this.schemaService.getSchemaForResource(document2.uri, doc).then(function(schema5) {
          if (schema5 && node) {
            var matchingSchemas = doc.getMatchingSchemas(schema5.schema, node.offset);
            var title_1 = void 0;
            var markdownDescription_1 = void 0;
            var markdownEnumValueDescription_1 = void 0, enumValue_1 = void 0;
            matchingSchemas.every(function(s) {
              if (s.node === node && !s.inverted && s.schema) {
                title_1 = title_1 || s.schema.title;
                markdownDescription_1 = markdownDescription_1 || s.schema.markdownDescription || toMarkdown(s.schema.description);
                if (s.schema.enum) {
                  var idx = s.schema.enum.indexOf(getNodeValue22(node));
                  if (s.schema.markdownEnumDescriptions) {
                    markdownEnumValueDescription_1 = s.schema.markdownEnumDescriptions[idx];
                  } else if (s.schema.enumDescriptions) {
                    markdownEnumValueDescription_1 = toMarkdown(s.schema.enumDescriptions[idx]);
                  }
                  if (markdownEnumValueDescription_1) {
                    enumValue_1 = s.schema.enum[idx];
                    if (typeof enumValue_1 !== "string") {
                      enumValue_1 = JSON.stringify(enumValue_1);
                    }
                  }
                }
              }
              return true;
            });
            var result = "";
            if (title_1) {
              result = toMarkdown(title_1);
            }
            if (markdownDescription_1) {
              if (result.length > 0) {
                result += "\n\n";
              }
              result += markdownDescription_1;
            }
            if (markdownEnumValueDescription_1) {
              if (result.length > 0) {
                result += "\n\n";
              }
              result += "`" + toMarkdownCodeBlock(enumValue_1) + "`: " + markdownEnumValueDescription_1;
            }
            return createHover([result]);
          }
          return null;
        });
      };
      return JSONHover2;
    }()
  );
  function toMarkdown(plain) {
    if (plain) {
      var res = plain.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, "$1\n\n$3");
      return res.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    return void 0;
  }
  function toMarkdownCodeBlock(content) {
    if (content.indexOf("`") !== -1) {
      return "`` " + content + " ``";
    }
    return content;
  }
  var localize5 = loadMessageBundle();
  var JSONValidation = (
    /** @class */
    function() {
      function JSONValidation2(jsonSchemaService, promiseConstructor) {
        this.jsonSchemaService = jsonSchemaService;
        this.promise = promiseConstructor;
        this.validationEnabled = true;
      }
      JSONValidation2.prototype.configure = function(raw) {
        if (raw) {
          this.validationEnabled = raw.validate !== false;
          this.commentSeverity = raw.allowComments ? void 0 : DiagnosticSeverity.Error;
        }
      };
      JSONValidation2.prototype.doValidation = function(textDocument, jsonDocument, documentSettings, schema5) {
        var _this = this;
        if (!this.validationEnabled) {
          return this.promise.resolve([]);
        }
        var diagnostics = [];
        var added = {};
        var addProblem = function(problem) {
          var signature = problem.range.start.line + " " + problem.range.start.character + " " + problem.message;
          if (!added[signature]) {
            added[signature] = true;
            diagnostics.push(problem);
          }
        };
        var getDiagnostics = function(schema22) {
          var trailingCommaSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : DiagnosticSeverity.Error;
          var commentSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.comments) ? toDiagnosticSeverity(documentSettings.comments) : _this.commentSeverity;
          var schemaValidation = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : DiagnosticSeverity.Warning;
          var schemaRequest = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : DiagnosticSeverity.Warning;
          if (schema22) {
            if (schema22.errors.length && jsonDocument.root && schemaRequest) {
              var astRoot = jsonDocument.root;
              var property2 = astRoot.type === "object" ? astRoot.properties[0] : void 0;
              if (property2 && property2.keyNode.value === "$schema") {
                var node = property2.valueNode || property2;
                var range = Range2.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));
                addProblem(Diagnostic.create(range, schema22.errors[0], schemaRequest, ErrorCode.SchemaResolveError));
              } else {
                var range = Range2.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));
                addProblem(Diagnostic.create(range, schema22.errors[0], schemaRequest, ErrorCode.SchemaResolveError));
              }
            } else if (schemaValidation) {
              var semanticErrors = jsonDocument.validate(textDocument, schema22.schema, schemaValidation);
              if (semanticErrors) {
                semanticErrors.forEach(addProblem);
              }
            }
            if (schemaAllowsComments(schema22.schema)) {
              commentSeverity = void 0;
            }
            if (schemaAllowsTrailingCommas(schema22.schema)) {
              trailingCommaSeverity = void 0;
            }
          }
          for (var _i = 0, _a3 = jsonDocument.syntaxErrors; _i < _a3.length; _i++) {
            var p = _a3[_i];
            if (p.code === ErrorCode.TrailingComma) {
              if (typeof trailingCommaSeverity !== "number") {
                continue;
              }
              p.severity = trailingCommaSeverity;
            }
            addProblem(p);
          }
          if (typeof commentSeverity === "number") {
            var message_1 = localize5("InvalidCommentToken", "Comments are not permitted in JSON.");
            jsonDocument.comments.forEach(function(c) {
              addProblem(Diagnostic.create(c, message_1, commentSeverity, ErrorCode.CommentNotPermitted));
            });
          }
          return diagnostics;
        };
        if (schema5) {
          var id = schema5.id || "schemaservice://untitled/" + idCounter2++;
          return this.jsonSchemaService.resolveSchemaContent(new UnresolvedSchema(schema5), id, {}).then(function(resolvedSchema) {
            return getDiagnostics(resolvedSchema);
          });
        }
        return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function(schema22) {
          return getDiagnostics(schema22);
        });
      };
      return JSONValidation2;
    }()
  );
  var idCounter2 = 0;
  function schemaAllowsComments(schemaRef) {
    if (schemaRef && typeof schemaRef === "object") {
      if (isBoolean(schemaRef.allowComments)) {
        return schemaRef.allowComments;
      }
      if (schemaRef.allOf) {
        for (var _i = 0, _a3 = schemaRef.allOf; _i < _a3.length; _i++) {
          var schema5 = _a3[_i];
          var allow = schemaAllowsComments(schema5);
          if (isBoolean(allow)) {
            return allow;
          }
        }
      }
    }
    return void 0;
  }
  function schemaAllowsTrailingCommas(schemaRef) {
    if (schemaRef && typeof schemaRef === "object") {
      if (isBoolean(schemaRef.allowTrailingCommas)) {
        return schemaRef.allowTrailingCommas;
      }
      var deprSchemaRef = schemaRef;
      if (isBoolean(deprSchemaRef["allowsTrailingCommas"])) {
        return deprSchemaRef["allowsTrailingCommas"];
      }
      if (schemaRef.allOf) {
        for (var _i = 0, _a3 = schemaRef.allOf; _i < _a3.length; _i++) {
          var schema5 = _a3[_i];
          var allow = schemaAllowsTrailingCommas(schema5);
          if (isBoolean(allow)) {
            return allow;
          }
        }
      }
    }
    return void 0;
  }
  function toDiagnosticSeverity(severityLevel) {
    switch (severityLevel) {
      case "error":
        return DiagnosticSeverity.Error;
      case "warning":
        return DiagnosticSeverity.Warning;
      case "ignore":
        return void 0;
    }
    return void 0;
  }
  var Digit0 = 48;
  var Digit9 = 57;
  var A = 65;
  var a = 97;
  var f = 102;
  function hexDigit(charCode) {
    if (charCode < Digit0) {
      return 0;
    }
    if (charCode <= Digit9) {
      return charCode - Digit0;
    }
    if (charCode < a) {
      charCode += a - A;
    }
    if (charCode >= a && charCode <= f) {
      return charCode - a + 10;
    }
    return 0;
  }
  function colorFromHex(text) {
    if (text[0] !== "#") {
      return void 0;
    }
    switch (text.length) {
      case 4:
        return {
          red: hexDigit(text.charCodeAt(1)) * 17 / 255,
          green: hexDigit(text.charCodeAt(2)) * 17 / 255,
          blue: hexDigit(text.charCodeAt(3)) * 17 / 255,
          alpha: 1
        };
      case 5:
        return {
          red: hexDigit(text.charCodeAt(1)) * 17 / 255,
          green: hexDigit(text.charCodeAt(2)) * 17 / 255,
          blue: hexDigit(text.charCodeAt(3)) * 17 / 255,
          alpha: hexDigit(text.charCodeAt(4)) * 17 / 255
        };
      case 7:
        return {
          red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,
          green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,
          blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,
          alpha: 1
        };
      case 9:
        return {
          red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,
          green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,
          blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,
          alpha: (hexDigit(text.charCodeAt(7)) * 16 + hexDigit(text.charCodeAt(8))) / 255
        };
    }
    return void 0;
  }
  var JSONDocumentSymbols = (
    /** @class */
    function() {
      function JSONDocumentSymbols2(schemaService) {
        this.schemaService = schemaService;
      }
      JSONDocumentSymbols2.prototype.findDocumentSymbols = function(document2, doc, context) {
        var _this = this;
        if (context === void 0) {
          context = { resultLimit: Number.MAX_VALUE };
        }
        var root = doc.root;
        if (!root) {
          return [];
        }
        var limit = context.resultLimit || Number.MAX_VALUE;
        var resourceString = document2.uri;
        if (resourceString === "vscode://defaultsettings/keybindings.json" || endsWith(resourceString.toLowerCase(), "/user/keybindings.json")) {
          if (root.type === "array") {
            var result_1 = [];
            for (var _i = 0, _a3 = root.items; _i < _a3.length; _i++) {
              var item = _a3[_i];
              if (item.type === "object") {
                for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {
                  var property2 = _c[_b];
                  if (property2.keyNode.value === "key" && property2.valueNode) {
                    var location = Location.create(document2.uri, getRange(document2, item));
                    result_1.push({ name: getNodeValue22(property2.valueNode), kind: SymbolKind2.Function, location });
                    limit--;
                    if (limit <= 0) {
                      if (context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                      }
                      return result_1;
                    }
                  }
                }
              }
            }
            return result_1;
          }
        }
        var toVisit = [
          { node: root, containerName: "" }
        ];
        var nextToVisit = 0;
        var limitExceeded = false;
        var result = [];
        var collectOutlineEntries = function(node, containerName) {
          if (node.type === "array") {
            node.items.forEach(function(node2) {
              if (node2) {
                toVisit.push({ node: node2, containerName });
              }
            });
          } else if (node.type === "object") {
            node.properties.forEach(function(property22) {
              var valueNode = property22.valueNode;
              if (valueNode) {
                if (limit > 0) {
                  limit--;
                  var location2 = Location.create(document2.uri, getRange(document2, property22));
                  var childContainerName = containerName ? containerName + "." + property22.keyNode.value : property22.keyNode.value;
                  result.push({ name: _this.getKeyLabel(property22), kind: _this.getSymbolKind(valueNode.type), location: location2, containerName });
                  toVisit.push({ node: valueNode, containerName: childContainerName });
                } else {
                  limitExceeded = true;
                }
              }
            });
          }
        };
        while (nextToVisit < toVisit.length) {
          var next = toVisit[nextToVisit++];
          collectOutlineEntries(next.node, next.containerName);
        }
        if (limitExceeded && context && context.onResultLimitExceeded) {
          context.onResultLimitExceeded(resourceString);
        }
        return result;
      };
      JSONDocumentSymbols2.prototype.findDocumentSymbols2 = function(document2, doc, context) {
        var _this = this;
        if (context === void 0) {
          context = { resultLimit: Number.MAX_VALUE };
        }
        var root = doc.root;
        if (!root) {
          return [];
        }
        var limit = context.resultLimit || Number.MAX_VALUE;
        var resourceString = document2.uri;
        if (resourceString === "vscode://defaultsettings/keybindings.json" || endsWith(resourceString.toLowerCase(), "/user/keybindings.json")) {
          if (root.type === "array") {
            var result_2 = [];
            for (var _i = 0, _a3 = root.items; _i < _a3.length; _i++) {
              var item = _a3[_i];
              if (item.type === "object") {
                for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {
                  var property2 = _c[_b];
                  if (property2.keyNode.value === "key" && property2.valueNode) {
                    var range = getRange(document2, item);
                    var selectionRange = getRange(document2, property2.keyNode);
                    result_2.push({ name: getNodeValue22(property2.valueNode), kind: SymbolKind2.Function, range, selectionRange });
                    limit--;
                    if (limit <= 0) {
                      if (context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                      }
                      return result_2;
                    }
                  }
                }
              }
            }
            return result_2;
          }
        }
        var result = [];
        var toVisit = [
          { node: root, result }
        ];
        var nextToVisit = 0;
        var limitExceeded = false;
        var collectOutlineEntries = function(node, result2) {
          if (node.type === "array") {
            node.items.forEach(function(node2, index) {
              if (node2) {
                if (limit > 0) {
                  limit--;
                  var range2 = getRange(document2, node2);
                  var selectionRange2 = range2;
                  var name = String(index);
                  var symbol = { name, kind: _this.getSymbolKind(node2.type), range: range2, selectionRange: selectionRange2, children: [] };
                  result2.push(symbol);
                  toVisit.push({ result: symbol.children, node: node2 });
                } else {
                  limitExceeded = true;
                }
              }
            });
          } else if (node.type === "object") {
            node.properties.forEach(function(property22) {
              var valueNode = property22.valueNode;
              if (valueNode) {
                if (limit > 0) {
                  limit--;
                  var range2 = getRange(document2, property22);
                  var selectionRange2 = getRange(document2, property22.keyNode);
                  var children = [];
                  var symbol = { name: _this.getKeyLabel(property22), kind: _this.getSymbolKind(valueNode.type), range: range2, selectionRange: selectionRange2, children, detail: _this.getDetail(valueNode) };
                  result2.push(symbol);
                  toVisit.push({ result: children, node: valueNode });
                } else {
                  limitExceeded = true;
                }
              }
            });
          }
        };
        while (nextToVisit < toVisit.length) {
          var next = toVisit[nextToVisit++];
          collectOutlineEntries(next.node, next.result);
        }
        if (limitExceeded && context && context.onResultLimitExceeded) {
          context.onResultLimitExceeded(resourceString);
        }
        return result;
      };
      JSONDocumentSymbols2.prototype.getSymbolKind = function(nodeType) {
        switch (nodeType) {
          case "object":
            return SymbolKind2.Module;
          case "string":
            return SymbolKind2.String;
          case "number":
            return SymbolKind2.Number;
          case "array":
            return SymbolKind2.Array;
          case "boolean":
            return SymbolKind2.Boolean;
          default:
            return SymbolKind2.Variable;
        }
      };
      JSONDocumentSymbols2.prototype.getKeyLabel = function(property2) {
        var name = property2.keyNode.value;
        if (name) {
          name = name.replace(/[\n]/g, "\u21B5");
        }
        if (name && name.trim()) {
          return name;
        }
        return '"' + name + '"';
      };
      JSONDocumentSymbols2.prototype.getDetail = function(node) {
        if (!node) {
          return void 0;
        }
        if (node.type === "boolean" || node.type === "number" || node.type === "null" || node.type === "string") {
          return String(node.value);
        } else {
          if (node.type === "array") {
            return node.children.length ? void 0 : "[]";
          } else if (node.type === "object") {
            return node.children.length ? void 0 : "{}";
          }
        }
        return void 0;
      };
      JSONDocumentSymbols2.prototype.findDocumentColors = function(document2, doc, context) {
        return this.schemaService.getSchemaForResource(document2.uri, doc).then(function(schema5) {
          var result = [];
          if (schema5) {
            var limit = context && typeof context.resultLimit === "number" ? context.resultLimit : Number.MAX_VALUE;
            var matchingSchemas = doc.getMatchingSchemas(schema5.schema);
            var visitedNode = {};
            for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {
              var s = matchingSchemas_1[_i];
              if (!s.inverted && s.schema && (s.schema.format === "color" || s.schema.format === "color-hex") && s.node && s.node.type === "string") {
                var nodeId = String(s.node.offset);
                if (!visitedNode[nodeId]) {
                  var color = colorFromHex(getNodeValue22(s.node));
                  if (color) {
                    var range = getRange(document2, s.node);
                    result.push({ color, range });
                  }
                  visitedNode[nodeId] = true;
                  limit--;
                  if (limit <= 0) {
                    if (context && context.onResultLimitExceeded) {
                      context.onResultLimitExceeded(document2.uri);
                    }
                    return result;
                  }
                }
              }
            }
          }
          return result;
        });
      };
      JSONDocumentSymbols2.prototype.getColorPresentations = function(document2, doc, color, range) {
        var result = [];
        var red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
        function toTwoDigitHex(n) {
          var r = n.toString(16);
          return r.length !== 2 ? "0" + r : r;
        }
        var label;
        if (color.alpha === 1) {
          label = "#" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256);
        } else {
          label = "#" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256) + toTwoDigitHex(Math.round(color.alpha * 255));
        }
        result.push({ label, textEdit: TextEdit.replace(range, JSON.stringify(label)) });
        return result;
      };
      return JSONDocumentSymbols2;
    }()
  );
  function getRange(document2, node) {
    return Range2.create(document2.positionAt(node.offset), document2.positionAt(node.offset + node.length));
  }
  var localize6 = loadMessageBundle();
  var schemaContributions = {
    schemaAssociations: [],
    schemas: {
      // refer to the latest schema
      "http://json-schema.org/schema#": {
        $ref: "http://json-schema.org/draft-07/schema#"
      },
      // bundle the schema-schema to include (localized) descriptions
      "http://json-schema.org/draft-04/schema#": {
        "$schema": "http://json-schema.org/draft-04/schema#",
        "definitions": {
          "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#"
            }
          },
          "positiveInteger": {
            "type": "integer",
            "minimum": 0
          },
          "positiveIntegerDefault0": {
            "allOf": [
              {
                "$ref": "#/definitions/positiveInteger"
              },
              {
                "default": 0
              }
            ]
          },
          "simpleTypes": {
            "type": "string",
            "enum": [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ]
          },
          "stringArray": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "uniqueItems": true
          }
        },
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uri"
          },
          "$schema": {
            "type": "string",
            "format": "uri"
          },
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "default": {},
          "multipleOf": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
          },
          "maximum": {
            "type": "number"
          },
          "exclusiveMaximum": {
            "type": "boolean",
            "default": false
          },
          "minimum": {
            "type": "number"
          },
          "exclusiveMinimum": {
            "type": "boolean",
            "default": false
          },
          "maxLength": {
            "allOf": [
              {
                "$ref": "#/definitions/positiveInteger"
              }
            ]
          },
          "minLength": {
            "allOf": [
              {
                "$ref": "#/definitions/positiveIntegerDefault0"
              }
            ]
          },
          "pattern": {
            "type": "string",
            "format": "regex"
          },
          "additionalItems": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "$ref": "#"
              }
            ],
            "default": {}
          },
          "items": {
            "anyOf": [
              {
                "$ref": "#"
              },
              {
                "$ref": "#/definitions/schemaArray"
              }
            ],
            "default": {}
          },
          "maxItems": {
            "allOf": [
              {
                "$ref": "#/definitions/positiveInteger"
              }
            ]
          },
          "minItems": {
            "allOf": [
              {
                "$ref": "#/definitions/positiveIntegerDefault0"
              }
            ]
          },
          "uniqueItems": {
            "type": "boolean",
            "default": false
          },
          "maxProperties": {
            "allOf": [
              {
                "$ref": "#/definitions/positiveInteger"
              }
            ]
          },
          "minProperties": {
            "allOf": [
              {
                "$ref": "#/definitions/positiveIntegerDefault0"
              }
            ]
          },
          "required": {
            "allOf": [
              {
                "$ref": "#/definitions/stringArray"
              }
            ]
          },
          "additionalProperties": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "$ref": "#"
              }
            ],
            "default": {}
          },
          "definitions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#"
            },
            "default": {}
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#"
            },
            "default": {}
          },
          "patternProperties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#"
            },
            "default": {}
          },
          "dependencies": {
            "type": "object",
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#"
                },
                {
                  "$ref": "#/definitions/stringArray"
                }
              ]
            }
          },
          "enum": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true
          },
          "type": {
            "anyOf": [
              {
                "$ref": "#/definitions/simpleTypes"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/simpleTypes"
                },
                "minItems": 1,
                "uniqueItems": true
              }
            ]
          },
          "format": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "date-time",
                  "uri",
                  "email",
                  "hostname",
                  "ipv4",
                  "ipv6",
                  "regex"
                ]
              },
              {
                "type": "string"
              }
            ]
          },
          "allOf": {
            "allOf": [
              {
                "$ref": "#/definitions/schemaArray"
              }
            ]
          },
          "anyOf": {
            "allOf": [
              {
                "$ref": "#/definitions/schemaArray"
              }
            ]
          },
          "oneOf": {
            "allOf": [
              {
                "$ref": "#/definitions/schemaArray"
              }
            ]
          },
          "not": {
            "allOf": [
              {
                "$ref": "#"
              }
            ]
          }
        },
        "dependencies": {
          "exclusiveMaximum": [
            "maximum"
          ],
          "exclusiveMinimum": [
            "minimum"
          ]
        },
        "default": {}
      },
      "http://json-schema.org/draft-07/schema#": {
        "definitions": {
          "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
          },
          "nonNegativeInteger": {
            "type": "integer",
            "minimum": 0
          },
          "nonNegativeIntegerDefault0": {
            "allOf": [
              { "$ref": "#/definitions/nonNegativeInteger" },
              { "default": 0 }
            ]
          },
          "simpleTypes": {
            "enum": [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ]
          },
          "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "uniqueItems": true,
            "default": []
          }
        },
        "type": ["object", "boolean"],
        "properties": {
          "$id": {
            "type": "string",
            "format": "uri-reference"
          },
          "$schema": {
            "type": "string",
            "format": "uri"
          },
          "$ref": {
            "type": "string",
            "format": "uri-reference"
          },
          "$comment": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "default": true,
          "readOnly": {
            "type": "boolean",
            "default": false
          },
          "examples": {
            "type": "array",
            "items": true
          },
          "multipleOf": {
            "type": "number",
            "exclusiveMinimum": 0
          },
          "maximum": {
            "type": "number"
          },
          "exclusiveMaximum": {
            "type": "number"
          },
          "minimum": {
            "type": "number"
          },
          "exclusiveMinimum": {
            "type": "number"
          },
          "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
          "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
          "pattern": {
            "type": "string",
            "format": "regex"
          },
          "additionalItems": { "$ref": "#" },
          "items": {
            "anyOf": [
              { "$ref": "#" },
              { "$ref": "#/definitions/schemaArray" }
            ],
            "default": true
          },
          "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
          "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
          "uniqueItems": {
            "type": "boolean",
            "default": false
          },
          "contains": { "$ref": "#" },
          "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
          "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
          "required": { "$ref": "#/definitions/stringArray" },
          "additionalProperties": { "$ref": "#" },
          "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
          },
          "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
          },
          "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "propertyNames": { "format": "regex" },
            "default": {}
          },
          "dependencies": {
            "type": "object",
            "additionalProperties": {
              "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/stringArray" }
              ]
            }
          },
          "propertyNames": { "$ref": "#" },
          "const": true,
          "enum": {
            "type": "array",
            "items": true,
            "minItems": 1,
            "uniqueItems": true
          },
          "type": {
            "anyOf": [
              { "$ref": "#/definitions/simpleTypes" },
              {
                "type": "array",
                "items": { "$ref": "#/definitions/simpleTypes" },
                "minItems": 1,
                "uniqueItems": true
              }
            ]
          },
          "format": { "type": "string" },
          "contentMediaType": { "type": "string" },
          "contentEncoding": { "type": "string" },
          "if": { "$ref": "#" },
          "then": { "$ref": "#" },
          "else": { "$ref": "#" },
          "allOf": { "$ref": "#/definitions/schemaArray" },
          "anyOf": { "$ref": "#/definitions/schemaArray" },
          "oneOf": { "$ref": "#/definitions/schemaArray" },
          "not": { "$ref": "#" }
        },
        "default": true
      }
    }
  };
  var descriptions = {
    id: localize6("schema.json.id", "A unique identifier for the schema."),
    $schema: localize6("schema.json.$schema", "The schema to verify this document against."),
    title: localize6("schema.json.title", "A descriptive title of the element."),
    description: localize6("schema.json.description", "A long description of the element. Used in hover menus and suggestions."),
    default: localize6("schema.json.default", "A default value. Used by suggestions."),
    multipleOf: localize6("schema.json.multipleOf", "A number that should cleanly divide the current value (i.e. have no remainder)."),
    maximum: localize6("schema.json.maximum", "The maximum numerical value, inclusive by default."),
    exclusiveMaximum: localize6("schema.json.exclusiveMaximum", "Makes the maximum property exclusive."),
    minimum: localize6("schema.json.minimum", "The minimum numerical value, inclusive by default."),
    exclusiveMinimum: localize6("schema.json.exclusiveMininum", "Makes the minimum property exclusive."),
    maxLength: localize6("schema.json.maxLength", "The maximum length of a string."),
    minLength: localize6("schema.json.minLength", "The minimum length of a string."),
    pattern: localize6("schema.json.pattern", "A regular expression to match the string against. It is not implicitly anchored."),
    additionalItems: localize6("schema.json.additionalItems", "For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail."),
    items: localize6("schema.json.items", "For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on."),
    maxItems: localize6("schema.json.maxItems", "The maximum number of items that can be inside an array. Inclusive."),
    minItems: localize6("schema.json.minItems", "The minimum number of items that can be inside an array. Inclusive."),
    uniqueItems: localize6("schema.json.uniqueItems", "If all of the items in the array must be unique. Defaults to false."),
    maxProperties: localize6("schema.json.maxProperties", "The maximum number of properties an object can have. Inclusive."),
    minProperties: localize6("schema.json.minProperties", "The minimum number of properties an object can have. Inclusive."),
    required: localize6("schema.json.required", "An array of strings that lists the names of all properties required on this object."),
    additionalProperties: localize6("schema.json.additionalProperties", "Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail."),
    definitions: localize6("schema.json.definitions", "Not used for validation. Place subschemas here that you wish to reference inline with $ref."),
    properties: localize6("schema.json.properties", "A map of property names to schemas for each property."),
    patternProperties: localize6("schema.json.patternProperties", "A map of regular expressions on property names to schemas for matching properties."),
    dependencies: localize6("schema.json.dependencies", "A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object."),
    enum: localize6("schema.json.enum", "The set of literal values that are valid."),
    type: localize6("schema.json.type", "Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types."),
    format: localize6("schema.json.format", "Describes the format expected for the value."),
    allOf: localize6("schema.json.allOf", "An array of schemas, all of which must match."),
    anyOf: localize6("schema.json.anyOf", "An array of schemas, where at least one must match."),
    oneOf: localize6("schema.json.oneOf", "An array of schemas, exactly one of which must match."),
    not: localize6("schema.json.not", "A schema which must not match."),
    $id: localize6("schema.json.$id", "A unique identifier for the schema."),
    $ref: localize6("schema.json.$ref", "Reference a definition hosted on any location."),
    $comment: localize6("schema.json.$comment", "Comments from schema authors to readers or maintainers of the schema."),
    readOnly: localize6("schema.json.readOnly", "Indicates that the value of the instance is managed exclusively by the owning authority."),
    examples: localize6("schema.json.examples", "Sample JSON values associated with a particular schema, for the purpose of illustrating usage."),
    contains: localize6("schema.json.contains", 'An array instance is valid against "contains" if at least one of its elements is valid against the given schema.'),
    propertyNames: localize6("schema.json.propertyNames", "If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema."),
    const: localize6("schema.json.const", "An instance validates successfully against this keyword if its value is equal to the value of the keyword."),
    contentMediaType: localize6("schema.json.contentMediaType", "Describes the media type of a string property."),
    contentEncoding: localize6("schema.json.contentEncoding", "Describes the content encoding of a string property."),
    if: localize6("schema.json.if", 'The validation outcome of the "if" subschema controls which of the "then" or "else" keywords are evaluated.'),
    then: localize6("schema.json.then", 'The "if" subschema is used for validation when the "if" subschema succeeds.'),
    else: localize6("schema.json.else", 'The "else" subschema is used for validation when the "if" subschema fails.')
  };
  for (schemaName in schemaContributions.schemas) {
    schema4 = schemaContributions.schemas[schemaName];
    for (property in schema4.properties) {
      propertyObject = schema4.properties[property];
      if (typeof propertyObject === "boolean") {
        propertyObject = schema4.properties[property] = {};
      }
      description = descriptions[property];
      if (description) {
        propertyObject["description"] = description;
      } else {
        console.log(property + ": localize('schema.json." + property + `', "")`);
      }
    }
  }
  var schema4;
  var propertyObject;
  var description;
  var property;
  var schemaName;
  function findLinks(document2, doc) {
    var links = [];
    doc.visit(function(node) {
      var _a3;
      if (node.type === "property" && node.keyNode.value === "$ref" && ((_a3 = node.valueNode) === null || _a3 === void 0 ? void 0 : _a3.type) === "string") {
        var path5 = node.valueNode.value;
        var targetNode = findTargetNode(doc, path5);
        if (targetNode) {
          var targetPos = document2.positionAt(targetNode.offset);
          links.push({
            target: document2.uri + "#" + (targetPos.line + 1) + "," + (targetPos.character + 1),
            range: createRange(document2, node.valueNode)
          });
        }
      }
      return true;
    });
    return Promise.resolve(links);
  }
  function createRange(document2, node) {
    return Range2.create(document2.positionAt(node.offset + 1), document2.positionAt(node.offset + node.length - 1));
  }
  function findTargetNode(doc, path5) {
    var tokens = parseJSONPointer(path5);
    if (!tokens) {
      return null;
    }
    return findNode(tokens, doc.root);
  }
  function findNode(pointer, node) {
    if (!node) {
      return null;
    }
    if (pointer.length === 0) {
      return node;
    }
    var token = pointer.shift();
    if (node && node.type === "object") {
      var propertyNode = node.properties.find(function(propertyNode2) {
        return propertyNode2.keyNode.value === token;
      });
      if (!propertyNode) {
        return null;
      }
      return findNode(pointer, propertyNode.valueNode);
    } else if (node && node.type === "array") {
      if (token.match(/^(0|[1-9][0-9]*)$/)) {
        var index = Number.parseInt(token);
        var arrayItem = node.items[index];
        if (!arrayItem) {
          return null;
        }
        return findNode(pointer, arrayItem);
      }
    }
    return null;
  }
  function parseJSONPointer(path5) {
    if (path5 === "#") {
      return [];
    }
    if (path5[0] !== "#" || path5[1] !== "/") {
      return null;
    }
    return path5.substring(2).split(/\//).map(unescape);
  }
  function unescape(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function matchOffsetToDocument(offset, jsonDocuments) {
    for (const jsonDoc of jsonDocuments.documents) {
      if (jsonDoc.internalDocument && jsonDoc.internalDocument.range[0] <= offset && jsonDoc.internalDocument.range[2] >= offset) {
        return jsonDoc;
      }
    }
    if (jsonDocuments.documents.length === 1) {
      return jsonDocuments.documents[0];
    }
    return null;
  }
  function filterInvalidCustomTags(customTags) {
    const validCustomTags = ["mapping", "scalar", "sequence"];
    if (!customTags) {
      return [];
    }
    return customTags.filter((tag) => {
      if (typeof tag === "string") {
        const typeInfo = tag.split(" ");
        const type = typeInfo[1] && typeInfo[1].toLowerCase() || "scalar";
        if (type === "map") {
          return false;
        }
        return validCustomTags.indexOf(type) !== -1;
      }
      return false;
    });
  }
  function isArrayEqual(fst, snd) {
    if (!snd || !fst) {
      return false;
    }
    if (snd.length !== fst.length) {
      return false;
    }
    for (let index = fst.length - 1; index >= 0; index--) {
      if (fst[index] !== snd[index]) {
        return false;
      }
    }
    return true;
  }
  var localize7 = loadMessageBundle();
  var MSG_PROPERTY_NOT_ALLOWED = "Property {0} is not allowed.";
  var formats2 = {
    "color-hex": {
      errorMessage: localize7("colorHexFormatWarning", "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA."),
      pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/
    },
    "date-time": {
      errorMessage: localize7("dateTimeFormatWarning", "String is not a RFC3339 date-time."),
      pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
    },
    date: {
      errorMessage: localize7("dateFormatWarning", "String is not a RFC3339 date."),
      pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i
    },
    time: {
      errorMessage: localize7("timeFormatWarning", "String is not a RFC3339 time."),
      pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
    },
    email: {
      errorMessage: localize7("emailFormatWarning", "String is not an e-mail address."),
      pattern: /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
    }
  };
  var YAML_SOURCE = "YAML";
  var YAML_SCHEMA_PREFIX = "yaml-schema: ";
  var ProblemType;
  (function(ProblemType2) {
    ProblemType2["missingRequiredPropWarning"] = "missingRequiredPropWarning";
    ProblemType2["typeMismatchWarning"] = "typeMismatchWarning";
    ProblemType2["constWarning"] = "constWarning";
  })(ProblemType || (ProblemType = {}));
  var ProblemTypeMessages = {
    [ProblemType.missingRequiredPropWarning]: 'Missing property "{0}".',
    [ProblemType.typeMismatchWarning]: 'Incorrect type. Expected "{0}".',
    [ProblemType.constWarning]: "Value must be {0}."
  };
  var ASTNodeImpl2 = class {
    constructor(parent, internalNode, offset, length) {
      this.offset = offset;
      this.length = length;
      this.parent = parent;
      this.internalNode = internalNode;
    }
    getNodeFromOffsetEndInclusive(offset) {
      const collector = [];
      const findNode2 = (node) => {
        if (offset >= node.offset && offset <= node.offset + node.length) {
          const children = node.children;
          for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
            const item = findNode2(children[i]);
            if (item) {
              collector.push(item);
            }
          }
          return node;
        }
        return null;
      };
      const foundNode = findNode2(this);
      let currMinDist = Number.MAX_VALUE;
      let currMinNode = null;
      for (const currNode of collector) {
        const minDist = currNode.length + currNode.offset - offset + (offset - currNode.offset);
        if (minDist < currMinDist) {
          currMinNode = currNode;
          currMinDist = minDist;
        }
      }
      return currMinNode || foundNode;
    }
    get children() {
      return [];
    }
    toString() {
      return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : "");
    }
  };
  var NullASTNodeImpl2 = class extends ASTNodeImpl2 {
    constructor(parent, internalNode, offset, length) {
      super(parent, internalNode, offset, length);
      this.type = "null";
      this.value = null;
    }
  };
  var BooleanASTNodeImpl2 = class extends ASTNodeImpl2 {
    constructor(parent, internalNode, boolValue, offset, length) {
      super(parent, internalNode, offset, length);
      this.type = "boolean";
      this.value = boolValue;
    }
  };
  var ArrayASTNodeImpl2 = class extends ASTNodeImpl2 {
    constructor(parent, internalNode, offset, length) {
      super(parent, internalNode, offset, length);
      this.type = "array";
      this.items = [];
    }
    get children() {
      return this.items;
    }
  };
  var NumberASTNodeImpl2 = class extends ASTNodeImpl2 {
    constructor(parent, internalNode, offset, length) {
      super(parent, internalNode, offset, length);
      this.type = "number";
      this.isInteger = true;
      this.value = Number.NaN;
    }
  };
  var StringASTNodeImpl2 = class extends ASTNodeImpl2 {
    constructor(parent, internalNode, offset, length) {
      super(parent, internalNode, offset, length);
      this.type = "string";
      this.value = "";
    }
  };
  var PropertyASTNodeImpl2 = class extends ASTNodeImpl2 {
    constructor(parent, internalNode, offset, length) {
      super(parent, internalNode, offset, length);
      this.type = "property";
      this.colonOffset = -1;
    }
    get children() {
      return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
    }
  };
  var ObjectASTNodeImpl2 = class extends ASTNodeImpl2 {
    constructor(parent, internalNode, offset, length) {
      super(parent, internalNode, offset, length);
      this.type = "object";
      this.properties = [];
    }
    get children() {
      return this.properties;
    }
  };
  function asSchema2(schema5) {
    if (schema5 === void 0) {
      return void 0;
    }
    if (isBoolean2(schema5)) {
      return schema5 ? {} : { not: {} };
    }
    if (typeof schema5 !== "object") {
      console.warn(`Wrong schema: ${JSON.stringify(schema5)}, it MUST be an Object or Boolean`);
      schema5 = {
        type: schema5
      };
    }
    return schema5;
  }
  var EnumMatch2;
  (function(EnumMatch3) {
    EnumMatch3[EnumMatch3["Key"] = 0] = "Key";
    EnumMatch3[EnumMatch3["Enum"] = 1] = "Enum";
  })(EnumMatch2 || (EnumMatch2 = {}));
  var SchemaCollector2 = class {
    constructor(focusOffset = -1, exclude = null) {
      this.focusOffset = focusOffset;
      this.exclude = exclude;
      this.schemas = [];
    }
    add(schema5) {
      this.schemas.push(schema5);
    }
    merge(other) {
      this.schemas.push(...other.schemas);
    }
    include(node) {
      return (this.focusOffset === -1 || contains22(node, this.focusOffset)) && node !== this.exclude;
    }
    newSub() {
      return new SchemaCollector2(-1, this.exclude);
    }
  };
  var NoOpSchemaCollector2 = class {
    constructor() {
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get schemas() {
      return [];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    add(schema5) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    merge(other) {
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    include(node) {
      return true;
    }
    newSub() {
      return this;
    }
  };
  NoOpSchemaCollector2.instance = new NoOpSchemaCollector2();
  var ValidationResult2 = class {
    constructor(isKubernetes) {
      this.problems = [];
      this.propertiesMatches = 0;
      this.propertiesValueMatches = 0;
      this.primaryValueMatches = 0;
      this.enumValueMatch = false;
      if (isKubernetes) {
        this.enumValues = [];
      } else {
        this.enumValues = null;
      }
    }
    hasProblems() {
      return !!this.problems.length;
    }
    mergeAll(validationResults) {
      for (const validationResult of validationResults) {
        this.merge(validationResult);
      }
    }
    merge(validationResult) {
      this.problems = this.problems.concat(validationResult.problems);
    }
    mergeEnumValues(validationResult) {
      if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
        this.enumValues = this.enumValues.concat(validationResult.enumValues);
        for (const error of this.problems) {
          if (error.code === ErrorCode.EnumValueMismatch) {
            error.message = localize7("enumWarning", "Value is not accepted. Valid values: {0}.", [...new Set(this.enumValues)].map((v) => {
              return JSON.stringify(v);
            }).join(", "));
          }
        }
      }
    }
    /**
     * Merge multiple warnings with same problemType together
     * @param subValidationResult another possible result
     */
    mergeWarningGeneric(subValidationResult, problemTypesToMerge) {
      var _a3, _b;
      if ((_a3 = this.problems) == null ? void 0 : _a3.length) {
        for (const problemType of problemTypesToMerge) {
          const bestResults = this.problems.filter((p) => p.problemType === problemType);
          for (const bestResult of bestResults) {
            const mergingResult = (_b = subValidationResult.problems) == null ? void 0 : _b.find(
              (p) => p.problemType === problemType && bestResult.location.offset === p.location.offset && (problemType !== ProblemType.missingRequiredPropWarning || isArrayEqual(p.problemArgs, bestResult.problemArgs))
            );
            if (mergingResult) {
              if (mergingResult.problemArgs.length) {
                mergingResult.problemArgs.filter((p) => !bestResult.problemArgs.includes(p)).forEach((p) => bestResult.problemArgs.push(p));
                bestResult.message = getWarningMessage(bestResult.problemType, bestResult.problemArgs);
              }
              this.mergeSources(mergingResult, bestResult);
            }
          }
        }
      }
    }
    mergePropertyMatch(propertyValidationResult) {
      this.merge(propertyValidationResult);
      this.propertiesMatches++;
      if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
        this.propertiesValueMatches++;
      }
      if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues) {
        this.primaryValueMatches++;
      }
    }
    mergeSources(mergingResult, bestResult) {
      const mergingSource = mergingResult.source.replace(YAML_SCHEMA_PREFIX, "");
      if (!bestResult.source.includes(mergingSource)) {
        bestResult.source = bestResult.source + " | " + mergingSource;
      }
      if (!bestResult.schemaUri.includes(mergingResult.schemaUri[0])) {
        bestResult.schemaUri = bestResult.schemaUri.concat(mergingResult.schemaUri);
      }
    }
    compareGeneric(other) {
      const hasProblems = this.hasProblems();
      if (hasProblems !== other.hasProblems()) {
        return hasProblems ? -1 : 1;
      }
      if (this.enumValueMatch !== other.enumValueMatch) {
        return other.enumValueMatch ? -1 : 1;
      }
      if (this.propertiesValueMatches !== other.propertiesValueMatches) {
        return this.propertiesValueMatches - other.propertiesValueMatches;
      }
      if (this.primaryValueMatches !== other.primaryValueMatches) {
        return this.primaryValueMatches - other.primaryValueMatches;
      }
      return this.propertiesMatches - other.propertiesMatches;
    }
    compareKubernetes(other) {
      const hasProblems = this.hasProblems();
      if (this.propertiesMatches !== other.propertiesMatches) {
        return this.propertiesMatches - other.propertiesMatches;
      }
      if (this.enumValueMatch !== other.enumValueMatch) {
        return other.enumValueMatch ? -1 : 1;
      }
      if (this.primaryValueMatches !== other.primaryValueMatches) {
        return this.primaryValueMatches - other.primaryValueMatches;
      }
      if (this.propertiesValueMatches !== other.propertiesValueMatches) {
        return this.propertiesValueMatches - other.propertiesValueMatches;
      }
      if (hasProblems !== other.hasProblems()) {
        return hasProblems ? -1 : 1;
      }
      return this.propertiesMatches - other.propertiesMatches;
    }
  };
  function getNodeValue3(node) {
    switch (node.type) {
      case "array":
        return node.children.map(getNodeValue3);
      case "object": {
        const obj = /* @__PURE__ */ Object.create(null);
        for (let _i = 0, _a3 = node.children; _i < _a3.length; _i++) {
          const prop = _a3[_i];
          const valueNode = prop.children[1];
          if (valueNode) {
            obj[prop.children[0].value] = getNodeValue3(valueNode);
          }
        }
        return obj;
      }
      case "null":
      case "string":
      case "number":
      case "boolean":
        return node.value;
      default:
        return void 0;
    }
  }
  function contains22(node, offset, includeRightBound = false) {
    return offset >= node.offset && offset <= node.offset + node.length || includeRightBound && offset === node.offset + node.length;
  }
  function findNodeAtOffset22(node, offset, includeRightBound) {
    if (includeRightBound === void 0) {
      includeRightBound = false;
    }
    if (contains22(node, offset, includeRightBound)) {
      const children = node.children;
      if (Array.isArray(children)) {
        for (let i = 0; i < children.length && children[i].offset <= offset; i++) {
          const item = findNodeAtOffset22(children[i], offset, includeRightBound);
          if (item) {
            return item;
          }
        }
      }
      return node;
    }
    return void 0;
  }
  var JSONDocument2 = class {
    constructor(root, syntaxErrors = [], comments = []) {
      this.root = root;
      this.syntaxErrors = syntaxErrors;
      this.comments = comments;
    }
    getNodeFromOffset(offset, includeRightBound = false) {
      if (this.root) {
        return findNodeAtOffset22(this.root, offset, includeRightBound);
      }
      return void 0;
    }
    getNodeFromOffsetEndInclusive(offset) {
      return this.root && this.root.getNodeFromOffsetEndInclusive(offset);
    }
    visit(visitor) {
      if (this.root) {
        const doVisit = (node) => {
          let ctn = visitor(node);
          const children = node.children;
          if (Array.isArray(children)) {
            for (let i = 0; i < children.length && ctn; i++) {
              ctn = doVisit(children[i]);
            }
          }
          return ctn;
        };
        doVisit(this.root);
      }
    }
    validate(textDocument, schema5) {
      if (this.root && schema5) {
        const validationResult = new ValidationResult2(this.isKubernetes);
        validate2(this.root, schema5, schema5, validationResult, NoOpSchemaCollector2.instance, {
          isKubernetes: this.isKubernetes,
          disableAdditionalProperties: this.disableAdditionalProperties,
          uri: this.uri
        });
        return validationResult.problems.map((p) => {
          const range = Range2.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
          const diagnostic = Diagnostic.create(range, p.message, p.severity, p.code ? p.code : ErrorCode.Undefined, p.source);
          diagnostic.data = { schemaUri: p.schemaUri, ...p.data };
          return diagnostic;
        });
      }
      return null;
    }
    /**
     * This method returns the list of applicable schemas
     *
     * currently used @param didCallFromAutoComplete flag to differentiate the method call, when it is from auto complete
     * then user still types something and skip the validation for timebeing untill completed.
     * On https://github.com/redhat-developer/yaml-language-server/pull/719 the auto completes need to populate the list of enum string which matches to the enum
     * and on https://github.com/redhat-developer/vscode-yaml/issues/803 the validation should throw the error based on the enum string.
     *
     * @param schema schema
     * @param focusOffset  offsetValue
     * @param exclude excluded Node
     * @param didCallFromAutoComplete true if method called from AutoComplete
     * @returns array of applicable schemas
     */
    getMatchingSchemas(schema5, focusOffset = -1, exclude = null, didCallFromAutoComplete) {
      const matchingSchemas = new SchemaCollector2(focusOffset, exclude);
      if (this.root && schema5) {
        validate2(this.root, schema5, schema5, new ValidationResult2(this.isKubernetes), matchingSchemas, {
          isKubernetes: this.isKubernetes,
          disableAdditionalProperties: this.disableAdditionalProperties,
          uri: this.uri,
          callFromAutoComplete: didCallFromAutoComplete
        });
      }
      return matchingSchemas.schemas;
    }
  };
  function validate2(node, schema5, originalSchema, validationResult, matchingSchemas, options) {
    const { isKubernetes, callFromAutoComplete } = options;
    if (!node) {
      return;
    }
    if (typeof schema5 !== "object") {
      return;
    }
    if (!schema5.url) {
      schema5.url = originalSchema.url;
    }
    schema5.closestTitle = schema5.title || originalSchema.closestTitle;
    switch (node.type) {
      case "object":
        _validateObjectNode(node, schema5, validationResult, matchingSchemas);
        break;
      case "array":
        _validateArrayNode(node, schema5, validationResult, matchingSchemas);
        break;
      case "string":
        _validateStringNode(node, schema5, validationResult);
        break;
      case "number":
        _validateNumberNode(node, schema5, validationResult);
        break;
      case "property":
        return validate2(node.valueNode, schema5, schema5, validationResult, matchingSchemas, options);
    }
    _validateNode();
    matchingSchemas.add({ node, schema: schema5 });
    function _validateNode() {
      function matchesType(type) {
        return node.type === type || type === "integer" && node.type === "number" && node.isInteger;
      }
      if (Array.isArray(schema5.type)) {
        if (!schema5.type.some(matchesType)) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            severity: DiagnosticSeverity.Warning,
            message: schema5.errorMessage || localize7("typeArrayMismatchWarning", "Incorrect type. Expected one of {0}.", schema5.type.join(", ")),
            source: getSchemaSource(schema5, originalSchema),
            schemaUri: getSchemaUri(schema5, originalSchema)
          });
        }
      } else if (schema5.type) {
        if (!matchesType(schema5.type)) {
          const schemaType = schema5.type === "object" ? getSchemaTypeName(schema5) : schema5.type;
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            severity: DiagnosticSeverity.Warning,
            message: schema5.errorMessage || getWarningMessage(ProblemType.typeMismatchWarning, [schemaType]),
            source: getSchemaSource(schema5, originalSchema),
            schemaUri: getSchemaUri(schema5, originalSchema),
            problemType: ProblemType.typeMismatchWarning,
            problemArgs: [schemaType]
          });
        }
      }
      if (Array.isArray(schema5.allOf)) {
        for (const subSchemaRef of schema5.allOf) {
          validate2(node, asSchema2(subSchemaRef), schema5, validationResult, matchingSchemas, options);
        }
      }
      const notSchema = asSchema2(schema5.not);
      if (notSchema) {
        const subValidationResult = new ValidationResult2(isKubernetes);
        const subMatchingSchemas = matchingSchemas.newSub();
        validate2(node, notSchema, schema5, subValidationResult, subMatchingSchemas, options);
        if (!subValidationResult.hasProblems()) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            severity: DiagnosticSeverity.Warning,
            message: localize7("notSchemaWarning", "Matches a schema that is not allowed."),
            source: getSchemaSource(schema5, originalSchema),
            schemaUri: getSchemaUri(schema5, originalSchema)
          });
        }
        for (const ms of subMatchingSchemas.schemas) {
          ms.inverted = !ms.inverted;
          matchingSchemas.add(ms);
        }
      }
      const testAlternatives = (alternatives, maxOneMatch) => {
        const matches = [];
        const subMatches = [];
        const noPropertyMatches = [];
        let bestMatch = null;
        for (const subSchemaRef of alternatives) {
          const subSchema = { ...asSchema2(subSchemaRef) };
          const subValidationResult = new ValidationResult2(isKubernetes);
          const subMatchingSchemas = matchingSchemas.newSub();
          validate2(node, subSchema, schema5, subValidationResult, subMatchingSchemas, options);
          if (!subValidationResult.hasProblems() || callFromAutoComplete) {
            matches.push(subSchema);
            subMatches.push(subSchema);
            if (subValidationResult.propertiesMatches === 0) {
              noPropertyMatches.push(subSchema);
            }
            if (subSchema.format) {
              subMatches.pop();
            }
          }
          if (!bestMatch) {
            bestMatch = {
              schema: subSchema,
              validationResult: subValidationResult,
              matchingSchemas: subMatchingSchemas
            };
          } else if (isKubernetes) {
            bestMatch = alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas);
          } else {
            bestMatch = genericComparison(node, maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas);
          }
        }
        if (subMatches.length > 1 && (subMatches.length > 1 || noPropertyMatches.length === 0) && maxOneMatch) {
          validationResult.problems.push({
            location: { offset: node.offset, length: 1 },
            severity: DiagnosticSeverity.Warning,
            message: localize7("oneOfWarning", "Matches multiple schemas when only one must validate."),
            source: getSchemaSource(schema5, originalSchema),
            schemaUri: getSchemaUri(schema5, originalSchema)
          });
        }
        if (bestMatch !== null) {
          validationResult.merge(bestMatch.validationResult);
          validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;
          validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;
          matchingSchemas.merge(bestMatch.matchingSchemas);
        }
        return matches.length;
      };
      if (Array.isArray(schema5.anyOf)) {
        testAlternatives(schema5.anyOf, false);
      }
      if (Array.isArray(schema5.oneOf)) {
        testAlternatives(schema5.oneOf, true);
      }
      const testBranch = (schema22, originalSchema2) => {
        const subValidationResult = new ValidationResult2(isKubernetes);
        const subMatchingSchemas = matchingSchemas.newSub();
        validate2(node, asSchema2(schema22), originalSchema2, subValidationResult, subMatchingSchemas, options);
        validationResult.merge(subValidationResult);
        validationResult.propertiesMatches += subValidationResult.propertiesMatches;
        validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
        matchingSchemas.merge(subMatchingSchemas);
      };
      const testCondition = (ifSchema2, originalSchema2, thenSchema, elseSchema) => {
        const subSchema = asSchema2(ifSchema2);
        const subValidationResult = new ValidationResult2(isKubernetes);
        const subMatchingSchemas = matchingSchemas.newSub();
        validate2(node, subSchema, originalSchema2, subValidationResult, subMatchingSchemas, options);
        matchingSchemas.merge(subMatchingSchemas);
        const { filePatternAssociation } = subSchema;
        if (filePatternAssociation) {
          const association = new FilePatternAssociation2(filePatternAssociation);
          if (!association.matchesPattern(options.uri)) {
            subValidationResult.problems.push({
              location: { offset: node.offset, length: node.length },
              severity: DiagnosticSeverity.Warning,
              message: localize7("ifFilePatternAssociation", `filePatternAssociation '${filePatternAssociation}' does not match with doc uri '${options.uri}'.`),
              source: getSchemaSource(schema5, originalSchema2),
              schemaUri: getSchemaUri(schema5, originalSchema2)
            });
          }
        }
        if (!subValidationResult.hasProblems()) {
          if (thenSchema) {
            testBranch(thenSchema, originalSchema2);
          }
        } else if (elseSchema) {
          testBranch(elseSchema, originalSchema2);
        }
      };
      const ifSchema = asSchema2(schema5.if);
      if (ifSchema) {
        testCondition(ifSchema, schema5, asSchema2(schema5.then), asSchema2(schema5.else));
      }
      if (Array.isArray(schema5.enum)) {
        const val = getNodeValue3(node);
        let enumValueMatch = false;
        for (const e of schema5.enum) {
          if (equals22(val, e) || callFromAutoComplete && isString22(val) && isString22(e) && val && e.startsWith(val)) {
            enumValueMatch = true;
            break;
          }
        }
        validationResult.enumValues = schema5.enum;
        validationResult.enumValueMatch = enumValueMatch;
        if (!enumValueMatch) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            severity: DiagnosticSeverity.Warning,
            code: ErrorCode.EnumValueMismatch,
            message: schema5.errorMessage || localize7("enumWarning", "Value is not accepted. Valid values: {0}.", schema5.enum.map((v) => {
              return JSON.stringify(v);
            }).join(", ")),
            source: getSchemaSource(schema5, originalSchema),
            schemaUri: getSchemaUri(schema5, originalSchema)
          });
        }
      }
      if (isDefined2(schema5.const)) {
        const val = getNodeValue3(node);
        if (!equals22(val, schema5.const)) {
          validationResult.problems.push({
            location: { offset: node.offset, length: node.length },
            severity: DiagnosticSeverity.Warning,
            code: ErrorCode.EnumValueMismatch,
            problemType: ProblemType.constWarning,
            message: schema5.errorMessage || getWarningMessage(ProblemType.constWarning, [JSON.stringify(schema5.const)]),
            source: getSchemaSource(schema5, originalSchema),
            schemaUri: getSchemaUri(schema5, originalSchema),
            problemArgs: [JSON.stringify(schema5.const)]
          });
          validationResult.enumValueMatch = false;
        } else {
          validationResult.enumValueMatch = true;
        }
        validationResult.enumValues = [schema5.const];
      }
      if (schema5.deprecationMessage && node.parent) {
        validationResult.problems.push({
          location: { offset: node.parent.offset, length: node.parent.length },
          severity: DiagnosticSeverity.Warning,
          message: schema5.deprecationMessage,
          source: getSchemaSource(schema5, originalSchema),
          schemaUri: getSchemaUri(schema5, originalSchema)
        });
      }
    }
    function _validateNumberNode(node2, schema22, validationResult2) {
      const val = node2.value;
      if (isNumber2(schema22.multipleOf)) {
        if (val % schema22.multipleOf !== 0) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            severity: DiagnosticSeverity.Warning,
            message: localize7("multipleOfWarning", "Value is not divisible by {0}.", schema22.multipleOf),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema)
          });
        }
      }
      function getExclusiveLimit(limit, exclusive) {
        if (isNumber2(exclusive)) {
          return exclusive;
        }
        if (isBoolean2(exclusive) && exclusive) {
          return limit;
        }
        return void 0;
      }
      function getLimit(limit, exclusive) {
        if (!isBoolean2(exclusive) || !exclusive) {
          return limit;
        }
        return void 0;
      }
      const exclusiveMinimum = getExclusiveLimit(schema22.minimum, schema22.exclusiveMinimum);
      if (isNumber2(exclusiveMinimum) && val <= exclusiveMinimum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("exclusiveMinimumWarning", "Value is below the exclusive minimum of {0}.", exclusiveMinimum),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
      const exclusiveMaximum = getExclusiveLimit(schema22.maximum, schema22.exclusiveMaximum);
      if (isNumber2(exclusiveMaximum) && val >= exclusiveMaximum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("exclusiveMaximumWarning", "Value is above the exclusive maximum of {0}.", exclusiveMaximum),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
      const minimum = getLimit(schema22.minimum, schema22.exclusiveMinimum);
      if (isNumber2(minimum) && val < minimum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("minimumWarning", "Value is below the minimum of {0}.", minimum),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
      const maximum = getLimit(schema22.maximum, schema22.exclusiveMaximum);
      if (isNumber2(maximum) && val > maximum) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("maximumWarning", "Value is above the maximum of {0}.", maximum),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
    }
    function _validateStringNode(node2, schema22, validationResult2) {
      if (isNumber2(schema22.minLength) && node2.value.length < schema22.minLength) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("minLengthWarning", "String is shorter than the minimum length of {0}.", schema22.minLength),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
      if (isNumber2(schema22.maxLength) && node2.value.length > schema22.maxLength) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("maxLengthWarning", "String is longer than the maximum length of {0}.", schema22.maxLength),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
      if (isString22(schema22.pattern)) {
        const regex = safeCreateUnicodeRegExp(schema22.pattern);
        if (!regex.test(node2.value)) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            severity: DiagnosticSeverity.Warning,
            message: schema22.patternErrorMessage || schema22.errorMessage || localize7("patternWarning", 'String does not match the pattern of "{0}".', schema22.pattern),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema)
          });
        }
      }
      if (schema22.format) {
        switch (schema22.format) {
          case "uri":
          case "uri-reference":
            {
              let errorMessage;
              if (!node2.value) {
                errorMessage = localize7("uriEmpty", "URI expected.");
              } else {
                try {
                  const uri = URI2.parse(node2.value);
                  if (!uri.scheme && schema22.format === "uri") {
                    errorMessage = localize7("uriSchemeMissing", "URI with a scheme is expected.");
                  }
                } catch (e) {
                  errorMessage = e.message;
                }
              }
              if (errorMessage) {
                validationResult2.problems.push({
                  location: { offset: node2.offset, length: node2.length },
                  severity: DiagnosticSeverity.Warning,
                  message: schema22.patternErrorMessage || schema22.errorMessage || localize7("uriFormatWarning", "String is not a URI: {0}", errorMessage),
                  source: getSchemaSource(schema22, originalSchema),
                  schemaUri: getSchemaUri(schema22, originalSchema)
                });
              }
            }
            break;
          case "color-hex":
          case "date-time":
          case "date":
          case "time":
          case "email":
            {
              const format32 = formats2[schema22.format];
              if (!node2.value || !format32.pattern.exec(node2.value)) {
                validationResult2.problems.push({
                  location: { offset: node2.offset, length: node2.length },
                  severity: DiagnosticSeverity.Warning,
                  message: schema22.patternErrorMessage || schema22.errorMessage || format32.errorMessage,
                  source: getSchemaSource(schema22, originalSchema),
                  schemaUri: getSchemaUri(schema22, originalSchema)
                });
              }
            }
            break;
          default:
        }
      }
    }
    function _validateArrayNode(node2, schema22, validationResult2, matchingSchemas2) {
      if (Array.isArray(schema22.items)) {
        const subSchemas = schema22.items;
        for (let index = 0; index < subSchemas.length; index++) {
          const subSchemaRef = subSchemas[index];
          const subSchema = asSchema2(subSchemaRef);
          const itemValidationResult = new ValidationResult2(isKubernetes);
          const item = node2.items[index];
          if (item) {
            validate2(item, subSchema, schema22, itemValidationResult, matchingSchemas2, options);
            validationResult2.mergePropertyMatch(itemValidationResult);
            validationResult2.mergeEnumValues(itemValidationResult);
          } else if (node2.items.length >= subSchemas.length) {
            validationResult2.propertiesValueMatches++;
          }
        }
        if (node2.items.length > subSchemas.length) {
          if (typeof schema22.additionalItems === "object") {
            for (let i = subSchemas.length; i < node2.items.length; i++) {
              const itemValidationResult = new ValidationResult2(isKubernetes);
              validate2(node2.items[i], schema22.additionalItems, schema22, itemValidationResult, matchingSchemas2, options);
              validationResult2.mergePropertyMatch(itemValidationResult);
              validationResult2.mergeEnumValues(itemValidationResult);
            }
          } else if (schema22.additionalItems === false) {
            validationResult2.problems.push({
              location: { offset: node2.offset, length: node2.length },
              severity: DiagnosticSeverity.Warning,
              message: localize7("additionalItemsWarning", "Array has too many items according to schema. Expected {0} or fewer.", subSchemas.length),
              source: getSchemaSource(schema22, originalSchema),
              schemaUri: getSchemaUri(schema22, originalSchema)
            });
          }
        }
      } else {
        const itemSchema = asSchema2(schema22.items);
        if (itemSchema) {
          const itemValidationResult = new ValidationResult2(isKubernetes);
          node2.items.forEach((item) => {
            if (itemSchema.oneOf && itemSchema.oneOf.length === 1) {
              const subSchemaRef = itemSchema.oneOf[0];
              const subSchema = { ...asSchema2(subSchemaRef) };
              subSchema.title = schema22.title;
              subSchema.closestTitle = schema22.closestTitle;
              validate2(item, subSchema, schema22, itemValidationResult, matchingSchemas2, options);
              validationResult2.mergePropertyMatch(itemValidationResult);
              validationResult2.mergeEnumValues(itemValidationResult);
            } else {
              validate2(item, itemSchema, schema22, itemValidationResult, matchingSchemas2, options);
              validationResult2.mergePropertyMatch(itemValidationResult);
              validationResult2.mergeEnumValues(itemValidationResult);
            }
          });
        }
      }
      const containsSchema = asSchema2(schema22.contains);
      if (containsSchema) {
        const doesContain = node2.items.some((item) => {
          const itemValidationResult = new ValidationResult2(isKubernetes);
          validate2(item, containsSchema, schema22, itemValidationResult, NoOpSchemaCollector2.instance, options);
          return !itemValidationResult.hasProblems();
        });
        if (!doesContain) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            severity: DiagnosticSeverity.Warning,
            message: schema22.errorMessage || localize7("requiredItemMissingWarning", "Array does not contain required item."),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema)
          });
        }
      }
      if (isNumber2(schema22.minItems) && node2.items.length < schema22.minItems) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("minItemsWarning", "Array has too few items. Expected {0} or more.", schema22.minItems),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
      if (isNumber2(schema22.maxItems) && node2.items.length > schema22.maxItems) {
        validationResult2.problems.push({
          location: { offset: node2.offset, length: node2.length },
          severity: DiagnosticSeverity.Warning,
          message: localize7("maxItemsWarning", "Array has too many items. Expected {0} or fewer.", schema22.maxItems),
          source: getSchemaSource(schema22, originalSchema),
          schemaUri: getSchemaUri(schema22, originalSchema)
        });
      }
      if (schema22.uniqueItems === true) {
        const values = getNodeValue3(node2);
        const duplicates = values.some((value, index) => {
          return index !== values.lastIndexOf(value);
        });
        if (duplicates) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            severity: DiagnosticSeverity.Warning,
            message: localize7("uniqueItemsWarning", "Array has duplicate items."),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema)
          });
        }
      }
    }
    function _validateObjectNode(node2, schema22, validationResult2, matchingSchemas2) {
      var _a3;
      const seenKeys = /* @__PURE__ */ Object.create(null);
      const unprocessedProperties = [];
      const unprocessedNodes = [...node2.properties];
      while (unprocessedNodes.length > 0) {
        const propertyNode = unprocessedNodes.pop();
        const key = propertyNode.keyNode.value;
        if (key === "<<" && propertyNode.valueNode) {
          switch (propertyNode.valueNode.type) {
            case "object": {
              unprocessedNodes.push(...propertyNode.valueNode["properties"]);
              break;
            }
            case "array": {
              propertyNode.valueNode["items"].forEach((sequenceNode) => {
                if (sequenceNode && isIterable(sequenceNode["properties"])) {
                  unprocessedNodes.push(...sequenceNode["properties"]);
                }
              });
              break;
            }
            default: {
              break;
            }
          }
        } else {
          seenKeys[key] = propertyNode.valueNode;
          unprocessedProperties.push(key);
        }
      }
      if (Array.isArray(schema22.required)) {
        for (const propertyName of schema22.required) {
          if (seenKeys[propertyName] === void 0) {
            const keyNode = node2.parent && node2.parent.type === "property" && node2.parent.keyNode;
            const location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node2.offset, length: 1 };
            validationResult2.problems.push({
              location,
              severity: DiagnosticSeverity.Warning,
              message: getWarningMessage(ProblemType.missingRequiredPropWarning, [propertyName]),
              source: getSchemaSource(schema22, originalSchema),
              schemaUri: getSchemaUri(schema22, originalSchema),
              problemArgs: [propertyName],
              problemType: ProblemType.missingRequiredPropWarning
            });
          }
        }
      }
      const propertyProcessed = (prop) => {
        let index = unprocessedProperties.indexOf(prop);
        while (index >= 0) {
          unprocessedProperties.splice(index, 1);
          index = unprocessedProperties.indexOf(prop);
        }
      };
      if (schema22.properties) {
        for (const propertyName of Object.keys(schema22.properties)) {
          propertyProcessed(propertyName);
          const propertySchema = schema22.properties[propertyName];
          const child = seenKeys[propertyName];
          if (child) {
            if (isBoolean2(propertySchema)) {
              if (!propertySchema) {
                const propertyNode = child.parent;
                validationResult2.problems.push({
                  location: {
                    offset: propertyNode.keyNode.offset,
                    length: propertyNode.keyNode.length
                  },
                  severity: DiagnosticSeverity.Warning,
                  message: schema22.errorMessage || localize7("DisallowedExtraPropWarning", MSG_PROPERTY_NOT_ALLOWED, propertyName),
                  source: getSchemaSource(schema22, originalSchema),
                  schemaUri: getSchemaUri(schema22, originalSchema)
                });
              } else {
                validationResult2.propertiesMatches++;
                validationResult2.propertiesValueMatches++;
              }
            } else {
              propertySchema.url = (_a3 = schema22.url) != null ? _a3 : originalSchema.url;
              const propertyValidationResult = new ValidationResult2(isKubernetes);
              validate2(child, propertySchema, schema22, propertyValidationResult, matchingSchemas2, options);
              validationResult2.mergePropertyMatch(propertyValidationResult);
              validationResult2.mergeEnumValues(propertyValidationResult);
            }
          }
        }
      }
      if (schema22.patternProperties) {
        for (const propertyPattern of Object.keys(schema22.patternProperties)) {
          const regex = safeCreateUnicodeRegExp(propertyPattern);
          for (const propertyName of unprocessedProperties.slice(0)) {
            if (regex.test(propertyName)) {
              propertyProcessed(propertyName);
              const child = seenKeys[propertyName];
              if (child) {
                const propertySchema = schema22.patternProperties[propertyPattern];
                if (isBoolean2(propertySchema)) {
                  if (!propertySchema) {
                    const propertyNode = child.parent;
                    validationResult2.problems.push({
                      location: {
                        offset: propertyNode.keyNode.offset,
                        length: propertyNode.keyNode.length
                      },
                      severity: DiagnosticSeverity.Warning,
                      message: schema22.errorMessage || localize7("DisallowedExtraPropWarning", MSG_PROPERTY_NOT_ALLOWED, propertyName),
                      source: getSchemaSource(schema22, originalSchema),
                      schemaUri: getSchemaUri(schema22, originalSchema)
                    });
                  } else {
                    validationResult2.propertiesMatches++;
                    validationResult2.propertiesValueMatches++;
                  }
                } else {
                  const propertyValidationResult = new ValidationResult2(isKubernetes);
                  validate2(child, propertySchema, schema22, propertyValidationResult, matchingSchemas2, options);
                  validationResult2.mergePropertyMatch(propertyValidationResult);
                  validationResult2.mergeEnumValues(propertyValidationResult);
                }
              }
            }
          }
        }
      }
      if (typeof schema22.additionalProperties === "object") {
        for (const propertyName of unprocessedProperties) {
          const child = seenKeys[propertyName];
          if (child) {
            const propertyValidationResult = new ValidationResult2(isKubernetes);
            validate2(child, schema22.additionalProperties, schema22, propertyValidationResult, matchingSchemas2, options);
            validationResult2.mergePropertyMatch(propertyValidationResult);
            validationResult2.mergeEnumValues(propertyValidationResult);
          }
        }
      } else if (schema22.additionalProperties === false || schema22.type === "object" && schema22.additionalProperties === void 0 && options.disableAdditionalProperties === true) {
        if (unprocessedProperties.length > 0) {
          const possibleProperties = schema22.properties && Object.keys(schema22.properties).filter((prop) => !seenKeys[prop]);
          for (const propertyName of unprocessedProperties) {
            const child = seenKeys[propertyName];
            if (child) {
              let propertyNode = null;
              if (child.type !== "property") {
                propertyNode = child.parent;
                if (propertyNode.type === "object") {
                  propertyNode = propertyNode.properties[0];
                }
              } else {
                propertyNode = child;
              }
              const problem = {
                location: {
                  offset: propertyNode.keyNode.offset,
                  length: propertyNode.keyNode.length
                },
                severity: DiagnosticSeverity.Warning,
                message: schema22.errorMessage || localize7("DisallowedExtraPropWarning", MSG_PROPERTY_NOT_ALLOWED, propertyName),
                source: getSchemaSource(schema22, originalSchema),
                schemaUri: getSchemaUri(schema22, originalSchema)
              };
              if (possibleProperties == null ? void 0 : possibleProperties.length) {
                problem.data = { properties: possibleProperties };
              }
              validationResult2.problems.push(problem);
            }
          }
        }
      }
      if (isNumber2(schema22.maxProperties)) {
        if (node2.properties.length > schema22.maxProperties) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            severity: DiagnosticSeverity.Warning,
            message: localize7("MaxPropWarning", "Object has more properties than limit of {0}.", schema22.maxProperties),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema)
          });
        }
      }
      if (isNumber2(schema22.minProperties)) {
        if (node2.properties.length < schema22.minProperties) {
          validationResult2.problems.push({
            location: { offset: node2.offset, length: node2.length },
            severity: DiagnosticSeverity.Warning,
            message: localize7("MinPropWarning", "Object has fewer properties than the required number of {0}", schema22.minProperties),
            source: getSchemaSource(schema22, originalSchema),
            schemaUri: getSchemaUri(schema22, originalSchema)
          });
        }
      }
      if (schema22.dependencies) {
        for (const key of Object.keys(schema22.dependencies)) {
          const prop = seenKeys[key];
          if (prop) {
            const propertyDep = schema22.dependencies[key];
            if (Array.isArray(propertyDep)) {
              for (const requiredProp of propertyDep) {
                if (!seenKeys[requiredProp]) {
                  validationResult2.problems.push({
                    location: { offset: node2.offset, length: node2.length },
                    severity: DiagnosticSeverity.Warning,
                    message: localize7("RequiredDependentPropWarning", "Object is missing property {0} required by property {1}.", requiredProp, key),
                    source: getSchemaSource(schema22, originalSchema),
                    schemaUri: getSchemaUri(schema22, originalSchema)
                  });
                } else {
                  validationResult2.propertiesValueMatches++;
                }
              }
            } else {
              const propertySchema = asSchema2(propertyDep);
              if (propertySchema) {
                const propertyValidationResult = new ValidationResult2(isKubernetes);
                validate2(node2, propertySchema, schema22, propertyValidationResult, matchingSchemas2, options);
                validationResult2.mergePropertyMatch(propertyValidationResult);
                validationResult2.mergeEnumValues(propertyValidationResult);
              }
            }
          }
        }
      }
      const propertyNames = asSchema2(schema22.propertyNames);
      if (propertyNames) {
        for (const f2 of node2.properties) {
          const key = f2.keyNode;
          if (key) {
            validate2(key, propertyNames, schema22, validationResult2, NoOpSchemaCollector2.instance, options);
          }
        }
      }
    }
    function alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
      const compareResult = subValidationResult.compareKubernetes(bestMatch.validationResult);
      if (compareResult > 0) {
        bestMatch = {
          schema: subSchema,
          validationResult: subValidationResult,
          matchingSchemas: subMatchingSchemas
        };
      } else if (compareResult === 0) {
        bestMatch.matchingSchemas.merge(subMatchingSchemas);
        bestMatch.validationResult.mergeEnumValues(subValidationResult);
      }
      return bestMatch;
    }
    function genericComparison(node2, maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
      if (!maxOneMatch && !subValidationResult.hasProblems() && (!bestMatch.validationResult.hasProblems() || callFromAutoComplete)) {
        bestMatch.matchingSchemas.merge(subMatchingSchemas);
        bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;
        bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
      } else {
        const compareResult = subValidationResult.compareGeneric(bestMatch.validationResult);
        if (compareResult > 0 || compareResult === 0 && maxOneMatch && bestMatch.schema.type === "object" && node2.type !== "null" && node2.type !== bestMatch.schema.type) {
          bestMatch = {
            schema: subSchema,
            validationResult: subValidationResult,
            matchingSchemas: subMatchingSchemas
          };
        } else if (compareResult === 0) {
          bestMatch.matchingSchemas.merge(subMatchingSchemas);
          bestMatch.validationResult.mergeEnumValues(subValidationResult);
          bestMatch.validationResult.mergeWarningGeneric(subValidationResult, [
            ProblemType.missingRequiredPropWarning,
            ProblemType.typeMismatchWarning,
            ProblemType.constWarning
          ]);
        }
      }
      return bestMatch;
    }
  }
  function getSchemaSource(schema5, originalSchema) {
    var _a3;
    if (schema5) {
      let label;
      if (schema5.title) {
        label = schema5.title;
      } else if (schema5.closestTitle) {
        label = schema5.closestTitle;
      } else if (originalSchema.closestTitle) {
        label = originalSchema.closestTitle;
      } else {
        const uriString = (_a3 = schema5.url) != null ? _a3 : originalSchema.url;
        if (uriString) {
          const url = URI2.parse(uriString);
          if (url.scheme === "file") {
            label = url.fsPath;
          }
          label = url.toString();
        }
      }
      if (label) {
        return `${YAML_SCHEMA_PREFIX}${label}`;
      }
    }
    return YAML_SOURCE;
  }
  function getSchemaUri(schema5, originalSchema) {
    var _a3;
    const uriString = (_a3 = schema5.url) != null ? _a3 : originalSchema.url;
    return uriString ? [uriString] : [];
  }
  function getWarningMessage(problemType, args) {
    return localize7(problemType, ProblemTypeMessages[problemType], args.join(" | "));
  }
  var maxRefCount = 1e3;
  var refDepth = 0;
  function convertAST(parent, node, doc, lineCounter) {
    if (!parent) {
      refDepth = 0;
    }
    if (!node) {
      return null;
    }
    if (isMap(node)) {
      return convertMap(node, parent, doc, lineCounter);
    }
    if (isPair(node)) {
      return convertPair(node, parent, doc, lineCounter);
    }
    if (isSeq(node)) {
      return convertSeq(node, parent, doc, lineCounter);
    }
    if (isScalar(node)) {
      return convertScalar(node, parent);
    }
    if (isAlias(node)) {
      if (refDepth > maxRefCount) {
        return;
      }
      return convertAlias(node, parent, doc, lineCounter);
    }
  }
  function convertMap(node, parent, doc, lineCounter) {
    let range;
    if (node.flow && !node.range) {
      range = collectFlowMapRange(node);
    } else {
      range = node.range;
    }
    const result = new ObjectASTNodeImpl2(parent, node, ...toFixedOffsetLength(range, lineCounter));
    for (const it of node.items) {
      if (isPair(it)) {
        result.properties.push(convertAST(result, it, doc, lineCounter));
      }
    }
    return result;
  }
  function convertPair(node, parent, doc, lineCounter) {
    const keyNode = node.key;
    const valueNode = node.value;
    const rangeStart = keyNode.range[0];
    let rangeEnd = keyNode.range[1];
    let nodeEnd = keyNode.range[2];
    if (valueNode) {
      rangeEnd = valueNode.range[1];
      nodeEnd = valueNode.range[2];
    }
    const result = new PropertyASTNodeImpl2(parent, node, ...toFixedOffsetLength([rangeStart, rangeEnd, nodeEnd], lineCounter));
    if (isAlias(keyNode)) {
      const keyAlias = new StringASTNodeImpl2(parent, keyNode, ...toOffsetLength(keyNode.range));
      keyAlias.value = keyNode.source;
      result.keyNode = keyAlias;
    } else {
      result.keyNode = convertAST(result, keyNode, doc, lineCounter);
    }
    result.valueNode = convertAST(result, valueNode, doc, lineCounter);
    return result;
  }
  function convertSeq(node, parent, doc, lineCounter) {
    const result = new ArrayASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
    for (const it of node.items) {
      if (isNode(it)) {
        const convertedNode = convertAST(result, it, doc, lineCounter);
        if (convertedNode) {
          result.children.push(convertedNode);
        }
      }
    }
    return result;
  }
  function convertScalar(node, parent) {
    if (node.value === null) {
      return new NullASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
    }
    switch (typeof node.value) {
      case "string": {
        const result = new StringASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
        result.value = node.value;
        return result;
      }
      case "boolean":
        return new BooleanASTNodeImpl2(parent, node, node.value, ...toOffsetLength(node.range));
      case "number": {
        const result = new NumberASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
        result.value = node.value;
        result.isInteger = Number.isInteger(result.value);
        return result;
      }
      default: {
        const result = new StringASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
        result.value = node.source;
        return result;
      }
    }
  }
  function convertAlias(node, parent, doc, lineCounter) {
    refDepth++;
    const resolvedNode = node.resolve(doc);
    if (resolvedNode) {
      return convertAST(parent, resolvedNode, doc, lineCounter);
    } else {
      const resultNode = new StringASTNodeImpl2(parent, node, ...toOffsetLength(node.range));
      resultNode.value = node.source;
      return resultNode;
    }
  }
  function toOffsetLength(range) {
    return [range[0], range[1] - range[0]];
  }
  function toFixedOffsetLength(range, lineCounter) {
    const start = lineCounter.linePos(range[0]);
    const end = lineCounter.linePos(range[1]);
    const result = [range[0], range[1] - range[0]];
    if (start.line !== end.line && (lineCounter.lineStarts.length !== end.line || end.col === 1)) {
      result[1]--;
    }
    return result;
  }
  function collectFlowMapRange(node) {
    let start = Number.MAX_SAFE_INTEGER;
    let end = 0;
    for (const it of node.items) {
      if (isPair(it)) {
        if (isNode(it.key)) {
          if (it.key.range && it.key.range[0] <= start) {
            start = it.key.range[0];
          }
        }
        if (isNode(it.value)) {
          if (it.value.range && it.value.range[2] >= end) {
            end = it.value.range[2];
          }
        }
      }
    }
    return [start, end, end];
  }
  function getParent(doc, nodeToFind) {
    let parentNode;
    visit2(doc, (_, node, path5) => {
      if (node === nodeToFind) {
        parentNode = path5[path5.length - 1];
        return visit2.BREAK;
      }
    });
    if (isDocument(parentNode)) {
      return void 0;
    }
    return parentNode;
  }
  function isMapContainsEmptyPair(map2) {
    if (map2.items.length > 1) {
      return false;
    }
    const pair = map2.items[0];
    return isScalar(pair.key) && isScalar(pair.value) && pair.key.value === "" && !pair.value.value;
  }
  function indexOf(seq2, item) {
    for (const [i, obj] of seq2.items.entries()) {
      if (item === obj) {
        return i;
      }
    }
    return void 0;
  }
  function isInComment(tokens, offset) {
    let inComment = false;
    for (const token of tokens) {
      if (token.type === "document") {
        _visit2([], token, (item) => {
          var _a3;
          if (isCollectionItem(item) && ((_a3 = item.value) == null ? void 0 : _a3.type) === "comment") {
            if (token.offset <= offset && item.value.source.length + item.value.offset >= offset) {
              inComment = true;
              return visit2.BREAK;
            }
          } else if (item.type === "comment" && item.offset <= offset && item.offset + item.source.length >= offset) {
            inComment = true;
            return visit2.BREAK;
          }
        });
      } else if (token.type === "comment") {
        if (token.offset <= offset && token.source.length + token.offset >= offset) {
          return true;
        }
      }
      if (inComment) {
        break;
      }
    }
    return inComment;
  }
  function isCollectionItem(token) {
    return token["start"] !== void 0;
  }
  function _visit2(path5, item, visitor) {
    let ctrl = visitor(item, path5);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token2 = item[field];
      if (token2 && "items" in token2) {
        for (let i = 0; i < token2.items.length; ++i) {
          const ci = _visit2(Object.freeze(path5.concat([[field, i]])), token2.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === visit2.BREAK)
            return visit2.BREAK;
          else if (ci === visit2.REMOVE) {
            token2.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path5);
      }
    }
    const token = item["sep"];
    if (token) {
      for (let i = 0; i < token.length; ++i) {
        const ci = _visit2(Object.freeze(path5), token[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === visit2.BREAK)
          return visit2.BREAK;
        else if (ci === visit2.REMOVE) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path5) : ctrl;
  }
  var SingleYAMLDocument = class extends JSONDocument2 {
    constructor(lineCounter) {
      super(null, []);
      this.lineCounter = lineCounter;
    }
    /**
     * Create a deep copy of this document
     */
    clone() {
      const copy = new SingleYAMLDocument(this.lineCounter);
      copy.isKubernetes = this.isKubernetes;
      copy.disableAdditionalProperties = this.disableAdditionalProperties;
      copy.uri = this.uri;
      copy.currentDocIndex = this.currentDocIndex;
      copy._lineComments = this.lineComments.slice();
      copy.internalDocument = this._internalDocument.clone();
      return copy;
    }
    collectLineComments() {
      this._lineComments = [];
      if (this._internalDocument.commentBefore) {
        const comments = this._internalDocument.commentBefore.split("\n");
        comments.forEach((comment) => this._lineComments.push(`#${comment}`));
      }
      visit2(this.internalDocument, (_key, node) => {
        if (node == null ? void 0 : node.commentBefore) {
          const comments = node == null ? void 0 : node.commentBefore.split("\n");
          comments.forEach((comment) => this._lineComments.push(`#${comment}`));
        }
        if (node == null ? void 0 : node.comment) {
          this._lineComments.push(`#${node.comment}`);
        }
      });
      if (this._internalDocument.comment) {
        this._lineComments.push(`#${this._internalDocument.comment}`);
      }
    }
    set internalDocument(document2) {
      this._internalDocument = document2;
      this.root = convertAST(null, this._internalDocument.contents, this._internalDocument, this.lineCounter);
    }
    get internalDocument() {
      return this._internalDocument;
    }
    get lineComments() {
      if (!this._lineComments) {
        this.collectLineComments();
      }
      return this._lineComments;
    }
    set lineComments(val) {
      this._lineComments = val;
    }
    get errors() {
      return this.internalDocument.errors.map(YAMLErrorToYamlDocDiagnostics);
    }
    get warnings() {
      return this.internalDocument.warnings.map(YAMLErrorToYamlDocDiagnostics);
    }
    getNodeFromPosition(positionOffset, textBuffer, configuredIndentation) {
      const position = textBuffer.getPosition(positionOffset);
      const lineContent = textBuffer.getLineContent(position.line);
      if (lineContent.trim().length === 0) {
        return [this.findClosestNode(positionOffset, textBuffer, configuredIndentation), true];
      }
      const textAfterPosition = lineContent.substring(position.character);
      const spacesAfterPositionMatch = textAfterPosition.match(/^([ ]+)\n?$/);
      const areOnlySpacesAfterPosition = !!spacesAfterPositionMatch;
      const countOfSpacesAfterPosition = spacesAfterPositionMatch == null ? void 0 : spacesAfterPositionMatch[1].length;
      let closestNode;
      visit2(this.internalDocument, (key, node) => {
        if (!node) {
          return;
        }
        const range = node.range;
        if (!range) {
          return;
        }
        const isNullNodeOnTheLine = () => areOnlySpacesAfterPosition && positionOffset + countOfSpacesAfterPosition === range[2] && isScalar(node) && node.value === null;
        if (range[0] <= positionOffset && range[1] >= positionOffset || isNullNodeOnTheLine()) {
          closestNode = node;
        } else {
          return visit2.SKIP;
        }
      });
      return [closestNode, false];
    }
    findClosestNode(offset, textBuffer, configuredIndentation) {
      let offsetDiff = this.internalDocument.range[2];
      let maxOffset = this.internalDocument.range[0];
      let closestNode;
      visit2(this.internalDocument, (key, node) => {
        if (!node) {
          return;
        }
        const range = node.range;
        if (!range) {
          return;
        }
        const diff = range[1] - offset;
        if (maxOffset <= range[0] && diff <= 0 && Math.abs(diff) <= offsetDiff) {
          offsetDiff = Math.abs(diff);
          maxOffset = range[0];
          closestNode = node;
        }
      });
      const position = textBuffer.getPosition(offset);
      const lineContent = textBuffer.getLineContent(position.line);
      const indentation = getIndentation2(lineContent, position.character);
      if (isScalar(closestNode) && closestNode.value === null) {
        return closestNode;
      }
      if (indentation === position.character) {
        closestNode = this.getProperParentByIndentation(indentation, closestNode, textBuffer, "", configuredIndentation);
      }
      return closestNode;
    }
    getProperParentByIndentation(indentation, node, textBuffer, currentLine, configuredIndentation, rootParent) {
      if (!node) {
        return this.internalDocument.contents;
      }
      configuredIndentation = !configuredIndentation ? 2 : configuredIndentation;
      if (isNode(node) && node.range) {
        const position = textBuffer.getPosition(node.range[0]);
        const lineContent = textBuffer.getLineContent(position.line);
        currentLine = currentLine === "" ? lineContent.trim() : currentLine;
        if (currentLine.startsWith("-") && indentation === configuredIndentation && currentLine === lineContent.trim()) {
          position.character += indentation;
        }
        if (position.character > indentation && position.character > 0) {
          const parent = this.getParent(node);
          if (parent) {
            return this.getProperParentByIndentation(indentation, parent, textBuffer, currentLine, configuredIndentation, rootParent);
          }
        } else if (position.character < indentation) {
          const parent = this.getParent(node);
          if (isPair(parent) && isNode(parent.value)) {
            return parent.value;
          } else if (isPair(rootParent) && isNode(rootParent.value)) {
            return rootParent.value;
          }
        } else {
          return node;
        }
      } else if (isPair(node)) {
        rootParent = node;
        const parent = this.getParent(node);
        return this.getProperParentByIndentation(indentation, parent, textBuffer, currentLine, configuredIndentation, rootParent);
      }
      return node;
    }
    getParent(node) {
      return getParent(this.internalDocument, node);
    }
  };
  var YAMLDocument = class {
    constructor(documents, tokens) {
      this.documents = documents;
      this.tokens = tokens;
      this.errors = [];
      this.warnings = [];
    }
  };
  var YamlDocuments = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    /**
     * Get cached YAMLDocument
     * @param document TextDocument to parse
     * @param parserOptions YAML parserOptions
     * @param addRootObject if true and document is empty add empty object {} to force schema usage
     * @returns the YAMLDocument
     */
    getYamlDocument(document2, parserOptions, addRootObject = false) {
      this.ensureCache(document2, parserOptions != null ? parserOptions : defaultOptions, addRootObject);
      return this.cache.get(document2.uri).document;
    }
    /**
     * For test purpose only!
     */
    clear() {
      this.cache.clear();
    }
    ensureCache(document2, parserOptions, addRootObject) {
      const key = document2.uri;
      if (!this.cache.has(key)) {
        this.cache.set(key, { version: -1, document: new YAMLDocument([], []), parserOptions: defaultOptions });
      }
      const cacheEntry = this.cache.get(key);
      if (cacheEntry.version !== document2.version || parserOptions.customTags && !isArrayEqual(cacheEntry.parserOptions.customTags, parserOptions.customTags)) {
        let text = document2.getText();
        if (addRootObject && !/\S/.test(text)) {
          text = `{${text}}`;
        }
        const doc = parse32(text, parserOptions, document2);
        cacheEntry.document = doc;
        cacheEntry.version = document2.version;
        cacheEntry.parserOptions = parserOptions;
      }
    }
  };
  var yamlDocumentsCache = new YamlDocuments();
  function YAMLErrorToYamlDocDiagnostics(error) {
    return {
      message: error.message,
      location: {
        start: error.pos[0],
        end: error.pos[1],
        toLineEnd: true
      },
      severity: 1,
      code: ErrorCode.Undefined
    };
  }
  var CommonTagImpl = class {
    constructor(tag, type) {
      this.tag = tag;
      this.type = type;
    }
    get collection() {
      if (this.type === "mapping") {
        return "map";
      }
      if (this.type === "sequence") {
        return "seq";
      }
      return void 0;
    }
    resolve(value) {
      if (isMap(value) && this.type === "mapping") {
        return value;
      }
      if (isSeq(value) && this.type === "sequence") {
        return value;
      }
      if (typeof value === "string" && this.type === "scalar") {
        return value;
      }
    }
  };
  var IncludeTag = class {
    constructor() {
      this.tag = "!include";
      this.type = "scalar";
    }
    resolve(value, onError) {
      if (value && value.length > 0 && value.trim()) {
        return value;
      }
      onError("!include without value");
    }
  };
  function getCustomTags(customTags) {
    const tags = [];
    const filteredTags = filterInvalidCustomTags(customTags);
    for (const tag of filteredTags) {
      const typeInfo = tag.split(" ");
      const tagName = typeInfo[0];
      const tagType = typeInfo[1] && typeInfo[1].toLowerCase() || "scalar";
      tags.push(new CommonTagImpl(tagName, tagType));
    }
    tags.push(new IncludeTag());
    return tags;
  }
  var TextBuffer = class {
    constructor(doc) {
      this.doc = doc;
    }
    getLineCount() {
      return this.doc.lineCount;
    }
    getLineLength(lineNumber) {
      const lineOffsets = this.doc.getLineOffsets();
      if (lineNumber >= lineOffsets.length) {
        return this.doc.getText().length;
      } else if (lineNumber < 0) {
        return 0;
      }
      const nextLineOffset = lineNumber + 1 < lineOffsets.length ? lineOffsets[lineNumber + 1] : this.doc.getText().length;
      return nextLineOffset - lineOffsets[lineNumber];
    }
    getLineContent(lineNumber) {
      const lineOffsets = this.doc.getLineOffsets();
      if (lineNumber >= lineOffsets.length) {
        return this.doc.getText();
      } else if (lineNumber < 0) {
        return "";
      }
      const nextLineOffset = lineNumber + 1 < lineOffsets.length ? lineOffsets[lineNumber + 1] : this.doc.getText().length;
      return this.doc.getText().substring(lineOffsets[lineNumber], nextLineOffset);
    }
    getLineCharCode(lineNumber, index) {
      return this.doc.getText(Range2.create(lineNumber - 1, index, lineNumber - 1, index + 1)).charCodeAt(0);
    }
    getText(range) {
      return this.doc.getText(range);
    }
    getPosition(offest) {
      return this.doc.positionAt(offest);
    }
  };
  var defaultOptions = {
    customTags: [],
    yamlVersion: "1.2"
  };
  function parse32(text, parserOptions = defaultOptions, document2) {
    var _a3;
    const options = {
      strict: false,
      customTags: getCustomTags(parserOptions.customTags),
      version: (_a3 = parserOptions.yamlVersion) != null ? _a3 : defaultOptions.yamlVersion,
      keepSourceTokens: true
    };
    const composer = new Composer(options);
    const lineCounter = new LineCounter();
    let isLastLineEmpty = false;
    if (document2) {
      const textBuffer = new TextBuffer(document2);
      const position = textBuffer.getPosition(text.length);
      const lineContent = textBuffer.getLineContent(position.line);
      isLastLineEmpty = lineContent.trim().length === 0;
    }
    const parser2 = isLastLineEmpty ? new Parser() : new Parser(lineCounter.addNewLine);
    const tokens = parser2.parse(text);
    const tokensArr = Array.from(tokens);
    const docs = composer.compose(tokensArr, true, text.length);
    const yamlDocs = Array.from(docs, (doc) => parsedDocToSingleYAMLDocument(doc, lineCounter));
    return new YAMLDocument(yamlDocs, tokensArr);
  }
  function parsedDocToSingleYAMLDocument(parsedDoc, lineCounter) {
    const syd = new SingleYAMLDocument(lineCounter);
    syd.internalDocument = parsedDoc;
    return syd;
  }
  function getSchemaFromModeline(doc) {
    if (doc instanceof SingleYAMLDocument) {
      const yamlLanguageServerModeline = doc.lineComments.find((lineComment2) => {
        return isModeline(lineComment2);
      });
      if (yamlLanguageServerModeline != void 0) {
        const schemaMatchs = yamlLanguageServerModeline.match(/\$schema=\S+/g);
        if (schemaMatchs !== null && schemaMatchs.length >= 1) {
          if (schemaMatchs.length >= 2) {
            console.log("Several $schema attributes have been found on the yaml-language-server modeline. The first one will be picked.");
          }
          return schemaMatchs[0].substring("$schema=".length);
        }
      }
    }
    return void 0;
  }
  function isModeline(lineText) {
    const matchModeline = lineText.match(/^#\s+yaml-language-server\s*:/g);
    return matchModeline !== null && matchModeline.length === 1;
  }
  var AJVStub = class {
    // eslint-disable-next-line class-methods-use-this
    compile() {
      return () => true;
    }
  };
  var localize8 = loadMessageBundle();
  var ajv = new AJVStub();
  var jsonSchema07 = require_json_schema_draft_07();
  var schema07Validator = ajv.compile(jsonSchema07);
  var MODIFICATION_ACTIONS;
  (function(MODIFICATION_ACTIONS2) {
    MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["delete"] = 0] = "delete";
    MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["add"] = 1] = "add";
    MODIFICATION_ACTIONS2[MODIFICATION_ACTIONS2["deleteAll"] = 2] = "deleteAll";
  })(MODIFICATION_ACTIONS || (MODIFICATION_ACTIONS = {}));
  var FilePatternAssociation2 = class {
    constructor(pattern) {
      try {
        this.patternRegExp = new RegExp(convertSimple2RegExpPattern(pattern) + "$");
      } catch (e) {
        this.patternRegExp = null;
      }
      this.schemas = [];
    }
    addSchema(id) {
      this.schemas.push(id);
    }
    matchesPattern(fileName) {
      return this.patternRegExp && this.patternRegExp.test(fileName);
    }
    getSchemas() {
      return this.schemas;
    }
  };
  var YAMLSchemaService = class extends JSONSchemaService {
    constructor(requestService, contextService, promiseConstructor) {
      super(requestService, contextService, promiseConstructor);
      this.schemaUriToNameAndDescription = /* @__PURE__ */ new Map();
      this.customSchemaProvider = void 0;
      this.requestService = requestService;
      this.schemaPriorityMapping = /* @__PURE__ */ new Map();
    }
    registerCustomSchemaProvider(customSchemaProvider) {
      this.customSchemaProvider = customSchemaProvider;
    }
    getAllSchemas() {
      const result = [];
      const schemaUris = /* @__PURE__ */ new Set();
      for (const filePattern of this.filePatternAssociations) {
        const schemaUri = filePattern.uris[0];
        if (schemaUris.has(schemaUri)) {
          continue;
        }
        schemaUris.add(schemaUri);
        const schemaHandle = {
          uri: schemaUri,
          fromStore: false,
          usedForCurrentFile: false
        };
        if (this.schemaUriToNameAndDescription.has(schemaUri)) {
          const { name, description: description2, versions } = this.schemaUriToNameAndDescription.get(schemaUri);
          schemaHandle.name = name;
          schemaHandle.description = description2;
          schemaHandle.fromStore = true;
          schemaHandle.versions = versions;
        }
        result.push(schemaHandle);
      }
      return result;
    }
    async resolveSchemaContent(schemaToResolve, schemaURL, dependencies) {
      const resolveErrors = schemaToResolve.errors.slice(0);
      let schema5 = schemaToResolve.schema;
      const contextService = this.contextService;
      if (!schema07Validator(schema5)) {
        const errs = [];
        for (const err of schema07Validator.errors) {
          errs.push(`${err.instancePath} : ${err.message}`);
        }
        resolveErrors.push(`Schema '${getSchemaTitle(schemaToResolve.schema, schemaURL)}' is not valid:
${errs.join("\n")}`);
      }
      const findSection = (schema22, path5) => {
        if (!path5) {
          return schema22;
        }
        let current = schema22;
        if (path5[0] === "/") {
          path5 = path5.substr(1);
        }
        path5.split("/").some((part) => {
          current = current[part];
          return !current;
        });
        return current;
      };
      const merge = (target, sourceRoot, sourceURI, path5) => {
        const section = findSection(sourceRoot, path5);
        if (section) {
          for (const key in section) {
            if (Object.prototype.hasOwnProperty.call(section, key) && !Object.prototype.hasOwnProperty.call(target, key)) {
              target[key] = section[key];
            }
          }
        } else {
          resolveErrors.push(localize8("json.schema.invalidref", "$ref '{0}' in '{1}' can not be resolved.", path5, sourceURI));
        }
      };
      const resolveExternalLink = (node, uri, linkPath, parentSchemaURL, parentSchemaDependencies) => {
        if (contextService && !/^\w+:\/\/.*/.test(uri)) {
          uri = contextService.resolveRelativePath(uri, parentSchemaURL);
        }
        uri = this.normalizeId(uri);
        const referencedHandle = this.getOrAddSchemaHandle(uri);
        return referencedHandle.getUnresolvedSchema().then((unresolvedSchema) => {
          parentSchemaDependencies[uri] = true;
          if (unresolvedSchema.errors.length) {
            const loc = linkPath ? uri + "#" + linkPath : uri;
            resolveErrors.push(localize8("json.schema.problemloadingref", "Problems loading reference '{0}': {1}", loc, unresolvedSchema.errors[0]));
          }
          merge(node, unresolvedSchema.schema, uri, linkPath);
          node.url = uri;
          return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);
        });
      };
      const resolveRefs = async (node, parentSchema, parentSchemaURL, parentSchemaDependencies) => {
        if (!node || typeof node !== "object") {
          return null;
        }
        const toWalk = [node];
        const seen = [];
        const openPromises = [];
        const collectEntries = (...entries) => {
          for (const entry of entries) {
            if (typeof entry === "object") {
              toWalk.push(entry);
            }
          }
        };
        const collectMapEntries = (...maps) => {
          for (const map2 of maps) {
            if (typeof map2 === "object") {
              for (const key in map2) {
                const entry = map2[key];
                if (typeof entry === "object") {
                  toWalk.push(entry);
                }
              }
            }
          }
        };
        const collectArrayEntries = (...arrays) => {
          for (const array of arrays) {
            if (Array.isArray(array)) {
              for (const entry of array) {
                if (typeof entry === "object") {
                  toWalk.push(entry);
                }
              }
            }
          }
        };
        const handleRef = (next) => {
          const seenRefs = [];
          while (next.$ref) {
            const ref = next.$ref;
            const segments = ref.split("#", 2);
            next._$ref = next.$ref;
            delete next.$ref;
            if (segments[0].length > 0) {
              openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));
              return;
            } else {
              if (seenRefs.indexOf(ref) === -1) {
                merge(next, parentSchema, parentSchemaURL, segments[1]);
                seenRefs.push(ref);
              }
            }
          }
          collectEntries(next.items, next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);
          collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);
          collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items, next.schemaSequence);
        };
        if (parentSchemaURL.indexOf("#") > 0) {
          const segments = parentSchemaURL.split("#", 2);
          if (segments[0].length > 0 && segments[1].length > 0) {
            const newSchema = {};
            await resolveExternalLink(newSchema, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies);
            for (const key in schema5) {
              if (key === "required") {
                continue;
              }
              if (Object.prototype.hasOwnProperty.call(schema5, key) && !Object.prototype.hasOwnProperty.call(newSchema, key)) {
                newSchema[key] = schema5[key];
              }
            }
            schema5 = newSchema;
          }
        }
        while (toWalk.length) {
          const next = toWalk.pop();
          if (seen.indexOf(next) >= 0) {
            continue;
          }
          seen.push(next);
          handleRef(next);
        }
        return Promise.all(openPromises);
      };
      await resolveRefs(schema5, schema5, schemaURL, dependencies);
      return new ResolvedSchema(schema5, resolveErrors);
    }
    getSchemaForResource(resource, doc) {
      const resolveModelineSchema = () => {
        let schemaFromModeline = getSchemaFromModeline(doc);
        if (schemaFromModeline !== void 0) {
          if (!schemaFromModeline.startsWith("file:") && !schemaFromModeline.startsWith("http")) {
            let appendix = "";
            if (schemaFromModeline.indexOf("#") > 0) {
              const segments = schemaFromModeline.split("#", 2);
              schemaFromModeline = segments[0];
              appendix = segments[1];
            }
            if (!path2.isAbsolute(schemaFromModeline)) {
              const resUri = URI2.parse(resource);
              schemaFromModeline = URI2.file(path2.resolve(path2.parse(resUri.fsPath).dir, schemaFromModeline)).toString();
            } else {
              schemaFromModeline = URI2.file(schemaFromModeline).toString();
            }
            if (appendix.length > 0) {
              schemaFromModeline += "#" + appendix;
            }
          }
          return schemaFromModeline;
        }
      };
      const resolveSchemaForResource = (schemas2) => {
        const schemaHandle = super.createCombinedSchema(resource, schemas2);
        return schemaHandle.getResolvedSchema().then((schema5) => {
          if (schema5.schema && typeof schema5.schema === "object") {
            schema5.schema.url = schemaHandle.url;
          }
          if (schema5.schema && schema5.schema.schemaSequence && schema5.schema.schemaSequence[doc.currentDocIndex]) {
            return new ResolvedSchema(schema5.schema.schemaSequence[doc.currentDocIndex]);
          }
          return schema5;
        });
      };
      const resolveSchema = () => {
        const seen = /* @__PURE__ */ Object.create(null);
        const schemas2 = [];
        for (const entry of this.filePatternAssociations) {
          if (entry.matchesPattern(resource)) {
            for (const schemaId of entry.getURIs()) {
              if (!seen[schemaId]) {
                schemas2.push(schemaId);
                seen[schemaId] = true;
              }
            }
          }
        }
        const normalizedResourceID = this.normalizeId(resource);
        if (this.schemasById[normalizedResourceID]) {
          schemas2.push(normalizedResourceID);
        }
        if (schemas2.length > 0) {
          const highestPrioSchemas = this.highestPrioritySchemas(schemas2);
          return resolveSchemaForResource(highestPrioSchemas);
        }
        return Promise.resolve(null);
      };
      const modelineSchema = resolveModelineSchema();
      if (modelineSchema) {
        return resolveSchemaForResource([modelineSchema]);
      }
      if (this.customSchemaProvider) {
        return this.customSchemaProvider(resource).then((schemaUri) => {
          if (Array.isArray(schemaUri)) {
            if (schemaUri.length === 0) {
              return resolveSchema();
            }
            return Promise.all(schemaUri.map((schemaUri2) => {
              return this.resolveCustomSchema(schemaUri2, doc);
            })).then((schemas2) => {
              return {
                errors: [],
                schema: {
                  anyOf: schemas2.map((schemaObj) => {
                    return schemaObj.schema;
                  })
                }
              };
            }, () => {
              return resolveSchema();
            });
          }
          if (!schemaUri) {
            return resolveSchema();
          }
          return this.resolveCustomSchema(schemaUri, doc);
        }).then((schema5) => {
          return schema5;
        }, () => {
          return resolveSchema();
        });
      } else {
        return resolveSchema();
      }
    }
    // Set the priority of a schema in the schema service
    addSchemaPriority(uri, priority) {
      let currSchemaArray = this.schemaPriorityMapping.get(uri);
      if (currSchemaArray) {
        currSchemaArray = currSchemaArray.add(priority);
        this.schemaPriorityMapping.set(uri, currSchemaArray);
      } else {
        this.schemaPriorityMapping.set(uri, (/* @__PURE__ */ new Set()).add(priority));
      }
    }
    /**
     * Search through all the schemas and find the ones with the highest priority
     */
    highestPrioritySchemas(schemas2) {
      let highestPrio = 0;
      const priorityMapping = /* @__PURE__ */ new Map();
      schemas2.forEach((schema5) => {
        const priority = this.schemaPriorityMapping.get(schema5) || [0];
        priority.forEach((prio) => {
          if (prio > highestPrio) {
            highestPrio = prio;
          }
          let currPriorityArray = priorityMapping.get(prio);
          if (currPriorityArray) {
            currPriorityArray = currPriorityArray.concat(schema5);
            priorityMapping.set(prio, currPriorityArray);
          } else {
            priorityMapping.set(prio, [schema5]);
          }
        });
      });
      return priorityMapping.get(highestPrio) || [];
    }
    async resolveCustomSchema(schemaUri, doc) {
      const unresolvedSchema = await this.loadSchema(schemaUri);
      const schema5 = await this.resolveSchemaContent(unresolvedSchema, schemaUri, []);
      if (schema5.schema) {
        schema5.schema.url = schemaUri;
      }
      if (schema5.schema && schema5.schema.schemaSequence && schema5.schema.schemaSequence[doc.currentDocIndex]) {
        return new ResolvedSchema(schema5.schema.schemaSequence[doc.currentDocIndex]);
      }
      return schema5;
    }
    /**
     * Save a schema with schema ID and schema content.
     * Overrides previous schemas set for that schema ID.
     */
    async saveSchema(schemaId, schemaContent) {
      const id = this.normalizeId(schemaId);
      this.getOrAddSchemaHandle(id, schemaContent);
      this.schemaPriorityMapping.set(id, (/* @__PURE__ */ new Set()).add(SchemaPriority.Settings));
      return Promise.resolve(void 0);
    }
    /**
     * Delete schemas on specific path
     */
    async deleteSchemas(deletions) {
      deletions.schemas.forEach((s) => {
        this.deleteSchema(s);
      });
      return Promise.resolve(void 0);
    }
    /**
     * Delete a schema with schema ID.
     */
    async deleteSchema(schemaId) {
      const id = this.normalizeId(schemaId);
      if (this.schemasById[id]) {
        delete this.schemasById[id];
      }
      this.schemaPriorityMapping.delete(id);
      return Promise.resolve(void 0);
    }
    /**
     * Add content to a specified schema at a specified path
     */
    async addContent(additions) {
      const schema5 = await this.getResolvedSchema(additions.schema);
      if (schema5) {
        const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema5.schema, additions.path);
        if (typeof resolvedSchemaLocation === "object") {
          resolvedSchemaLocation[additions.key] = additions.content;
        }
        await this.saveSchema(additions.schema, schema5.schema);
      }
    }
    /**
     * Delete content in a specified schema at a specified path
     */
    async deleteContent(deletions) {
      const schema5 = await this.getResolvedSchema(deletions.schema);
      if (schema5) {
        const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema5.schema, deletions.path);
        if (typeof resolvedSchemaLocation === "object") {
          delete resolvedSchemaLocation[deletions.key];
        }
        await this.saveSchema(deletions.schema, schema5.schema);
      }
    }
    /**
     * Take a JSON Schema and the path that you would like to get to
     * @returns the JSON Schema resolved at that specific path
     */
    resolveJSONSchemaToSection(schema5, paths) {
      const splitPathway = paths.split("/");
      let resolvedSchemaLocation = schema5;
      for (const path5 of splitPathway) {
        if (path5 === "") {
          continue;
        }
        this.resolveNext(resolvedSchemaLocation, path5);
        resolvedSchemaLocation = resolvedSchemaLocation[path5];
      }
      return resolvedSchemaLocation;
    }
    /**
     * Resolve the next Object if they have compatible types
     * @param object a location in the JSON Schema
     * @param token the next token that you want to search for
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    resolveNext(object, token) {
      if (Array.isArray(object) && isNaN(token)) {
        throw new Error("Expected a number after the array object");
      } else if (typeof object === "object" && typeof token !== "string") {
        throw new Error("Expected a string after the object");
      }
    }
    /**
     * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need
     * to provide a wrapper around the javascript methods we are calling since they have no type
     */
    normalizeId(id) {
      try {
        return URI2.parse(id).toString();
      } catch (e) {
        return id;
      }
    }
    /*
     * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need
     * to provide a wrapper around the javascript methods we are calling since they have no type
     */
    getOrAddSchemaHandle(id, unresolvedSchemaContent) {
      return super.getOrAddSchemaHandle(id, unresolvedSchemaContent);
    }
    loadSchema(schemaUri) {
      const requestService = this.requestService;
      return super.loadSchema(schemaUri).then((unresolvedJsonSchema) => {
        if (unresolvedJsonSchema.errors && unresolvedJsonSchema.schema === void 0) {
          return requestService(schemaUri).then(
            (content) => {
              if (!content) {
                const errorMessage = localize8("json.schema.nocontent", "Unable to load schema from '{0}': No content. {1}", toDisplayString2(schemaUri), unresolvedJsonSchema.errors);
                return new UnresolvedSchema({}, [errorMessage]);
              }
              try {
                const schemaContent = parse3(content);
                return new UnresolvedSchema(schemaContent, []);
              } catch (yamlError) {
                const errorMessage = localize8("json.schema.invalidFormat", "Unable to parse content from '{0}': {1}.", toDisplayString2(schemaUri), yamlError);
                return new UnresolvedSchema({}, [errorMessage]);
              }
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (error) => {
              let errorMessage = error.toString();
              const errorSplit = error.toString().split("Error: ");
              if (errorSplit.length > 1) {
                errorMessage = errorSplit[1];
              }
              return new UnresolvedSchema({}, [errorMessage]);
            }
          );
        }
        unresolvedJsonSchema.uri = schemaUri;
        if (this.schemaUriToNameAndDescription.has(schemaUri)) {
          const { name, description: description2, versions } = this.schemaUriToNameAndDescription.get(schemaUri);
          unresolvedJsonSchema.schema.title = name != null ? name : unresolvedJsonSchema.schema.title;
          unresolvedJsonSchema.schema.description = description2 != null ? description2 : unresolvedJsonSchema.schema.description;
          unresolvedJsonSchema.schema.versions = versions != null ? versions : unresolvedJsonSchema.schema.versions;
        }
        return unresolvedJsonSchema;
      });
    }
    registerExternalSchema(uri, filePatterns, unresolvedSchema, name, description2, versions) {
      if (name || description2) {
        this.schemaUriToNameAndDescription.set(uri, { name, description: description2, versions });
      }
      return super.registerExternalSchema(uri, filePatterns, unresolvedSchema);
    }
    clearExternalSchemas() {
      super.clearExternalSchemas();
    }
    setSchemaContributions(schemaContributions2) {
      super.setSchemaContributions(schemaContributions2);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getRegisteredSchemaIds(filter) {
      return super.getRegisteredSchemaIds(filter);
    }
    getResolvedSchema(schemaId) {
      return super.getResolvedSchema(schemaId);
    }
    onResourceChange(uri) {
      return super.onResourceChange(uri);
    }
  };
  function toDisplayString2(url) {
    try {
      const uri = URI2.parse(url);
      if (uri.scheme === "file") {
        return uri.fsPath;
      }
    } catch (e) {
    }
    return url;
  }
  var YAMLDocumentSymbols = class {
    constructor(schemaService, telemetry2) {
      this.telemetry = telemetry2;
      this.jsonDocumentSymbols = new JSONDocumentSymbols(schemaService);
      this.jsonDocumentSymbols.getKeyLabel = (property2) => {
        const keyNode = property2.keyNode.internalNode;
        let name = "";
        if (isMap(keyNode)) {
          name = "{}";
        } else if (isSeq(keyNode)) {
          name = "[]";
        } else {
          name = keyNode.source;
        }
        return name;
      };
    }
    findDocumentSymbols(document2, context = { resultLimit: Number.MAX_VALUE }) {
      let results = [];
      try {
        const doc = yamlDocumentsCache.getYamlDocument(document2);
        if (!doc || doc["documents"].length === 0) {
          return null;
        }
        for (const yamlDoc of doc["documents"]) {
          if (yamlDoc.root) {
            results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols(document2, yamlDoc, context));
          }
        }
      } catch (err) {
        this.telemetry.sendError("yaml.documentSymbols.error", { error: convertErrorToTelemetryMsg(err) });
      }
      return results;
    }
    findHierarchicalDocumentSymbols(document2, context = { resultLimit: Number.MAX_VALUE }) {
      let results = [];
      try {
        const doc = yamlDocumentsCache.getYamlDocument(document2);
        if (!doc || doc["documents"].length === 0) {
          return null;
        }
        for (const yamlDoc of doc["documents"]) {
          if (yamlDoc.root) {
            results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols2(document2, yamlDoc, context));
          }
        }
      } catch (err) {
        this.telemetry.sendError("yaml.hierarchicalDocumentSymbols.error", { error: convertErrorToTelemetryMsg(err) });
      }
      return results;
    }
  };
  function setKubernetesParserOption(jsonDocuments, option) {
    for (const jsonDoc of jsonDocuments) {
      jsonDoc.isKubernetes = option;
    }
  }
  var YAMLHover = class {
    constructor(schemaService, telemetry2) {
      this.telemetry = telemetry2;
      this.shouldHover = true;
      this.schemaService = schemaService;
    }
    configure(languageSettings) {
      if (languageSettings) {
        this.shouldHover = languageSettings.hover;
      }
    }
    doHover(document2, position, isKubernetes = false) {
      try {
        if (!this.shouldHover || !document2) {
          return Promise.resolve(void 0);
        }
        const doc = yamlDocumentsCache.getYamlDocument(document2);
        const offset = document2.offsetAt(position);
        const currentDoc = matchOffsetToDocument(offset, doc);
        if (currentDoc === null) {
          return Promise.resolve(void 0);
        }
        setKubernetesParserOption(doc.documents, isKubernetes);
        const currentDocIndex = doc.documents.indexOf(currentDoc);
        currentDoc.currentDocIndex = currentDocIndex;
        return this.getHover(document2, position, currentDoc);
      } catch (error) {
        this.telemetry.sendError("yaml.hover.error", { error: convertErrorToTelemetryMsg(error) });
      }
    }
    // method copied from https://github.com/microsoft/vscode-json-languageservice/blob/2ea5ad3d2ffbbe40dea11cfe764a502becf113ce/src/services/jsonHover.ts#L23
    getHover(document2, position, doc) {
      const offset = document2.offsetAt(position);
      let node = doc.getNodeFromOffset(offset);
      if (!node || (node.type === "object" || node.type === "array") && offset > node.offset + 1 && offset < node.offset + node.length - 1) {
        return Promise.resolve(null);
      }
      const hoverRangeNode = node;
      if (node.type === "string") {
        const parent = node.parent;
        if (parent && parent.type === "property" && parent.keyNode === node) {
          node = parent.valueNode;
          if (!node) {
            return Promise.resolve(null);
          }
        }
      }
      const hoverRange = Range2.create(document2.positionAt(hoverRangeNode.offset), document2.positionAt(hoverRangeNode.offset + hoverRangeNode.length));
      const createHover = (contents) => {
        const markupContent = {
          kind: "markdown",
          value: contents
        };
        const result = {
          contents: markupContent,
          range: hoverRange
        };
        return result;
      };
      const removePipe = (value) => {
        return value.replace(/\|\|\s*$/, "");
      };
      return this.schemaService.getSchemaForResource(document2.uri, doc).then((schema5) => {
        if (schema5 && node && !schema5.errors.length) {
          const matchingSchemas = doc.getMatchingSchemas(schema5.schema, node.offset);
          let title = void 0;
          let markdownDescription = void 0;
          let markdownEnumValueDescription = void 0;
          let enumValue = void 0;
          const markdownExamples = [];
          matchingSchemas.every((s) => {
            if ((s.node === node || node.type === "property" && node.valueNode === s.node) && !s.inverted && s.schema) {
              title = title || s.schema.title || s.schema.closestTitle;
              markdownDescription = markdownDescription || s.schema.markdownDescription || toMarkdown2(s.schema.description);
              if (s.schema.enum) {
                const idx = s.schema.enum.indexOf(getNodeValue3(node));
                if (s.schema.markdownEnumDescriptions) {
                  markdownEnumValueDescription = s.schema.markdownEnumDescriptions[idx];
                } else if (s.schema.enumDescriptions) {
                  markdownEnumValueDescription = toMarkdown2(s.schema.enumDescriptions[idx]);
                }
                if (markdownEnumValueDescription) {
                  enumValue = s.schema.enum[idx];
                  if (typeof enumValue !== "string") {
                    enumValue = JSON.stringify(enumValue);
                  }
                }
              }
              if (s.schema.anyOf && isAllSchemasMatched(node, matchingSchemas, s.schema)) {
                title = "";
                markdownDescription = "";
                s.schema.anyOf.forEach((childSchema, index) => {
                  title += childSchema.title || s.schema.closestTitle || "";
                  markdownDescription += childSchema.markdownDescription || toMarkdown2(childSchema.description) || "";
                  if (index !== s.schema.anyOf.length - 1) {
                    title += " || ";
                    markdownDescription += " || ";
                  }
                });
                title = removePipe(title);
                markdownDescription = removePipe(markdownDescription);
              }
              if (s.schema.examples) {
                s.schema.examples.forEach((example) => {
                  markdownExamples.push(JSON.stringify(example));
                });
              }
            }
            return true;
          });
          let result = "";
          if (title) {
            result = "#### " + toMarkdown2(title);
          }
          if (markdownDescription) {
            if (result.length > 0) {
              result += "\n\n";
            }
            result += markdownDescription;
          }
          if (markdownEnumValueDescription) {
            if (result.length > 0) {
              result += "\n\n";
            }
            result += `\`${toMarkdownCodeBlock2(enumValue)}\`: ${markdownEnumValueDescription}`;
          }
          if (markdownExamples.length !== 0) {
            if (result.length > 0) {
              result += "\n\n";
            }
            result += "Examples:";
            markdownExamples.forEach((example) => {
              result += `

\`\`\`${example}\`\`\``;
            });
          }
          if (result.length > 0 && schema5.schema.url) {
            result += `

Source: [${getSchemaName(schema5.schema)}](${schema5.schema.url})`;
          }
          return createHover(result);
        }
        return null;
      });
    }
  };
  function getSchemaName(schema5) {
    let result = "JSON Schema";
    const urlString = schema5.url;
    if (urlString) {
      const url = URI2.parse(urlString);
      result = path3.basename(url.fsPath);
    } else if (schema5.title) {
      result = schema5.title;
    }
    return result;
  }
  function toMarkdown2(plain) {
    if (plain) {
      const res = plain.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, "$1\n\n$3");
      return res.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
    }
    return void 0;
  }
  function toMarkdownCodeBlock2(content) {
    if (content.indexOf("`") !== -1) {
      return "`` " + content + " ``";
    }
    return content;
  }
  function isAllSchemasMatched(node, matchingSchemas, schema5) {
    let count = 0;
    for (const matchSchema of matchingSchemas) {
      if (node === matchSchema.node && matchSchema.schema !== schema5) {
        schema5.anyOf.forEach((childSchema) => {
          if (matchSchema.schema.title === childSchema.title && matchSchema.schema.description === childSchema.description && matchSchema.schema.properties === childSchema.properties) {
            count++;
          }
        });
      }
    }
    return count === schema5.anyOf.length;
  }
  var UnusedAnchorsValidator = class {
    validate(document2, yamlDoc) {
      const result = [];
      const anchors = /* @__PURE__ */ new Set();
      const usedAnchors = /* @__PURE__ */ new Set();
      const anchorParent = /* @__PURE__ */ new Map();
      visit2(yamlDoc.internalDocument, (key, node, path5) => {
        if (!isNode(node)) {
          return;
        }
        if ((isCollection(node) || isScalar(node)) && node.anchor) {
          anchors.add(node);
          anchorParent.set(node, path5[path5.length - 1]);
        }
        if (isAlias(node)) {
          usedAnchors.add(node.resolve(yamlDoc.internalDocument));
        }
      });
      for (const anchor of anchors) {
        if (!usedAnchors.has(anchor)) {
          const aToken = this.getAnchorNode(anchorParent.get(anchor));
          if (aToken) {
            const range = Range2.create(document2.positionAt(aToken.offset), document2.positionAt(aToken.offset + aToken.source.length));
            const warningDiagnostic = Diagnostic.create(range, `Unused anchor "${aToken.source}"`, DiagnosticSeverity.Hint, 0);
            warningDiagnostic.tags = [DiagnosticTag.Unnecessary];
            result.push(warningDiagnostic);
          }
        }
      }
      return result;
    }
    getAnchorNode(parentNode) {
      if (parentNode && parentNode.srcToken) {
        const token = parentNode.srcToken;
        if (isCollectionItem(token)) {
          return getAnchorFromCollectionItem(token);
        } else if (cst_exports.isCollection(token)) {
          for (const t of token.items) {
            const anchor = getAnchorFromCollectionItem(t);
            if (anchor) {
              return anchor;
            }
          }
        }
      }
      return void 0;
    }
  };
  function getAnchorFromCollectionItem(token) {
    for (const t of token.start) {
      if (t.type === "anchor") {
        return t;
      }
    }
    if (token.sep && Array.isArray(token.sep)) {
      for (const t of token.sep) {
        if (t.type === "anchor") {
          return t;
        }
      }
    }
  }
  var YAMLStyleValidator = class {
    constructor(settings) {
      this.forbidMapping = settings.flowMapping === "forbid";
      this.forbidSequence = settings.flowSequence === "forbid";
    }
    validate(document2, yamlDoc) {
      const result = [];
      visit2(yamlDoc.internalDocument, (key, node) => {
        var _a3, _b;
        if (this.forbidMapping && isMap(node) && ((_a3 = node.srcToken) == null ? void 0 : _a3.type) === "flow-collection") {
          result.push(Diagnostic.create(this.getRangeOf(document2, node.srcToken), "Flow style mapping is forbidden", DiagnosticSeverity.Error, "flowMap"));
        }
        if (this.forbidSequence && isSeq(node) && ((_b = node.srcToken) == null ? void 0 : _b.type) === "flow-collection") {
          result.push(Diagnostic.create(this.getRangeOf(document2, node.srcToken), "Flow style sequence is forbidden", DiagnosticSeverity.Error, "flowSeq"));
        }
      });
      return result;
    }
    getRangeOf(document2, node) {
      return Range2.create(document2.positionAt(node.start.offset), document2.positionAt(node.end.pop().offset));
    }
  };
  var yamlDiagToLSDiag = (yamlDiag, textDocument) => {
    const start = textDocument.positionAt(yamlDiag.location.start);
    const range = {
      start,
      end: yamlDiag.location.toLineEnd ? Position2.create(start.line, new TextBuffer(textDocument).getLineLength(start.line)) : textDocument.positionAt(yamlDiag.location.end)
    };
    return Diagnostic.create(range, yamlDiag.message, yamlDiag.severity, yamlDiag.code, YAML_SOURCE);
  };
  var YAMLValidation = class {
    constructor(schemaService, telemetry2) {
      this.telemetry = telemetry2;
      this.validators = [];
      this.MATCHES_MULTIPLE = "Matches multiple schemas when only one must validate.";
      this.validationEnabled = true;
      this.jsonValidation = new JSONValidation(schemaService, Promise);
    }
    configure(settings) {
      this.validators = [];
      if (settings) {
        this.validationEnabled = settings.validate;
        this.customTags = settings.customTags;
        this.disableAdditionalProperties = settings.disableAdditionalProperties;
        this.yamlVersion = settings.yamlVersion;
        if (settings.flowMapping === "forbid" || settings.flowSequence === "forbid") {
          this.validators.push(new YAMLStyleValidator(settings));
        }
      }
      this.validators.push(new UnusedAnchorsValidator());
    }
    async doValidation(textDocument, isKubernetes = false) {
      if (!this.validationEnabled) {
        return Promise.resolve([]);
      }
      const validationResult = [];
      try {
        const yamlDocument = yamlDocumentsCache.getYamlDocument(textDocument, { customTags: this.customTags, yamlVersion: this.yamlVersion }, true);
        let index = 0;
        for (const currentYAMLDoc of yamlDocument.documents) {
          currentYAMLDoc.isKubernetes = isKubernetes;
          currentYAMLDoc.currentDocIndex = index;
          currentYAMLDoc.disableAdditionalProperties = this.disableAdditionalProperties;
          currentYAMLDoc.uri = textDocument.uri;
          const validation = await this.jsonValidation.doValidation(textDocument, currentYAMLDoc);
          const syd = currentYAMLDoc;
          if (syd.errors.length > 0) {
            validationResult.push(...syd.errors);
          }
          if (syd.warnings.length > 0) {
            validationResult.push(...syd.warnings);
          }
          validationResult.push(...validation);
          validationResult.push(...this.runAdditionalValidators(textDocument, currentYAMLDoc));
          index++;
        }
      } catch (err) {
        this.telemetry.sendError("yaml.validation.error", { error: convertErrorToTelemetryMsg(err) });
      }
      let previousErr;
      const foundSignatures = /* @__PURE__ */ new Set();
      const duplicateMessagesRemoved = [];
      for (let err of validationResult) {
        if (isKubernetes && err.message === this.MATCHES_MULTIPLE) {
          continue;
        }
        if (Object.prototype.hasOwnProperty.call(err, "location")) {
          err = yamlDiagToLSDiag(err, textDocument);
        }
        if (!err.source) {
          err.source = YAML_SOURCE;
        }
        if (previousErr && previousErr.message === err.message && previousErr.range.end.line === err.range.start.line && Math.abs(previousErr.range.end.character - err.range.end.character) >= 1) {
          previousErr.range.end = err.range.end;
          continue;
        } else {
          previousErr = err;
        }
        const errSig = err.range.start.line + " " + err.range.start.character + " " + err.message;
        if (!foundSignatures.has(errSig)) {
          duplicateMessagesRemoved.push(err);
          foundSignatures.add(errSig);
        }
      }
      return duplicateMessagesRemoved;
    }
    runAdditionalValidators(document2, yarnDoc) {
      const result = [];
      for (const validator of this.validators) {
        result.push(...validator.validate(document2, yarnDoc));
      }
      return result;
    }
  };
  var YAMLFormatter = class {
    constructor() {
      this.formatterEnabled = true;
    }
    configure(shouldFormat) {
      if (shouldFormat) {
        this.formatterEnabled = shouldFormat.format;
      }
    }
    format(document2, options) {
      if (!this.formatterEnabled) {
        return [];
      }
      try {
        const text = document2.getText();
        const prettierOptions = {
          parser: "yaml",
          plugins: [parser],
          // --- FormattingOptions ---
          tabWidth: options.tabWidth || options.tabSize,
          // --- CustomFormatterOptions ---
          singleQuote: options.singleQuote,
          bracketSpacing: options.bracketSpacing,
          // 'preserve' is the default for Options.proseWrap. See also server.ts
          proseWrap: "always" === options.proseWrap ? "always" : "never" === options.proseWrap ? "never" : "preserve",
          printWidth: options.printWidth
        };
        const formatted = prettier.format(text, prettierOptions);
        return [TextEdit.replace(Range2.create(Position2.create(0, 0), document2.positionAt(text.length)), formatted)];
      } catch (error) {
        return [];
      }
    }
  };
  var YamlLinks = class {
    constructor(telemetry2) {
      this.telemetry = telemetry2;
    }
    findLinks(document2) {
      try {
        const doc = yamlDocumentsCache.getYamlDocument(document2);
        const linkPromises = [];
        for (const yamlDoc of doc.documents) {
          linkPromises.push(findLinks(document2, yamlDoc));
        }
        return Promise.all(linkPromises).then((yamlLinkArray) => [].concat(...yamlLinkArray));
      } catch (err) {
        this.telemetry.sendError("yaml.documentLink.error", { error: convertErrorToTelemetryMsg(err) });
      }
    }
  };
  function getFoldingRanges2(document2, context) {
    if (!document2) {
      return;
    }
    const result = [];
    const doc = yamlDocumentsCache.getYamlDocument(document2);
    for (const ymlDoc of doc.documents) {
      if (doc.documents.length > 1) {
        result.push(createNormalizedFolding(document2, ymlDoc.root));
      }
      ymlDoc.visit((node) => {
        var _a3;
        if (node.type === "object" && ((_a3 = node.parent) == null ? void 0 : _a3.type) === "array") {
          result.push(createNormalizedFolding(document2, node));
        }
        if (node.type === "property" && node.valueNode) {
          switch (node.valueNode.type) {
            case "array":
            case "object":
              result.push(createNormalizedFolding(document2, node));
              break;
            case "string": {
              const nodePosn = document2.positionAt(node.offset);
              const valuePosn = document2.positionAt(node.valueNode.offset + node.valueNode.length);
              if (nodePosn.line !== valuePosn.line) {
                result.push(createNormalizedFolding(document2, node));
              }
              break;
            }
            default:
              return true;
          }
        }
        return true;
      });
    }
    const rangeLimit = context && context.rangeLimit;
    if (typeof rangeLimit !== "number" || result.length <= rangeLimit) {
      return result;
    }
    if (context && context.onRangeLimitExceeded) {
      context.onRangeLimitExceeded(document2.uri);
    }
    return result.slice(0, context.rangeLimit);
  }
  function createNormalizedFolding(document2, node) {
    const startPos = document2.positionAt(node.offset);
    let endPos = document2.positionAt(node.offset + node.length);
    const textFragment = document2.getText(Range2.create(startPos, endPos));
    const newLength = textFragment.length - textFragment.trimRight().length;
    if (newLength > 0) {
      endPos = document2.positionAt(node.offset + node.length - newLength);
    }
    return FoldingRange.create(startPos.line, endPos.line, startPos.character, endPos.character);
  }
  var YamlCommands;
  (function(YamlCommands2) {
    YamlCommands2["JUMP_TO_SCHEMA"] = "jumpToSchema";
  })(YamlCommands || (YamlCommands = {}));
  var FlowStyleRewriter = class {
    constructor(indentation) {
      this.indentation = indentation;
    }
    write(node) {
      if (node.internalNode.srcToken["type"] !== "flow-collection") {
        return null;
      }
      const collection = node.internalNode.srcToken;
      const blockType = collection.start.type === "flow-map-start" ? "block-map" : "block-seq";
      const parentType = node.parent.type;
      const blockStyle = {
        type: blockType,
        offset: collection.offset,
        indent: collection.indent,
        items: []
      };
      for (const item of collection.items) {
        cst_exports.visit(item, ({ key, sep: sep2, value }) => {
          if (blockType === "block-map") {
            const start = [{ type: "space", indent: 0, offset: key.offset, source: this.indentation }];
            if (parentType === "property") {
              start.unshift({ type: "newline", indent: 0, offset: key.offset, source: "\n" });
            }
            blockStyle.items.push({
              start,
              key,
              sep: sep2,
              value
            });
          } else if (blockType === "block-seq") {
            blockStyle.items.push({
              start: [
                { type: "newline", indent: 0, offset: value.offset, source: "\n" },
                { type: "space", indent: 0, offset: value.offset, source: this.indentation },
                { type: "seq-item-ind", indent: 0, offset: value.offset, source: "-" },
                { type: "space", indent: 0, offset: value.offset, source: " " }
              ],
              value
            });
          }
          if (value.type === "flow-collection") {
            return visit2.SKIP;
          }
        });
      }
      return cst_exports.stringify(blockStyle);
    }
  };
  var YamlCodeActions = class {
    constructor(clientCapabilities) {
      this.clientCapabilities = clientCapabilities;
      this.indentation = "  ";
    }
    configure(settings) {
      this.indentation = settings.indentation;
    }
    getCodeAction(document2, params) {
      if (!params.context.diagnostics) {
        return;
      }
      const result = [];
      result.push(...this.getConvertToBooleanActions(params.context.diagnostics, document2));
      result.push(...this.getJumpToSchemaActions(params.context.diagnostics));
      result.push(...this.getTabToSpaceConverting(params.context.diagnostics, document2));
      result.push(...this.getUnusedAnchorsDelete(params.context.diagnostics, document2));
      result.push(...this.getConvertToBlockStyleActions(params.context.diagnostics, document2));
      return result;
    }
    getJumpToSchemaActions(diagnostics) {
      var _a3, _b, _c, _d, _e;
      const isOpenTextDocumentEnabled = (_d = (_c = (_b = (_a3 = this.clientCapabilities) == null ? void 0 : _a3.window) == null ? void 0 : _b.showDocument) == null ? void 0 : _c.support) != null ? _d : false;
      if (!isOpenTextDocumentEnabled) {
        return [];
      }
      const schemaUriToDiagnostic = /* @__PURE__ */ new Map();
      for (const diagnostic of diagnostics) {
        const schemaUri = ((_e = diagnostic.data) == null ? void 0 : _e.schemaUri) || [];
        for (const schemaUriStr of schemaUri) {
          if (schemaUriStr) {
            if (!schemaUriToDiagnostic.has(schemaUriStr)) {
              schemaUriToDiagnostic.set(schemaUriStr, []);
            }
            schemaUriToDiagnostic.get(schemaUriStr).push(diagnostic);
          }
        }
      }
      const result = [];
      for (const schemaUri of schemaUriToDiagnostic.keys()) {
        const action = CodeAction.create(`Jump to schema location (${path4.basename(schemaUri)})`, Command2.create("JumpToSchema", YamlCommands.JUMP_TO_SCHEMA, schemaUri));
        action.diagnostics = schemaUriToDiagnostic.get(schemaUri);
        result.push(action);
      }
      return result;
    }
    getTabToSpaceConverting(diagnostics, document2) {
      const result = [];
      const textBuff = new TextBuffer(document2);
      const processedLine = [];
      for (const diag of diagnostics) {
        if (diag.message === "Using tabs can lead to unpredictable results") {
          if (processedLine.includes(diag.range.start.line)) {
            continue;
          }
          const lineContent = textBuff.getLineContent(diag.range.start.line);
          let replacedTabs = 0;
          let newText = "";
          for (let i = diag.range.start.character; i <= diag.range.end.character; i++) {
            const char = lineContent.charAt(i);
            if (char !== "	") {
              break;
            }
            replacedTabs++;
            newText += this.indentation;
          }
          processedLine.push(diag.range.start.line);
          let resultRange = diag.range;
          if (replacedTabs !== diag.range.end.character - diag.range.start.character) {
            resultRange = Range2.create(diag.range.start, Position2.create(diag.range.end.line, diag.range.start.character + replacedTabs));
          }
          result.push(CodeAction.create("Convert Tab to Spaces", createWorkspaceEdit(document2.uri, [TextEdit.replace(resultRange, newText)]), CodeActionKind.QuickFix));
        }
      }
      if (result.length !== 0) {
        const replaceEdits = [];
        for (let i = 0; i <= textBuff.getLineCount(); i++) {
          const lineContent = textBuff.getLineContent(i);
          let replacedTabs = 0;
          let newText = "";
          for (let j = 0; j < lineContent.length; j++) {
            const char = lineContent.charAt(j);
            if (char !== " " && char !== "	") {
              if (replacedTabs !== 0) {
                replaceEdits.push(TextEdit.replace(Range2.create(i, j - replacedTabs, i, j), newText));
                replacedTabs = 0;
                newText = "";
              }
              break;
            }
            if (char === " " && replacedTabs !== 0) {
              replaceEdits.push(TextEdit.replace(Range2.create(i, j - replacedTabs, i, j), newText));
              replacedTabs = 0;
              newText = "";
              continue;
            }
            if (char === "	") {
              newText += this.indentation;
              replacedTabs++;
            }
          }
          if (replacedTabs !== 0) {
            replaceEdits.push(TextEdit.replace(Range2.create(i, 0, i, textBuff.getLineLength(i)), newText));
          }
        }
        if (replaceEdits.length > 0) {
          result.push(CodeAction.create("Convert all Tabs to Spaces", createWorkspaceEdit(document2.uri, replaceEdits), CodeActionKind.QuickFix));
        }
      }
      return result;
    }
    getUnusedAnchorsDelete(diagnostics, document2) {
      const result = [];
      const buffer = new TextBuffer(document2);
      for (const diag of diagnostics) {
        if (diag.message.startsWith("Unused anchor") && diag.source === YAML_SOURCE) {
          const range = Range2.create(diag.range.start, diag.range.end);
          const actual = buffer.getText(range);
          const lineContent = buffer.getLineContent(range.end.line);
          const lastWhitespaceChar = getFirstNonWhitespaceCharacterAfterOffset(lineContent, range.end.character);
          range.end.character = lastWhitespaceChar;
          const action = CodeAction.create(`Delete unused anchor: ${actual}`, createWorkspaceEdit(document2.uri, [TextEdit.del(range)]), CodeActionKind.QuickFix);
          action.diagnostics = [diag];
          result.push(action);
        }
      }
      return result;
    }
    getConvertToBooleanActions(diagnostics, document2) {
      const results = [];
      for (const diagnostic of diagnostics) {
        if (diagnostic.message === 'Incorrect type. Expected "boolean".') {
          const value = document2.getText(diagnostic.range).toLocaleLowerCase();
          if (value === '"true"' || value === '"false"' || value === "'true'" || value === "'false'") {
            const newValue = value.includes("true") ? "true" : "false";
            results.push(CodeAction.create("Convert to boolean", createWorkspaceEdit(document2.uri, [TextEdit.replace(diagnostic.range, newValue)]), CodeActionKind.QuickFix));
          }
        }
      }
      return results;
    }
    getConvertToBlockStyleActions(diagnostics, document2) {
      const results = [];
      for (const diagnostic of diagnostics) {
        if (diagnostic.code === "flowMap" || diagnostic.code === "flowSeq") {
          const yamlDocuments = yamlDocumentsCache.getYamlDocument(document2);
          const startOffset = document2.offsetAt(diagnostic.range.start);
          const yamlDoc = matchOffsetToDocument(startOffset, yamlDocuments);
          const node = yamlDoc.getNodeFromOffset(startOffset);
          if (isMap(node.internalNode) || isSeq(node.internalNode)) {
            const blockTypeDescription = isMap(node.internalNode) ? "map" : "sequence";
            const rewriter = new FlowStyleRewriter(this.indentation);
            results.push(CodeAction.create(`Convert to block style ${blockTypeDescription}`, createWorkspaceEdit(document2.uri, [TextEdit.replace(diagnostic.range, rewriter.write(node))]), CodeActionKind.QuickFix));
          }
        }
      }
      return results;
    }
  };
  function createWorkspaceEdit(uri, edits) {
    const changes = {};
    changes[uri] = edits;
    const edit = {
      changes
    };
    return edit;
  }
  var CommandExecutor = class {
    constructor() {
      this.commands = /* @__PURE__ */ new Map();
    }
    executeCommand(params) {
      if (this.commands.has(params.command)) {
        const handler = this.commands.get(params.command);
        return handler(...params.arguments);
      }
      throw new Error(`Command '${params.command}' not found`);
    }
    registerCommand(commandId, handler) {
      this.commands.set(commandId, handler);
    }
  };
  var commandExecutor = new CommandExecutor();
  function doDocumentOnTypeFormatting(document2, params) {
    const { position } = params;
    const tb = new TextBuffer(document2);
    if (params.ch === "\n") {
      const previousLine = tb.getLineContent(position.line - 1);
      if (previousLine.trimRight().endsWith(":")) {
        const currentLine = tb.getLineContent(position.line);
        const subLine = currentLine.substring(position.character, currentLine.length);
        const isInArray = previousLine.indexOf(" - ") !== -1;
        if (subLine.trimRight().length === 0) {
          const indentationFix = position.character - (previousLine.length - previousLine.trimLeft().length);
          if (indentationFix === params.options.tabSize && !isInArray) {
            return;
          }
          const result = [];
          if (currentLine.length > 0) {
            result.push(TextEdit.del(Range2.create(position, Position2.create(position.line, currentLine.length - 1))));
          }
          result.push(TextEdit.insert(position, " ".repeat(params.options.tabSize + (isInArray ? 2 - indentationFix : 0))));
          return result;
        }
        if (isInArray) {
          return [TextEdit.insert(position, " ".repeat(params.options.tabSize))];
        }
      }
      if (previousLine.trimRight().endsWith("|")) {
        return [TextEdit.insert(position, " ".repeat(params.options.tabSize))];
      }
      if (previousLine.includes(" - ") && !previousLine.includes(": ")) {
        return [TextEdit.insert(position, "- ")];
      }
      if (previousLine.includes(" - ") && previousLine.includes(": ")) {
        return [TextEdit.insert(position, "  ")];
      }
    }
  }
  function getSchemaUrls(schema5) {
    const result = /* @__PURE__ */ new Map();
    if (!schema5) {
      return result;
    }
    if (schema5.url) {
      if (schema5.url.startsWith("schemaservice://combinedSchema/")) {
        addSchemasForOf(schema5, result);
      } else {
        result.set(schema5.url, schema5);
      }
    } else {
      addSchemasForOf(schema5, result);
    }
    return result;
  }
  function addSchemasForOf(schema5, result) {
    if (schema5.allOf) {
      addInnerSchemaUrls(schema5.allOf, result);
    }
    if (schema5.anyOf) {
      addInnerSchemaUrls(schema5.anyOf, result);
    }
    if (schema5.oneOf) {
      addInnerSchemaUrls(schema5.oneOf, result);
    }
  }
  function addInnerSchemaUrls(schemas2, result) {
    for (const subSchema of schemas2) {
      if (!isBoolean2(subSchema) && subSchema.url && !result.has(subSchema.url)) {
        result.set(subSchema.url, subSchema);
      }
    }
  }
  var YamlCodeLens = class {
    constructor(schemaService, telemetry2) {
      this.schemaService = schemaService;
      this.telemetry = telemetry2;
    }
    async getCodeLens(document2) {
      const result = [];
      try {
        const yamlDocument = yamlDocumentsCache.getYamlDocument(document2);
        let schemaUrls = /* @__PURE__ */ new Map();
        for (const currentYAMLDoc of yamlDocument.documents) {
          const schema5 = await this.schemaService.getSchemaForResource(document2.uri, currentYAMLDoc);
          if (schema5 == null ? void 0 : schema5.schema) {
            schemaUrls = new Map([...getSchemaUrls(schema5 == null ? void 0 : schema5.schema), ...schemaUrls]);
          }
        }
        for (const urlToSchema of schemaUrls) {
          const lens = CodeLens.create(Range2.create(0, 0, 0, 0));
          lens.command = {
            title: getSchemaTitle(urlToSchema[1], urlToSchema[0]),
            command: YamlCommands.JUMP_TO_SCHEMA,
            arguments: [urlToSchema[0]]
          };
          result.push(lens);
        }
      } catch (err) {
        this.telemetry.sendError("yaml.codeLens.error", { error: convertErrorToTelemetryMsg(err) });
      }
      return result;
    }
    resolveCodeLens(param) {
      return param;
    }
  };
  function registerCommands(commandExecutor2, connection) {
    commandExecutor2.registerCommand(YamlCommands.JUMP_TO_SCHEMA, async (uri) => {
      if (!uri) {
        return;
      }
      if (!uri.startsWith("file") && !/^[a-z]:[\\/]/i.test(uri)) {
        const origUri = URI2.parse(uri);
        const customUri = URI2.from({
          scheme: "json-schema",
          authority: origUri.authority,
          path: origUri.path.endsWith(".json") ? origUri.path : origUri.path + ".json",
          fragment: uri
        });
        uri = customUri.toString();
      }
      if (/^[a-z]:[\\/]/i.test(uri)) {
        const winUri = URI2.file(uri);
        uri = winUri.toString();
      }
      const result = await connection.window.showDocument({ uri, external: false, takeFocus: true });
      if (!result) {
        connection.window.showErrorMessage(`Cannot open ${uri}`);
      }
    });
  }
  var SpacesDiffResult = class {
    constructor() {
      this.spacesDiff = 0;
      this.looksLikeAlignment = false;
    }
  };
  function spacesDiff(a2, aLength, b, bLength, result) {
    result.spacesDiff = 0;
    result.looksLikeAlignment = false;
    let i;
    for (i = 0; i < aLength && i < bLength; i++) {
      const aCharCode = a2.charCodeAt(i);
      const bCharCode = b.charCodeAt(i);
      if (aCharCode !== bCharCode) {
        break;
      }
    }
    let aSpacesCnt = 0, aTabsCount = 0;
    for (let j = i; j < aLength; j++) {
      const aCharCode = a2.charCodeAt(j);
      if (aCharCode === 32) {
        aSpacesCnt++;
      } else {
        aTabsCount++;
      }
    }
    let bSpacesCnt = 0, bTabsCount = 0;
    for (let j = i; j < bLength; j++) {
      const bCharCode = b.charCodeAt(j);
      if (bCharCode === 32) {
        bSpacesCnt++;
      } else {
        bTabsCount++;
      }
    }
    if (aSpacesCnt > 0 && aTabsCount > 0) {
      return;
    }
    if (bSpacesCnt > 0 && bTabsCount > 0) {
      return;
    }
    const tabsDiff = Math.abs(aTabsCount - bTabsCount);
    const spacesDiff2 = Math.abs(aSpacesCnt - bSpacesCnt);
    if (tabsDiff === 0) {
      result.spacesDiff = spacesDiff2;
      if (spacesDiff2 > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a2.length && bSpacesCnt < b.length) {
        if (b.charCodeAt(bSpacesCnt) !== 32 && a2.charCodeAt(bSpacesCnt - 1) === 32) {
          if (a2.charCodeAt(a2.length - 1) === 44) {
            result.looksLikeAlignment = true;
          }
        }
      }
      return;
    }
    if (spacesDiff2 % tabsDiff === 0) {
      result.spacesDiff = spacesDiff2 / tabsDiff;
    }
  }
  function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {
    const linesCount = Math.min(source.getLineCount(), 1e4);
    let linesIndentedWithTabsCount = 0;
    let linesIndentedWithSpacesCount = 0;
    let previousLineText = "";
    let previousLineIndentation = 0;
    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7];
    const MAX_ALLOWED_TAB_SIZE_GUESS = 8;
    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    const tmp = new SpacesDiffResult();
    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {
      const currentLineLength = source.getLineLength(lineNumber);
      const currentLineText = source.getLineContent(lineNumber);
      const useCurrentLineText = currentLineLength <= 65536;
      let currentLineHasContent = false;
      let currentLineIndentation = 0;
      let currentLineSpacesCount = 0;
      let currentLineTabsCount = 0;
      for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {
        const charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);
        if (charCode === 9) {
          currentLineTabsCount++;
        } else if (charCode === 32) {
          currentLineSpacesCount++;
        } else {
          currentLineHasContent = true;
          currentLineIndentation = j;
          break;
        }
      }
      if (!currentLineHasContent) {
        continue;
      }
      if (currentLineTabsCount > 0) {
        linesIndentedWithTabsCount++;
      } else if (currentLineSpacesCount > 1) {
        linesIndentedWithSpacesCount++;
      }
      spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);
      if (tmp.looksLikeAlignment) {
        if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {
          continue;
        }
      }
      const currentSpacesDiff = tmp.spacesDiff;
      if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
        spacesDiffCount[currentSpacesDiff]++;
      }
      previousLineText = currentLineText;
      previousLineIndentation = currentLineIndentation;
    }
    let insertSpaces = defaultInsertSpaces;
    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
      insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;
    }
    let tabSize = defaultTabSize;
    if (insertSpaces) {
      let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;
      ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {
        const possibleTabSizeScore = spacesDiffCount[possibleTabSize];
        if (possibleTabSizeScore > tabSizeScore) {
          tabSizeScore = possibleTabSizeScore;
          tabSize = possibleTabSize;
        }
      });
      if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {
        tabSize = 2;
      }
    }
    return {
      insertSpaces,
      tabSize
    };
  }
  function stringifyObject2(obj, indent, stringifyLiteral, settings, depth = 0, consecutiveArrays = 0) {
    if (obj !== null && typeof obj === "object") {
      const newIndent = depth === 0 && settings.shouldIndentWithTab || depth > 0 ? indent + settings.indentation : "";
      if (Array.isArray(obj)) {
        consecutiveArrays += 1;
        if (obj.length === 0) {
          return "";
        }
        let result = "";
        for (let i = 0; i < obj.length; i++) {
          let pseudoObj = obj[i];
          if (typeof obj[i] !== "object") {
            result += "\n" + newIndent + "- " + stringifyLiteral(obj[i]);
            continue;
          }
          if (!Array.isArray(obj[i])) {
            pseudoObj = prependToObject(obj[i], consecutiveArrays);
          }
          result += stringifyObject2(pseudoObj, indent, stringifyLiteral, settings, depth += 1, consecutiveArrays);
        }
        return result;
      } else {
        const keys = Object.keys(obj);
        if (keys.length === 0) {
          return "";
        }
        let result = depth === 0 && settings.newLineFirst || depth > 0 ? "\n" : "";
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const isObject2 = typeof obj[key] === "object";
          const colonDelimiter = isObject2 ? ":" : ": ";
          const parentArrayCompensation = isObject2 && /^\s|-/.test(key) ? settings.indentation : "";
          const objectIndent = newIndent + parentArrayCompensation;
          if (depth === 0 && i === 0 && !settings.indentFirstObject) {
            const value = stringifyObject2(obj[key], objectIndent, stringifyLiteral, settings, depth += 1, 0);
            result += indent + key + colonDelimiter + value;
          } else {
            const value = stringifyObject2(obj[key], objectIndent, stringifyLiteral, settings, depth += 1, 0);
            result += newIndent + key + colonDelimiter + value;
          }
          if (i < keys.length - 1) {
            result += "\n";
          }
        }
        return result;
      }
    }
    return stringifyLiteral(obj);
  }
  function prependToObject(obj, consecutiveArrays) {
    const newObj = {};
    for (let i = 0; i < Object.keys(obj).length; i++) {
      const key = Object.keys(obj)[i];
      if (i === 0) {
        newObj["- ".repeat(consecutiveArrays) + key] = obj[key];
      } else {
        newObj["  ".repeat(consecutiveArrays) + key] = obj[key];
      }
    }
    return newObj;
  }
  var localize9 = loadMessageBundle();
  var doubleQuotesEscapeRegExp = /[\\]+"/g;
  var parentCompletionKind = CompletionItemKind2.Class;
  var YamlCompletion = class {
    constructor(schemaService, clientCapabilities = {}, yamlDocument, telemetry2) {
      this.schemaService = schemaService;
      this.clientCapabilities = clientCapabilities;
      this.yamlDocument = yamlDocument;
      this.telemetry = telemetry2;
      this.completionEnabled = true;
      this.arrayPrefixIndentation = "";
    }
    configure(languageSettings) {
      if (languageSettings) {
        this.completionEnabled = languageSettings.completion;
      }
      this.customTags = languageSettings.customTags;
      this.yamlVersion = languageSettings.yamlVersion;
      this.configuredIndentation = languageSettings.indentation;
      this.disableDefaultProperties = languageSettings.disableDefaultProperties;
      this.parentSkeletonSelectedFirst = languageSettings.parentSkeletonSelectedFirst;
    }
    async doComplete(document2, position, isKubernetes = false, doComplete = true) {
      const result = CompletionList.create([], false);
      if (!this.completionEnabled) {
        return result;
      }
      const doc = this.yamlDocument.getYamlDocument(document2, { customTags: this.customTags, yamlVersion: this.yamlVersion }, true);
      const textBuffer = new TextBuffer(document2);
      if (!this.configuredIndentation) {
        const indent = guessIndentation(textBuffer, 2, true);
        this.indentation = indent.insertSpaces ? " ".repeat(indent.tabSize) : "	";
      } else {
        this.indentation = this.configuredIndentation;
      }
      setKubernetesParserOption(doc.documents, isKubernetes);
      for (const jsonDoc of doc.documents) {
        jsonDoc.uri = document2.uri;
      }
      const offset = document2.offsetAt(position);
      const text = document2.getText();
      if (text.charAt(offset - 1) === ":") {
        return Promise.resolve(result);
      }
      let currentDoc = matchOffsetToDocument(offset, doc);
      if (currentDoc === null) {
        return Promise.resolve(result);
      }
      currentDoc = currentDoc.clone();
      let [node, foundByClosest] = currentDoc.getNodeFromPosition(offset, textBuffer, this.indentation.length);
      const currentWord = this.getCurrentWord(document2, offset);
      let lineContent = textBuffer.getLineContent(position.line);
      const lineAfterPosition = lineContent.substring(position.character);
      const areOnlySpacesAfterPosition = /^[ ]+\n?$/.test(lineAfterPosition);
      this.arrayPrefixIndentation = "";
      let overwriteRange = null;
      if (areOnlySpacesAfterPosition) {
        overwriteRange = Range2.create(position, Position2.create(position.line, lineContent.length));
        const isOnlyWhitespace = lineContent.trim().length === 0;
        const isOnlyDash = lineContent.match(/^\s*(-)\s*$/);
        if (node && isScalar(node) && !isOnlyWhitespace && !isOnlyDash) {
          const matches = lineContent.match(/^([\s-]*)[^:]+[ \t]+\n?$/);
          if (matches == null ? void 0 : matches.length) {
            overwriteRange = Range2.create(Position2.create(position.line, matches[1].length), Position2.create(position.line, lineContent.length));
          }
        }
      } else if (node && isScalar(node) && node.value === "null") {
        const nodeStartPos = document2.positionAt(node.range[0]);
        nodeStartPos.character += 1;
        const nodeEndPos = document2.positionAt(node.range[2]);
        nodeEndPos.character += 1;
        overwriteRange = Range2.create(nodeStartPos, nodeEndPos);
      } else if (node && isScalar(node) && node.value) {
        const start = document2.positionAt(node.range[0]);
        if (offset > 0 && start.character > 0 && text.charAt(offset - 1) === "-") {
          start.character -= 1;
        }
        overwriteRange = Range2.create(start, document2.positionAt(node.range[1]));
      } else if (node && isScalar(node) && node.value === null && currentWord === "-") {
        overwriteRange = Range2.create(position, position);
        this.arrayPrefixIndentation = " ";
      } else {
        let overwriteStart = document2.offsetAt(position) - currentWord.length;
        if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
          overwriteStart--;
        }
        overwriteRange = Range2.create(document2.positionAt(overwriteStart), position);
      }
      const proposed = {};
      const existingProposeItem = "__";
      const collector = {
        add: (completionItem, oneOfSchema) => {
          const addSuggestionForParent = function(completionItem2) {
            var _a3;
            const existsInYaml = ((_a3 = proposed[completionItem2.label]) == null ? void 0 : _a3.label) === existingProposeItem;
            if (existsInYaml) {
              return;
            }
            const schema5 = completionItem2.parent.schema;
            const schemaType = getSchemaTypeName(schema5);
            const schemaDescription = schema5.markdownDescription || schema5.description;
            let parentCompletion = result.items.find((item) => {
              var _a22;
              return ((_a22 = item.parent) == null ? void 0 : _a22.schema) === schema5 && item.kind === parentCompletionKind;
            });
            if (parentCompletion && parentCompletion.parent.insertTexts.includes(completionItem2.insertText)) {
              return;
            } else if (!parentCompletion) {
              parentCompletion = {
                ...completionItem2,
                label: schemaType,
                documentation: schemaDescription,
                sortText: "_" + schemaType,
                kind: parentCompletionKind
              };
              parentCompletion.label = parentCompletion.label || completionItem2.label;
              parentCompletion.parent.insertTexts = [completionItem2.insertText];
              result.items.push(parentCompletion);
            } else {
              parentCompletion.parent.insertTexts.push(completionItem2.insertText);
            }
          };
          const isForParentCompletion = !!completionItem.parent;
          let label = completionItem.label;
          if (!label) {
            console.warn(`Ignoring CompletionItem without label: ${JSON.stringify(completionItem)}`);
            return;
          }
          if (!isString22(label)) {
            label = String(label);
          }
          label = label.replace(/[\n]/g, "\u21B5");
          if (label.length > 60) {
            const shortendedLabel = label.substr(0, 57).trim() + "...";
            if (!proposed[shortendedLabel]) {
              label = shortendedLabel;
            }
          }
          if (completionItem.insertText.endsWith("$1") && !isForParentCompletion) {
            completionItem.insertText = completionItem.insertText.substr(0, completionItem.insertText.length - 2);
          }
          if (overwriteRange && overwriteRange.start.line === overwriteRange.end.line) {
            completionItem.textEdit = TextEdit.replace(overwriteRange, completionItem.insertText);
          }
          completionItem.label = label;
          if (isForParentCompletion) {
            addSuggestionForParent(completionItem);
            return;
          }
          if (this.arrayPrefixIndentation) {
            this.updateCompletionText(completionItem, this.arrayPrefixIndentation + completionItem.insertText);
          }
          const existing = proposed[label];
          const isInsertTextDifferent = (existing == null ? void 0 : existing.label) !== existingProposeItem && (existing == null ? void 0 : existing.insertText) !== completionItem.insertText;
          if (!existing) {
            proposed[label] = completionItem;
            result.items.push(completionItem);
          } else if (isInsertTextDifferent) {
            const mergedText = this.mergeSimpleInsertTexts(label, existing.insertText, completionItem.insertText, oneOfSchema);
            if (mergedText) {
              this.updateCompletionText(existing, mergedText);
            } else {
              proposed[label] = completionItem;
              result.items.push(completionItem);
            }
          }
          if (existing && !existing.documentation && completionItem.documentation) {
            existing.documentation = completionItem.documentation;
          }
        },
        error: (message) => {
          this.telemetry.sendError("yaml.completion.error", { error: convertErrorToTelemetryMsg(message) });
        },
        log: (message) => {
          console.log(message);
        },
        getNumberOfProposals: () => {
          return result.items.length;
        },
        result
      };
      if (this.customTags.length > 0) {
        this.getCustomTagValueCompletions(collector);
      }
      if (lineContent.endsWith("\n")) {
        lineContent = lineContent.substr(0, lineContent.length - 1);
      }
      try {
        const schema5 = await this.schemaService.getSchemaForResource(document2.uri, currentDoc);
        if (!schema5 || schema5.errors.length) {
          if (position.line === 0 && position.character === 0 && !isModeline(lineContent)) {
            const inlineSchemaCompletion = {
              kind: CompletionItemKind2.Text,
              label: "Inline schema",
              insertText: "# yaml-language-server: $schema=",
              insertTextFormat: InsertTextFormat.PlainText
            };
            result.items.push(inlineSchemaCompletion);
          }
        }
        if (isModeline(lineContent) || isInComment(doc.tokens, offset)) {
          const schemaIndex = lineContent.indexOf("$schema=");
          if (schemaIndex !== -1 && schemaIndex + "$schema=".length <= position.character) {
            this.schemaService.getAllSchemas().forEach((schema22) => {
              var _a3;
              const schemaIdCompletion = {
                kind: CompletionItemKind2.Constant,
                label: (_a3 = schema22.name) != null ? _a3 : schema22.uri,
                detail: schema22.description,
                insertText: schema22.uri,
                insertTextFormat: InsertTextFormat.PlainText,
                insertTextMode: InsertTextMode.asIs
              };
              result.items.push(schemaIdCompletion);
            });
          }
          return result;
        }
        if (!schema5 || schema5.errors.length) {
          return result;
        }
        let currentProperty = null;
        if (!node) {
          if (!currentDoc.internalDocument.contents || isScalar(currentDoc.internalDocument.contents)) {
            const map2 = currentDoc.internalDocument.createNode({});
            map2.range = [offset, offset + 1, offset + 1];
            currentDoc.internalDocument.contents = map2;
            currentDoc.internalDocument = currentDoc.internalDocument;
            node = map2;
          } else {
            node = currentDoc.findClosestNode(offset, textBuffer);
            foundByClosest = true;
          }
        }
        const originalNode = node;
        if (node) {
          if (lineContent.length === 0) {
            node = currentDoc.internalDocument.contents;
          } else {
            const parent = currentDoc.getParent(node);
            if (parent) {
              if (isScalar(node)) {
                if (node.value) {
                  if (isPair(parent)) {
                    if (parent.value === node) {
                      if (lineContent.trim().length > 0 && lineContent.indexOf(":") < 0) {
                        const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                        const parentParent = currentDoc.getParent(parent);
                        if (isSeq(currentDoc.internalDocument.contents)) {
                          const index = indexOf(currentDoc.internalDocument.contents, parent);
                          if (typeof index === "number") {
                            currentDoc.internalDocument.set(index, map2);
                            currentDoc.internalDocument = currentDoc.internalDocument;
                          }
                        } else if (parentParent && (isMap(parentParent) || isSeq(parentParent))) {
                          parentParent.set(parent.key, map2);
                          currentDoc.internalDocument = currentDoc.internalDocument;
                        } else {
                          currentDoc.internalDocument.set(parent.key, map2);
                          currentDoc.internalDocument = currentDoc.internalDocument;
                        }
                        currentProperty = map2.items[0];
                        node = map2;
                      } else if (lineContent.trim().length === 0) {
                        const parentParent = currentDoc.getParent(parent);
                        if (parentParent) {
                          node = parentParent;
                        }
                      }
                    } else if (parent.key === node) {
                      const parentParent = currentDoc.getParent(parent);
                      currentProperty = parent;
                      if (parentParent) {
                        node = parentParent;
                      }
                    }
                  } else if (isSeq(parent)) {
                    if (lineContent.trim().length > 0) {
                      const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                      parent.delete(node);
                      parent.add(map2);
                      currentDoc.internalDocument = currentDoc.internalDocument;
                      node = map2;
                    } else {
                      node = parent;
                    }
                  }
                } else if (node.value === null) {
                  if (isPair(parent)) {
                    if (parent.key === node) {
                      node = parent;
                    } else {
                      if (isNode(parent.key) && parent.key.range) {
                        const parentParent = currentDoc.getParent(parent);
                        if (foundByClosest && parentParent && isMap(parentParent) && isMapContainsEmptyPair(parentParent)) {
                          node = parentParent;
                        } else {
                          const parentPosition = document2.positionAt(parent.key.range[0]);
                          if (position.character > parentPosition.character && position.line !== parentPosition.line) {
                            const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                            if (parentParent && (isMap(parentParent) || isSeq(parentParent))) {
                              parentParent.set(parent.key, map2);
                              currentDoc.internalDocument = currentDoc.internalDocument;
                            } else {
                              currentDoc.internalDocument.set(parent.key, map2);
                              currentDoc.internalDocument = currentDoc.internalDocument;
                            }
                            currentProperty = map2.items[0];
                            node = map2;
                          } else if (parentPosition.character === position.character) {
                            if (parentParent) {
                              node = parentParent;
                            }
                          }
                        }
                      }
                    }
                  } else if (isSeq(parent)) {
                    if (lineContent.charAt(position.character - 1) !== "-") {
                      const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                      parent.delete(node);
                      parent.add(map2);
                      currentDoc.internalDocument = currentDoc.internalDocument;
                      node = map2;
                    } else if (lineContent.charAt(position.character - 1) === "-") {
                      const map2 = this.createTempObjNode("", node, currentDoc);
                      parent.delete(node);
                      parent.add(map2);
                      currentDoc.internalDocument = currentDoc.internalDocument;
                      node = map2;
                    } else {
                      node = parent;
                    }
                  }
                }
              } else if (isMap(node)) {
                if (!foundByClosest && lineContent.trim().length === 0 && isSeq(parent)) {
                  const nextLine = textBuffer.getLineContent(position.line + 1);
                  if (textBuffer.getLineCount() === position.line + 1 || nextLine.trim().length === 0) {
                    node = parent;
                  }
                }
              }
            } else if (isScalar(node)) {
              const map2 = this.createTempObjNode(currentWord, node, currentDoc);
              currentDoc.internalDocument.contents = map2;
              currentDoc.internalDocument = currentDoc.internalDocument;
              currentProperty = map2.items[0];
              node = map2;
            } else if (isMap(node)) {
              for (const pair of node.items) {
                if (isNode(pair.value) && pair.value.range && pair.value.range[0] === offset + 1) {
                  node = pair.value;
                }
              }
            } else if (isSeq(node)) {
              if (lineContent.charAt(position.character - 1) !== "-") {
                const map2 = this.createTempObjNode(currentWord, node, currentDoc);
                map2.items = [];
                currentDoc.internalDocument = currentDoc.internalDocument;
                for (const pair of node.items) {
                  if (isMap(pair)) {
                    pair.items.forEach((value) => {
                      map2.items.push(value);
                    });
                  }
                }
                node = map2;
              }
            }
          }
        }
        if (node && isMap(node)) {
          const properties = node.items;
          for (const p of properties) {
            if (!currentProperty || currentProperty !== p) {
              if (isScalar(p.key)) {
                proposed[p.key.value + ""] = CompletionItem.create(existingProposeItem);
              }
            }
          }
          this.addPropertyCompletions(schema5, currentDoc, node, originalNode, "", collector, textBuffer, overwriteRange, doComplete);
          if (!schema5 && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"') {
            collector.add({
              kind: CompletionItemKind2.Property,
              label: currentWord,
              insertText: this.getInsertTextForProperty(currentWord, null, ""),
              insertTextFormat: InsertTextFormat.Snippet
            });
          }
        }
        const types = {};
        this.getValueCompletions(schema5, currentDoc, node, offset, document2, collector, types, doComplete);
      } catch (err) {
        this.telemetry.sendError("yaml.completion.error", { error: convertErrorToTelemetryMsg(err) });
      }
      this.finalizeParentCompletion(result);
      const uniqueItems = result.items.filter((arr, index, self2) => index === self2.findIndex((item) => item.label === arr.label && item.insertText === arr.insertText && item.kind === arr.kind));
      if ((uniqueItems == null ? void 0 : uniqueItems.length) > 0) {
        result.items = uniqueItems;
      }
      return result;
    }
    updateCompletionText(completionItem, text) {
      completionItem.insertText = text;
      if (completionItem.textEdit) {
        completionItem.textEdit.newText = text;
      }
    }
    mergeSimpleInsertTexts(label, existingText, addingText, oneOfSchema) {
      const containsNewLineAfterColon = (value) => {
        return value.includes("\n");
      };
      const startWithNewLine = (value) => {
        return value.startsWith("\n");
      };
      const isNullObject = (value) => {
        const index = value.indexOf("\n");
        return index > 0 && value.substring(index, value.length).trim().length === 0;
      };
      if (containsNewLineAfterColon(existingText) || containsNewLineAfterColon(addingText)) {
        if (oneOfSchema && isNullObject(existingText) && !isNullObject(addingText) && !startWithNewLine(addingText)) {
          return addingText;
        }
        return void 0;
      }
      const existingValues = this.getValuesFromInsertText(existingText);
      const addingValues = this.getValuesFromInsertText(addingText);
      const newValues = Array.prototype.concat(existingValues, addingValues);
      if (!newValues.length) {
        return void 0;
      } else if (newValues.length === 1) {
        return `${label}: \${1:${newValues[0]}}`;
      } else {
        return `${label}: \${1|${newValues.join(",")}|}`;
      }
    }
    getValuesFromInsertText(insertText) {
      const value = insertText.substring(insertText.indexOf(":") + 1).trim();
      if (!value) {
        return [];
      }
      const valueMath = value.match(/^\${1[|:]([^|]*)+\|?}$/);
      if (valueMath) {
        return valueMath[1].split(",");
      }
      return [value];
    }
    finalizeParentCompletion(result) {
      const reindexText = (insertTexts) => {
        let max$index = 0;
        return insertTexts.map((text) => {
          const match = text.match(/\$([0-9]+)|\${[0-9]+:/g);
          if (!match) {
            return text;
          }
          const max$indexLocal = match.map((m) => +m.replace(/\${([0-9]+)[:|]/g, "$1").replace("$", "")).reduce((p, n) => n > p ? n : p, 0);
          const reindexedStr = text.replace(/\$([0-9]+)/g, (s, args) => "$" + (+args + max$index)).replace(/\${([0-9]+)[:|]/g, (s, args) => "${" + (+args + max$index) + ":");
          max$index += max$indexLocal;
          return reindexedStr;
        });
      };
      result.items.forEach((completionItem) => {
        if (isParentCompletionItem(completionItem)) {
          const indent = completionItem.parent.indent || "";
          const reindexedTexts = reindexText(completionItem.parent.insertTexts);
          let insertText = reindexedTexts.join(`
${indent}`);
          if (insertText.endsWith("$1")) {
            insertText = insertText.substring(0, insertText.length - 2);
          }
          completionItem.insertText = this.arrayPrefixIndentation + insertText;
          if (completionItem.textEdit) {
            completionItem.textEdit.newText = completionItem.insertText;
          }
          const mdText = insertText.replace(/\${[0-9]+[:|](.*)}/g, (s, arg) => arg).replace(/\$([0-9]+)/g, "");
          const originalDocumentation = completionItem.documentation ? [completionItem.documentation, "", "----", ""] : [];
          completionItem.documentation = {
            kind: MarkupKind.Markdown,
            value: [...originalDocumentation, "```yaml", indent + mdText, "```"].join("\n")
          };
          delete completionItem.parent;
        }
      });
    }
    createTempObjNode(currentWord, node, currentDoc) {
      const obj = {};
      obj[currentWord] = null;
      const map2 = currentDoc.internalDocument.createNode(obj);
      map2.range = node.range;
      map2.items[0].key.range = node.range;
      map2.items[0].value.range = node.range;
      return map2;
    }
    addPropertyCompletions(schema5, doc, node, originalNode, separatorAfter, collector, textBuffer, overwriteRange, doComplete) {
      var _a3, _b, _c;
      const matchingSchemas = doc.getMatchingSchemas(schema5.schema, -1, null, doComplete);
      const existingKey = textBuffer.getText(overwriteRange);
      const lineContent = textBuffer.getLineContent(overwriteRange.start.line);
      const hasOnlyWhitespace = lineContent.trim().length === 0;
      const hasColon = lineContent.indexOf(":") !== -1;
      const isInArray = lineContent.trimLeft().indexOf("-") === 0;
      const nodeParent = doc.getParent(node);
      const matchOriginal = matchingSchemas.find((it) => it.node.internalNode === originalNode && it.schema.properties);
      const oneOfSchema = matchingSchemas.filter((schema22) => schema22.schema.oneOf).map((oneOfSchema2) => oneOfSchema2.schema.oneOf)[0];
      let didOneOfSchemaMatches = false;
      if ((oneOfSchema == null ? void 0 : oneOfSchema.length) < matchingSchemas.length) {
        oneOfSchema == null ? void 0 : oneOfSchema.forEach((property2, index) => {
          var _a22, _b2;
          if (!((_a22 = matchingSchemas[index]) == null ? void 0 : _a22.schema.oneOf) && ((_b2 = matchingSchemas[index]) == null ? void 0 : _b2.schema.properties) === property2.properties) {
            didOneOfSchemaMatches = true;
          }
        });
      }
      for (const schema22 of matchingSchemas) {
        if ((schema22.node.internalNode === node && !matchOriginal || schema22.node.internalNode === originalNode && !hasColon || ((_a3 = schema22.node.parent) == null ? void 0 : _a3.internalNode) === originalNode && !hasColon) && !schema22.inverted) {
          this.collectDefaultSnippets(schema22.schema, separatorAfter, collector, {
            newLineFirst: false,
            indentFirstObject: false,
            shouldIndentWithTab: isInArray
          });
          const schemaProperties = schema22.schema.properties;
          if (schemaProperties) {
            const maxProperties = schema22.schema.maxProperties;
            if (maxProperties === void 0 || node.items === void 0 || node.items.length < maxProperties || node.items.length === maxProperties && !hasOnlyWhitespace) {
              for (const key in schemaProperties) {
                if (Object.prototype.hasOwnProperty.call(schemaProperties, key)) {
                  const propertySchema = schemaProperties[key];
                  if (typeof propertySchema === "object" && !propertySchema.deprecationMessage && !propertySchema["doNotSuggest"]) {
                    let identCompensation = "";
                    if (nodeParent && isSeq(nodeParent) && node.items.length <= 1 && !hasOnlyWhitespace) {
                      const sourceText = textBuffer.getText();
                      const indexOfSlash = sourceText.lastIndexOf("-", node.range[0] - 1);
                      if (indexOfSlash >= 0) {
                        const overwriteChars = overwriteRange.end.character - overwriteRange.start.character;
                        identCompensation = " " + sourceText.slice(indexOfSlash + 1, node.range[1] - overwriteChars);
                      }
                    }
                    identCompensation += this.arrayPrefixIndentation;
                    let pair;
                    if (propertySchema.type === "array" && (pair = node.items.find((it) => isScalar(it.key) && it.key.range && it.key.value === key && isScalar(it.value) && !it.value.value && textBuffer.getPosition(it.key.range[2]).line === overwriteRange.end.line - 1)) && pair) {
                      if (Array.isArray(propertySchema.items)) {
                        this.addSchemaValueCompletions(propertySchema.items[0], separatorAfter, collector, {}, "property");
                      } else if (typeof propertySchema.items === "object" && propertySchema.items.type === "object") {
                        this.addArrayItemValueCompletion(propertySchema.items, separatorAfter, collector);
                      }
                    }
                    let insertText = key;
                    if (!key.startsWith(existingKey) || !hasColon) {
                      insertText = this.getInsertTextForProperty(key, propertySchema, separatorAfter, identCompensation + this.indentation);
                    }
                    const isNodeNull = isScalar(originalNode) && originalNode.value === null || isMap(originalNode) && originalNode.items.length === 0;
                    const existsParentCompletion = ((_b = schema22.schema.required) == null ? void 0 : _b.length) > 0;
                    if (!this.parentSkeletonSelectedFirst || !isNodeNull || !existsParentCompletion) {
                      collector.add({
                        kind: CompletionItemKind2.Property,
                        label: key,
                        insertText,
                        insertTextFormat: InsertTextFormat.Snippet,
                        documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || ""
                      }, didOneOfSchemaMatches);
                    }
                    if ((_c = schema22.schema.required) == null ? void 0 : _c.includes(key)) {
                      collector.add({
                        label: key,
                        insertText: this.getInsertTextForProperty(key, propertySchema, separatorAfter, identCompensation + this.indentation),
                        insertTextFormat: InsertTextFormat.Snippet,
                        documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || "",
                        parent: {
                          schema: schema22.schema,
                          indent: identCompensation
                        }
                      });
                    }
                  }
                }
              }
            }
          }
          if (nodeParent && isSeq(nodeParent) && isPrimitiveType(schema22.schema)) {
            this.addSchemaValueCompletions(schema22.schema, separatorAfter, collector, {}, "property", Array.isArray(nodeParent.items));
          }
          if (schema22.schema.propertyNames && schema22.schema.additionalProperties && schema22.schema.type === "object") {
            const propertyNameSchema = asSchema2(schema22.schema.propertyNames);
            const label = propertyNameSchema.title || "property";
            collector.add({
              kind: CompletionItemKind2.Property,
              label,
              insertText: `\${1:${label}}: `,
              insertTextFormat: InsertTextFormat.Snippet,
              documentation: this.fromMarkup(propertyNameSchema.markdownDescription) || propertyNameSchema.description || ""
            });
          }
        }
        if (nodeParent && schema22.node.internalNode === nodeParent && schema22.schema.defaultSnippets) {
          if (node.items.length === 1) {
            this.collectDefaultSnippets(schema22.schema, separatorAfter, collector, {
              newLineFirst: false,
              indentFirstObject: false,
              shouldIndentWithTab: true
            }, 1);
          } else {
            this.collectDefaultSnippets(schema22.schema, separatorAfter, collector, {
              newLineFirst: false,
              indentFirstObject: true,
              shouldIndentWithTab: false
            }, 1);
          }
        }
      }
    }
    getValueCompletions(schema5, doc, node, offset, document2, collector, types, doComplete) {
      let parentKey = null;
      if (node && isScalar(node)) {
        node = doc.getParent(node);
      }
      if (!node) {
        this.addSchemaValueCompletions(schema5.schema, "", collector, types, "value");
        return;
      }
      if (isPair(node)) {
        const valueNode = node.value;
        if (valueNode && valueNode.range && offset > valueNode.range[0] + valueNode.range[2]) {
          return;
        }
        parentKey = isScalar(node.key) ? node.key.value + "" : null;
        node = doc.getParent(node);
      }
      if (node && (parentKey !== null || isSeq(node))) {
        const separatorAfter = "";
        const matchingSchemas = doc.getMatchingSchemas(schema5.schema, -1, null, doComplete);
        for (const s of matchingSchemas) {
          if (s.node.internalNode === node && !s.inverted && s.schema) {
            if (s.schema.items) {
              this.collectDefaultSnippets(s.schema, separatorAfter, collector, {
                newLineFirst: false,
                indentFirstObject: false,
                shouldIndentWithTab: false
              });
              if (isSeq(node) && node.items) {
                if (Array.isArray(s.schema.items)) {
                  const index = this.findItemAtOffset(node, document2, offset);
                  if (index < s.schema.items.length) {
                    this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, collector, types, "value");
                  }
                } else if (typeof s.schema.items === "object" && (s.schema.items.type === "object" || isAnyOfAllOfOneOfType(s.schema.items))) {
                  this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types, "value", true);
                } else {
                  this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types, "value");
                }
              }
            }
            if (s.schema.properties) {
              const propertySchema = s.schema.properties[parentKey];
              if (propertySchema) {
                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types, "value");
              }
            } else if (s.schema.additionalProperties) {
              this.addSchemaValueCompletions(s.schema.additionalProperties, separatorAfter, collector, types, "value");
            }
          }
        }
        if (types["boolean"]) {
          this.addBooleanValueCompletion(true, separatorAfter, collector);
          this.addBooleanValueCompletion(false, separatorAfter, collector);
        }
        if (types["null"]) {
          this.addNullValueCompletion(separatorAfter, collector);
        }
      }
    }
    addArrayItemValueCompletion(schema5, separatorAfter, collector, index) {
      const schemaType = getSchemaTypeName(schema5);
      const insertText = `- ${this.getInsertTextForObject(schema5, separatorAfter).insertText.trimLeft()}`;
      const schemaTypeTitle = schemaType ? " type `" + schemaType + "`" : "";
      const schemaDescription = schema5.description ? " (" + schema5.description + ")" : "";
      const documentation = this.getDocumentationWithMarkdownText(`Create an item of an array${schemaTypeTitle}${schemaDescription}`, insertText);
      collector.add({
        kind: this.getSuggestionKind(schema5.type),
        label: "- (array item) " + (schemaType || index),
        documentation,
        insertText,
        insertTextFormat: InsertTextFormat.Snippet
      });
    }
    getInsertTextForProperty(key, propertySchema, separatorAfter, indent = this.indentation) {
      const propertyText = this.getInsertTextForValue(key, "", "string");
      const resultText = propertyText + ":";
      let value;
      let nValueProposals = 0;
      if (propertySchema) {
        let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
        if (!type) {
          if (propertySchema.properties) {
            type = "object";
          } else if (propertySchema.items) {
            type = "array";
          } else if (propertySchema.anyOf) {
            type = "anyOf";
          }
        }
        if (Array.isArray(propertySchema.defaultSnippets)) {
          if (propertySchema.defaultSnippets.length === 1) {
            const body = propertySchema.defaultSnippets[0].body;
            if (isDefined2(body)) {
              value = this.getInsertTextForSnippetValue(body, "", {
                newLineFirst: true,
                indentFirstObject: false,
                shouldIndentWithTab: false
              }, 1);
              if (!value.startsWith(" ") && !value.startsWith("\n")) {
                value = " " + value;
              }
            }
          }
          nValueProposals += propertySchema.defaultSnippets.length;
        }
        if (propertySchema.enum) {
          if (!value && propertySchema.enum.length === 1) {
            value = " " + this.getInsertTextForGuessedValue(propertySchema.enum[0], "", type);
          }
          nValueProposals += propertySchema.enum.length;
        }
        if (propertySchema.const) {
          if (!value) {
            value = this.getInsertTextForGuessedValue(propertySchema.const, "", type);
            value = evaluateTab1Symbol(value);
            value = " " + value;
          }
          nValueProposals++;
        }
        if (isDefined2(propertySchema.default)) {
          if (!value) {
            value = " " + this.getInsertTextForGuessedValue(propertySchema.default, "", type);
          }
          nValueProposals++;
        }
        if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
          if (!value) {
            value = " " + this.getInsertTextForGuessedValue(propertySchema.examples[0], "", type);
          }
          nValueProposals += propertySchema.examples.length;
        }
        if (propertySchema.properties) {
          return `${resultText}
${this.getInsertTextForObject(propertySchema, separatorAfter, indent).insertText}`;
        } else if (propertySchema.items) {
          return `${resultText}
${indent}- ${this.getInsertTextForArray(propertySchema.items, separatorAfter, 1, indent).insertText}`;
        }
        if (nValueProposals === 0) {
          switch (type) {
            case "boolean":
              value = " $1";
              break;
            case "string":
              value = " $1";
              break;
            case "object":
              value = `
${indent}`;
              break;
            case "array":
              value = `
${indent}- `;
              break;
            case "number":
            case "integer":
              value = " ${1:0}";
              break;
            case "null":
              value = " ${1:null}";
              break;
            case "anyOf":
              value = " $1";
              break;
            default:
              return propertyText;
          }
        }
      }
      if (!value || nValueProposals > 1) {
        value = " $1";
      }
      return resultText + value + separatorAfter;
    }
    getInsertTextForObject(schema5, separatorAfter, indent = this.indentation, insertIndex = 1) {
      let insertText = "";
      if (!schema5.properties) {
        insertText = `${indent}$${insertIndex++}
`;
        return { insertText, insertIndex };
      }
      Object.keys(schema5.properties).forEach((key) => {
        const propertySchema = schema5.properties[key];
        let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
        if (!type) {
          if (propertySchema.anyOf) {
            type = "anyOf";
          }
          if (propertySchema.properties) {
            type = "object";
          }
          if (propertySchema.items) {
            type = "array";
          }
        }
        if (schema5.required && schema5.required.indexOf(key) > -1) {
          switch (type) {
            case "boolean":
            case "string":
            case "number":
            case "integer":
            case "anyOf": {
              let value = propertySchema.default || propertySchema.const;
              if (value) {
                if (type === "string") {
                  value = convertToStringValue(value);
                }
                insertText += `${indent}${key}: \${${insertIndex++}:${value}}
`;
              } else {
                insertText += `${indent}${key}: $${insertIndex++}
`;
              }
              break;
            }
            case "array":
              {
                const arrayInsertResult = this.getInsertTextForArray(propertySchema.items, separatorAfter, insertIndex++, indent);
                const arrayInsertLines = arrayInsertResult.insertText.split("\n");
                let arrayTemplate = arrayInsertResult.insertText;
                if (arrayInsertLines.length > 1) {
                  for (let index = 1; index < arrayInsertLines.length; index++) {
                    const element = arrayInsertLines[index];
                    arrayInsertLines[index] = `  ${element}`;
                  }
                  arrayTemplate = arrayInsertLines.join("\n");
                }
                insertIndex = arrayInsertResult.insertIndex;
                insertText += `${indent}${key}:
${indent}${this.indentation}- ${arrayTemplate}
`;
              }
              break;
            case "object":
              {
                const objectInsertResult = this.getInsertTextForObject(propertySchema, separatorAfter, `${indent}${this.indentation}`, insertIndex++);
                insertIndex = objectInsertResult.insertIndex;
                insertText += `${indent}${key}:
${objectInsertResult.insertText}
`;
              }
              break;
          }
        } else if (!this.disableDefaultProperties && propertySchema.default !== void 0) {
          switch (type) {
            case "boolean":
            case "number":
            case "integer":
              insertText += `${indent}${//added quote if key is null
              key === "null" ? this.getInsertTextForValue(key, "", "string") : key}: \${${insertIndex++}:${propertySchema.default}}
`;
              break;
            case "string":
              insertText += `${indent}${key}: \${${insertIndex++}:${convertToStringValue(propertySchema.default)}}
`;
              break;
            case "array":
            case "object":
              break;
          }
        }
      });
      if (insertText.trim().length === 0) {
        insertText = `${indent}$${insertIndex++}
`;
      }
      insertText = insertText.trimRight() + separatorAfter;
      return { insertText, insertIndex };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getInsertTextForArray(schema5, separatorAfter, insertIndex = 1, indent = this.indentation) {
      let insertText = "";
      if (!schema5) {
        insertText = `$${insertIndex++}`;
        return { insertText, insertIndex };
      }
      let type = Array.isArray(schema5.type) ? schema5.type[0] : schema5.type;
      if (!type) {
        if (schema5.properties) {
          type = "object";
        }
        if (schema5.items) {
          type = "array";
        }
      }
      switch (schema5.type) {
        case "boolean":
          insertText = `\${${insertIndex++}:false}`;
          break;
        case "number":
        case "integer":
          insertText = `\${${insertIndex++}:0}`;
          break;
        case "string":
          insertText = `\${${insertIndex++}:""}`;
          break;
        case "object":
          {
            const objectInsertResult = this.getInsertTextForObject(schema5, separatorAfter, `${indent}  `, insertIndex++);
            insertText = objectInsertResult.insertText.trimLeft();
            insertIndex = objectInsertResult.insertIndex;
          }
          break;
      }
      return { insertText, insertIndex };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getInsertTextForGuessedValue(value, separatorAfter, type) {
      switch (typeof value) {
        case "object":
          if (value === null) {
            return "${1:null}" + separatorAfter;
          }
          return this.getInsertTextForValue(value, separatorAfter, type);
        case "string": {
          let snippetValue = JSON.stringify(value);
          snippetValue = snippetValue.substr(1, snippetValue.length - 2);
          snippetValue = this.getInsertTextForPlainText(snippetValue);
          if (type === "string") {
            snippetValue = convertToStringValue(snippetValue);
          }
          return "${1:" + snippetValue + "}" + separatorAfter;
        }
        case "number":
        case "boolean":
          return "${1:" + value + "}" + separatorAfter;
      }
      return this.getInsertTextForValue(value, separatorAfter, type);
    }
    getInsertTextForPlainText(text) {
      return text.replace(/[\\$}]/g, "\\$&");
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getInsertTextForValue(value, separatorAfter, type) {
      if (value === null) {
        return "null";
      }
      switch (typeof value) {
        case "object": {
          const indent = this.indentation;
          return this.getInsertTemplateForValue(value, indent, { index: 1 }, separatorAfter);
        }
        case "number":
        case "boolean":
          return this.getInsertTextForPlainText(value + separatorAfter);
      }
      type = Array.isArray(type) ? type[0] : type;
      if (type === "string") {
        value = convertToStringValue(value);
      }
      return this.getInsertTextForPlainText(value + separatorAfter);
    }
    getInsertTemplateForValue(value, indent, navOrder, separatorAfter) {
      if (Array.isArray(value)) {
        let insertText = "\n";
        for (const arrValue of value) {
          insertText += `${indent}- \${${navOrder.index++}:${arrValue}}
`;
        }
        return insertText;
      } else if (typeof value === "object") {
        let insertText = "\n";
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            const element = value[key];
            insertText += `${indent}\${${navOrder.index++}:${key}}:`;
            let valueTemplate;
            if (typeof element === "object") {
              valueTemplate = `${this.getInsertTemplateForValue(element, indent + this.indentation, navOrder, separatorAfter)}`;
            } else {
              valueTemplate = ` \${${navOrder.index++}:${this.getInsertTextForPlainText(element + separatorAfter)}}
`;
            }
            insertText += `${valueTemplate}`;
          }
        }
        return insertText;
      }
      return this.getInsertTextForPlainText(value + separatorAfter);
    }
    addSchemaValueCompletions(schema5, separatorAfter, collector, types, completionType, isArray) {
      if (typeof schema5 === "object") {
        this.addEnumValueCompletions(schema5, separatorAfter, collector, isArray);
        this.addDefaultValueCompletions(schema5, separatorAfter, collector);
        this.collectTypes(schema5, types);
        if (isArray && completionType === "value" && !isAnyOfAllOfOneOfType(schema5)) {
          this.addArrayItemValueCompletion(schema5, separatorAfter, collector);
        }
        if (Array.isArray(schema5.allOf)) {
          schema5.allOf.forEach((s) => {
            return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);
          });
        }
        if (Array.isArray(schema5.anyOf)) {
          schema5.anyOf.forEach((s) => {
            return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);
          });
        }
        if (Array.isArray(schema5.oneOf)) {
          schema5.oneOf.forEach((s) => {
            return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);
          });
        }
      }
    }
    collectTypes(schema5, types) {
      if (Array.isArray(schema5.enum) || isDefined2(schema5.const)) {
        return;
      }
      const type = schema5.type;
      if (Array.isArray(type)) {
        type.forEach(function(t) {
          return types[t] = true;
        });
      } else if (type) {
        types[type] = true;
      }
    }
    addDefaultValueCompletions(schema5, separatorAfter, collector, arrayDepth = 0) {
      let hasProposals = false;
      if (isDefined2(schema5.default)) {
        let type = schema5.type;
        let value = schema5.default;
        for (let i = arrayDepth; i > 0; i--) {
          value = [value];
          type = "array";
        }
        let label;
        if (typeof value == "object") {
          label = "Default value";
        } else {
          label = value.toString().replace(doubleQuotesEscapeRegExp, '"');
        }
        collector.add({
          kind: this.getSuggestionKind(type),
          label,
          insertText: this.getInsertTextForValue(value, separatorAfter, type),
          insertTextFormat: InsertTextFormat.Snippet,
          detail: localize9("json.suggest.default", "Default value")
        });
        hasProposals = true;
      }
      if (Array.isArray(schema5.examples)) {
        schema5.examples.forEach((example) => {
          let type = schema5.type;
          let value = example;
          for (let i = arrayDepth; i > 0; i--) {
            value = [value];
            type = "array";
          }
          collector.add({
            kind: this.getSuggestionKind(type),
            label: this.getLabelForValue(value),
            insertText: this.getInsertTextForValue(value, separatorAfter, type),
            insertTextFormat: InsertTextFormat.Snippet
          });
          hasProposals = true;
        });
      }
      this.collectDefaultSnippets(schema5, separatorAfter, collector, {
        newLineFirst: true,
        indentFirstObject: true,
        shouldIndentWithTab: true
      });
      if (!hasProposals && typeof schema5.items === "object" && !Array.isArray(schema5.items)) {
        this.addDefaultValueCompletions(schema5.items, separatorAfter, collector, arrayDepth + 1);
      }
    }
    addEnumValueCompletions(schema5, separatorAfter, collector, isArray) {
      if (isDefined2(schema5.const) && !isArray) {
        collector.add({
          kind: this.getSuggestionKind(schema5.type),
          label: this.getLabelForValue(schema5.const),
          insertText: this.getInsertTextForValue(schema5.const, separatorAfter, schema5.type),
          insertTextFormat: InsertTextFormat.Snippet,
          documentation: this.fromMarkup(schema5.markdownDescription) || schema5.description
        });
      }
      if (Array.isArray(schema5.enum)) {
        for (let i = 0, length = schema5.enum.length; i < length; i++) {
          const enm = schema5.enum[i];
          let documentation = this.fromMarkup(schema5.markdownDescription) || schema5.description;
          if (schema5.markdownEnumDescriptions && i < schema5.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {
            documentation = this.fromMarkup(schema5.markdownEnumDescriptions[i]);
          } else if (schema5.enumDescriptions && i < schema5.enumDescriptions.length) {
            documentation = schema5.enumDescriptions[i];
          }
          collector.add({
            kind: this.getSuggestionKind(schema5.type),
            label: this.getLabelForValue(enm),
            insertText: this.getInsertTextForValue(enm, separatorAfter, schema5.type),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation
          });
        }
      }
    }
    getLabelForValue(value) {
      if (value === null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return JSON.stringify(value);
      }
      return "" + value;
    }
    collectDefaultSnippets(schema5, separatorAfter, collector, settings, arrayDepth = 0) {
      if (Array.isArray(schema5.defaultSnippets)) {
        for (const s of schema5.defaultSnippets) {
          let type = schema5.type;
          let value = s.body;
          let label = s.label;
          let insertText;
          let filterText;
          if (isDefined2(value)) {
            const type2 = s.type || schema5.type;
            if (arrayDepth === 0 && type2 === "array") {
              const fixedObj = {};
              Object.keys(value).forEach((val, index) => {
                if (index === 0 && !val.startsWith("-")) {
                  fixedObj[`- ${val}`] = value[val];
                } else {
                  fixedObj[`  ${val}`] = value[val];
                }
              });
              value = fixedObj;
            }
            insertText = this.getInsertTextForSnippetValue(value, separatorAfter, settings);
            label = label || this.getLabelForSnippetValue(value);
          } else if (typeof s.bodyText === "string") {
            let prefix = "", suffix = "", indent = "";
            for (let i = arrayDepth; i > 0; i--) {
              prefix = prefix + indent + "[\n";
              suffix = suffix + "\n" + indent + "]";
              indent += this.indentation;
              type = "array";
            }
            insertText = prefix + indent + s.bodyText.split("\n").join("\n" + indent) + suffix + separatorAfter;
            label = label || insertText;
            filterText = insertText.replace(/[\n]/g, "");
          }
          collector.add({
            kind: s.suggestionKind || this.getSuggestionKind(type),
            label,
            sortText: s.sortText || s.label,
            documentation: this.fromMarkup(s.markdownDescription) || s.description,
            insertText,
            insertTextFormat: InsertTextFormat.Snippet,
            filterText
          });
        }
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getInsertTextForSnippetValue(value, separatorAfter, settings, depth) {
      const replacer = (value2) => {
        if (typeof value2 === "string") {
          if (value2[0] === "^") {
            return value2.substr(1);
          }
          if (value2 === "true" || value2 === "false") {
            return `"${value2}"`;
          }
        }
        return value2;
      };
      return stringifyObject2(value, "", replacer, { ...settings, indentation: this.indentation }, depth) + separatorAfter;
    }
    addBooleanValueCompletion(value, separatorAfter, collector) {
      collector.add({
        kind: this.getSuggestionKind("boolean"),
        label: value ? "true" : "false",
        insertText: this.getInsertTextForValue(value, separatorAfter, "boolean"),
        insertTextFormat: InsertTextFormat.Snippet,
        documentation: ""
      });
    }
    addNullValueCompletion(separatorAfter, collector) {
      collector.add({
        kind: this.getSuggestionKind("null"),
        label: "null",
        insertText: "null" + separatorAfter,
        insertTextFormat: InsertTextFormat.Snippet,
        documentation: ""
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getLabelForSnippetValue(value) {
      const label = JSON.stringify(value);
      return label.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1");
    }
    getCustomTagValueCompletions(collector) {
      const validCustomTags = filterInvalidCustomTags(this.customTags);
      validCustomTags.forEach((validTag) => {
        const label = validTag.split(" ")[0];
        this.addCustomTagValueCompletion(collector, " ", label);
      });
    }
    addCustomTagValueCompletion(collector, separatorAfter, label) {
      collector.add({
        kind: this.getSuggestionKind("string"),
        label,
        insertText: label + separatorAfter,
        insertTextFormat: InsertTextFormat.Snippet,
        documentation: ""
      });
    }
    getDocumentationWithMarkdownText(documentation, insertText) {
      let res = documentation;
      if (this.doesSupportMarkdown()) {
        insertText = insertText.replace(/\${[0-9]+[:|](.*)}/g, (s, arg) => {
          return arg;
        }).replace(/\$([0-9]+)/g, "");
        res = this.fromMarkup(`${documentation}
 \`\`\`
${insertText}
\`\`\``);
      }
      return res;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getSuggestionKind(type) {
      if (Array.isArray(type)) {
        const array = type;
        type = array.length > 0 ? array[0] : null;
      }
      if (!type) {
        return CompletionItemKind2.Value;
      }
      switch (type) {
        case "string":
          return CompletionItemKind2.Value;
        case "object":
          return CompletionItemKind2.Module;
        case "property":
          return CompletionItemKind2.Property;
        default:
          return CompletionItemKind2.Value;
      }
    }
    getCurrentWord(doc, offset) {
      let i = offset - 1;
      const text = doc.getText();
      while (i >= 0 && ' 	\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1) {
        i--;
      }
      return text.substring(i + 1, offset);
    }
    fromMarkup(markupString) {
      if (markupString && this.doesSupportMarkdown()) {
        return {
          kind: MarkupKind.Markdown,
          value: markupString
        };
      }
      return void 0;
    }
    doesSupportMarkdown() {
      if (this.supportsMarkdown === void 0) {
        const completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
        this.supportsMarkdown = completion && completion.completionItem && Array.isArray(completion.completionItem.documentationFormat) && completion.completionItem.documentationFormat.indexOf(MarkupKind.Markdown) !== -1;
      }
      return this.supportsMarkdown;
    }
    findItemAtOffset(seqNode, doc, offset) {
      for (let i = seqNode.items.length - 1; i >= 0; i--) {
        const node = seqNode.items[i];
        if (isNode(node)) {
          if (node.range) {
            if (offset > node.range[1]) {
              return i;
            } else if (offset >= node.range[0]) {
              return i;
            }
          }
        }
      }
      return 0;
    }
  };
  var isNumberExp = /^\d+$/;
  function convertToStringValue(param) {
    let value;
    if (typeof param === "string") {
      value = param;
    } else {
      value = "" + param;
    }
    if (value.length === 0) {
      return value;
    }
    if (value === "true" || value === "false" || value === "null" || isNumberExp.test(value)) {
      return `"${value}"`;
    }
    if (value.indexOf('"') !== -1) {
      value = value.replace(doubleQuotesEscapeRegExp, '"');
    }
    let doQuote = !isNaN(parseInt(value)) || value.charAt(0) === "@";
    if (!doQuote) {
      let idx = value.indexOf(":", 0);
      for (; idx > 0 && idx < value.length; idx = value.indexOf(":", idx + 1)) {
        if (idx === value.length - 1) {
          doQuote = true;
          break;
        }
        const nextChar = value.charAt(idx + 1);
        if (nextChar === "	" || nextChar === " ") {
          doQuote = true;
          break;
        }
      }
    }
    if (doQuote) {
      value = `"${value}"`;
    }
    return value;
  }
  function evaluateTab1Symbol(value) {
    return value.replace(/\$\{1:(.*)\}/, "$1");
  }
  function isParentCompletionItem(item) {
    return "parent" in item;
  }
  function JSONSchemaSelection() {
  }
  var YamlDefinition = class {
    constructor(telemetry2) {
      this.telemetry = telemetry2;
    }
    getDefinition(document2, params) {
      try {
        const yamlDocument = yamlDocumentsCache.getYamlDocument(document2);
        const offset = document2.offsetAt(params.position);
        const currentDoc = matchOffsetToDocument(offset, yamlDocument);
        if (currentDoc) {
          const [node] = currentDoc.getNodeFromPosition(offset, new TextBuffer(document2));
          if (node && isAlias(node)) {
            const defNode = node.resolve(currentDoc.internalDocument);
            if (defNode && defNode.range) {
              const targetRange = Range2.create(document2.positionAt(defNode.range[0]), document2.positionAt(defNode.range[2]));
              const selectionRange = Range2.create(document2.positionAt(defNode.range[0]), document2.positionAt(defNode.range[1]));
              return [LocationLink.create(document2.uri, targetRange, selectionRange)];
            }
          }
        }
      } catch (err) {
        this.telemetry.sendError("yaml.definition.error", { error: convertErrorToTelemetryMsg(err) });
      }
      return void 0;
    }
  };
  var SchemaPriority;
  (function(SchemaPriority2) {
    SchemaPriority2[SchemaPriority2["SchemaStore"] = 1] = "SchemaStore";
    SchemaPriority2[SchemaPriority2["SchemaAssociation"] = 2] = "SchemaAssociation";
    SchemaPriority2[SchemaPriority2["Settings"] = 3] = "Settings";
  })(SchemaPriority || (SchemaPriority = {}));
  function getLanguageService(schemaRequestService2, workspaceContext, connection, telemetry2, yamlSettings, clientCapabilities) {
    const schemaService = new YAMLSchemaService(schemaRequestService2, workspaceContext);
    const completer = new YamlCompletion(schemaService, clientCapabilities, yamlDocumentsCache, telemetry2);
    const hover = new YAMLHover(schemaService, telemetry2);
    const yamlDocumentSymbols = new YAMLDocumentSymbols(schemaService, telemetry2);
    const yamlValidation = new YAMLValidation(schemaService, telemetry2);
    const formatter = new YAMLFormatter();
    const yamlCodeActions = new YamlCodeActions(clientCapabilities);
    const yamlCodeLens = new YamlCodeLens(schemaService, telemetry2);
    const yamlLinks = new YamlLinks(telemetry2);
    const yamlDefinition = new YamlDefinition(telemetry2);
    new JSONSchemaSelection(schemaService, yamlSettings, connection);
    registerCommands(commandExecutor, connection);
    return {
      configure: (settings) => {
        schemaService.clearExternalSchemas();
        if (settings.schemas) {
          schemaService.schemaPriorityMapping = /* @__PURE__ */ new Map();
          settings.schemas.forEach((settings2) => {
            const currPriority = settings2.priority ? settings2.priority : 0;
            schemaService.addSchemaPriority(settings2.uri, currPriority);
            schemaService.registerExternalSchema(settings2.uri, settings2.fileMatch, settings2.schema, settings2.name, settings2.description, settings2.versions);
          });
        }
        yamlValidation.configure(settings);
        hover.configure(settings);
        completer.configure(settings);
        formatter.configure(settings);
        yamlCodeActions.configure(settings);
      },
      registerCustomSchemaProvider: (schemaProvider) => {
        schemaService.registerCustomSchemaProvider(schemaProvider);
      },
      findLinks: yamlLinks.findLinks.bind(yamlLinks),
      doComplete: completer.doComplete.bind(completer),
      doValidation: yamlValidation.doValidation.bind(yamlValidation),
      doHover: hover.doHover.bind(hover),
      findDocumentSymbols: yamlDocumentSymbols.findDocumentSymbols.bind(yamlDocumentSymbols),
      findDocumentSymbols2: yamlDocumentSymbols.findHierarchicalDocumentSymbols.bind(yamlDocumentSymbols),
      doDefinition: yamlDefinition.getDefinition.bind(yamlDefinition),
      resetSchema: (uri) => {
        return schemaService.onResourceChange(uri);
      },
      doFormat: formatter.format.bind(formatter),
      doDocumentOnTypeFormatting,
      addSchema: (schemaID, schema5) => {
        return schemaService.saveSchema(schemaID, schema5);
      },
      deleteSchema: (schemaID) => {
        return schemaService.deleteSchema(schemaID);
      },
      modifySchemaContent: (schemaAdditions) => {
        return schemaService.addContent(schemaAdditions);
      },
      deleteSchemaContent: (schemaDeletions) => {
        return schemaService.deleteContent(schemaDeletions);
      },
      deleteSchemasWhole: (schemaDeletions) => {
        return schemaService.deleteSchemas(schemaDeletions);
      },
      getFoldingRanges: getFoldingRanges2,
      getCodeAction: (document2, params) => {
        return yamlCodeActions.getCodeAction(document2, params);
      },
      getCodeLens: (document2) => {
        return yamlCodeLens.getCodeLens(document2);
      },
      resolveCodeLens: (param) => yamlCodeLens.resolveCodeLens(param)
    };
  }
  var languageId = "yaml";
  async function schemaRequestService(uri) {
    const response = await fetch(uri);
    if (response.ok) {
      return response.text();
    }
    throw new Error(`Schema request failed for ${uri}`);
  }
  var telemetry = {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    send() {
    },
    sendError(name, properties) {
      console.error("monaco-yaml", name, properties);
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    sendTrack() {
    }
  };
  initialize2((ctx, { enableSchemaRequest, languageSettings }) => {
    const languageService = getLanguageService(
      // @ts-expect-error Type definitions are wrong. This may be null.
      enableSchemaRequest ? schemaRequestService : null,
      null,
      null,
      telemetry,
      null
    );
    languageService.configure(languageSettings);
    const getTextDocument = (uri) => {
      const models = ctx.getMirrorModels();
      for (const model of models) {
        if (String(model.uri) === uri) {
          return TextDocument.create(uri, languageId, model.version, model.getValue());
        }
      }
    };
    return {
      doValidation(uri) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.doValidation(document2, Boolean(languageSettings.isKubernetes));
        }
      },
      doComplete(uri, position) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.doComplete(
            document2,
            position,
            Boolean(languageSettings.isKubernetes)
          );
        }
      },
      doDefinition(uri, position) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.doDefinition(document2, { position, textDocument: { uri } });
        }
      },
      doHover(uri, position) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.doHover(document2, position);
        }
      },
      format(uri, options) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.doFormat(document2, options);
        }
      },
      resetSchema(uri) {
        return languageService.resetSchema(uri);
      },
      findDocumentSymbols(uri) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.findDocumentSymbols2(document2, {});
        }
      },
      findLinks(uri) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.findLinks(document2);
        }
      },
      getCodeAction(uri, range, diagnostics) {
        const document2 = getTextDocument(uri);
        if (document2) {
          return languageService.getCodeAction(document2, {
            range,
            textDocument: { uri },
            context: { diagnostics }
          });
        }
      }
    };
  });
})();
